<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我不会编程的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://evanmeek.github.io/"/>
  <updated>2020-02-09T05:19:36.030Z</updated>
  <id>https://evanmeek.github.io/</id>
  
  <author>
    <name>EvanMeek</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux下连接蓝牙</title>
    <link href="https://evanmeek.github.io/2020/02/09/Linux%E4%B8%8B%E8%BF%9E%E6%8E%A5%E8%93%9D%E7%89%99/"/>
    <id>https://evanmeek.github.io/2020/02/09/Linux下连接蓝牙/</id>
    <published>2020-02-09T04:47:42.000Z</published>
    <updated>2020-02-09T05:19:36.030Z</updated>
    
    <content type="html"><![CDATA[<p align="center">Linux下连接蓝牙设备的方式</p><a id="more"></a><h1 id="准备事项"><a href="#准备事项" class="headerlink" title="准备事项"></a>准备事项</h1><h2 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h2><p>如果是你Arch用户，你可以直接:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> pacman -S bluez bluz-utils pulseaudio-bluetooth pavucontrol</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>bluez</code>包是提供蓝牙的协议栈</li><li><code>bluez-utils</code>包含了各式各样的工具</li><li><code>pulseaudio-bluetooth</code>为提供音频服务器</li><li><code>pavucontrol</code> 音频服务的图形化控制软件</li></ul><h2 id="启动蓝牙服务"><a href="#启动蓝牙服务" class="headerlink" title="启动蓝牙服务"></a>启动蓝牙服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> systemctl enable bluetooth</span><br><span class="line"><span class="meta">&gt;</span> systemctl start bluetooth</span><br></pre></td></tr></table></figure><h2 id="启动音频服务"><a href="#启动音频服务" class="headerlink" title="启动音频服务"></a>启动音频服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> pulseaudio -k                   # 确保没有pulseaudio启动</span><br><span class="line"><span class="meta">&gt;</span> pulseaudio --start              # 启动pulseaudio服务</span><br></pre></td></tr></table></figure><h2 id="将当前用户添加到lp用户组"><a href="#将当前用户添加到lp用户组" class="headerlink" title="将当前用户添加到lp用户组"></a>将当前用户添加到lp用户组</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> sudo usermo -a -G lp $USER</span><br></pre></td></tr></table></figure><h1 id="连接蓝牙"><a href="#连接蓝牙" class="headerlink" title="连接蓝牙"></a>连接蓝牙</h1><p>这里以连接我耳机来举例</p><p>使用<code>bluetoothctl</code>命令，开始连接:</p><ol><li>键入<code>power on</code>打开控制电源器</li><li>键入<code>scan on</code>扫描附近的蓝牙设备</li><li>键入<code>scan off</code>关闭扫描（如果扫描出来你的设备再关闭）</li><li>键入<code>devices</code>命令可以查看已经扫描过的设备</li><li>键入<code>agent on</code>打开代理</li><li>键入<code>pair $MAC</code>进行配对（如果是陌生设备才需要配对，$MAC代表了MAC地址，支持Tab<br>补全)</li><li>键入<code>trust $MAC</code> 如果你的设备是无PIN码的，可以这样手动认证。</li><li>键入<code>connect $MAC</code>连接设备</li></ol><p>下面为一个实例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[bluetooth]#</span> power on</span><br><span class="line">[CHG] Controller 84:C5:A6:00:59:64 Class: 0x001c010c</span><br><span class="line">Changing power on succeeded</span><br><span class="line">[CHG] Controller 84:C5:A6:00:59:64 Powered: yes</span><br><span class="line"><span class="meta">[bluetooth]#</span> scan on</span><br><span class="line">Discovery started</span><br><span class="line">[CHG] Controller 84:C5:A6:00:59:64 Discovering: yes</span><br><span class="line">[NEW] Device 67:68:09:5E:69:C8 67-68-09-5E-69-C8</span><br><span class="line">[NEW] Device 60:21:6D:9E:D9:E8 60-21-6D-9E-D9-E8</span><br><span class="line"><span class="meta">[bluetooth]#</span> scan off</span><br><span class="line">[CHG] Device 60:21:6D:9E:D9:E8 TxPower is nil</span><br><span class="line">[CHG] Device 60:21:6D:9E:D9:E8 RSSI is nil</span><br><span class="line">[CHG] Device 67:68:09:5E:69:C8 RSSI is nil</span><br><span class="line">[CHG] Controller 84:C5:A6:00:59:64 Discovering: no</span><br><span class="line">Discovery stopped</span><br><span class="line"><span class="meta">[bluetooth]#</span> devices </span><br><span class="line">Device E8:29:58:44:FE:D6 mobike</span><br><span class="line">Device E0:DC:FF:DC:5A:88 我永远喜欢Linux</span><br><span class="line">Device 94:BF:2D:90:7C:F9 EvanMeek的 Beats Studio³</span><br><span class="line">Device 74:40:BB:C4:04:D4 74-40-BB-C4-04-D4</span><br><span class="line">Device 67:68:09:5E:69:C8 67-68-09-5E-69-C8</span><br><span class="line">Device 60:21:6D:9E:D9:E8 60-21-6D-9E-D9-E8</span><br><span class="line"><span class="meta">[bluetooth]#</span> agent on</span><br><span class="line">Agent is already registered</span><br><span class="line"><span class="meta">[bluetooth]#</span> pair 94:BF:2D:90:7C:F9 </span><br><span class="line">Attempting to pair with 94:BF:2D:90:7C:F9</span><br><span class="line"><span class="meta">[bluetooth]#</span> connect 94:BF:2D:90:7C:F9 </span><br><span class="line">Attempting to connect to 94:BF:2D:90:7C:F9</span><br><span class="line">[CHG] Device 94:BF:2D:90:7C:F9 Connected: yes</span><br><span class="line">Connection successful</span><br><span class="line">[CHG] Device 94:BF:2D:90:7C:F9 ServicesResolved: yes</span><br><span class="line">[EvanMeek的 Beats Studio³]#</span><br></pre></td></tr></table></figure><blockquote><p>本文参考<br><a href="https://wiki.archlinux.org/index.php/Bluetooth" target="_blank" rel="noopener">ArchLinux Bluetooth Wiki</a><br><a href="http://blog.lujun9972.win/blog/2017/07/18/%E5%9C%A8archlinux%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%93%9D%E7%89%99%E8%80%B3%E6%9C%BA/" target="_blank" rel="noopener">暗无天日的博客</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;Linux下连接蓝牙设备的方式&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://evanmeek.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
      <category term="蓝牙" scheme="https://evanmeek.github.io/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title>《十年》</title>
    <link href="https://evanmeek.github.io/2020/02/05/%E3%80%8A%E5%8D%81%E5%B9%B4%E3%80%8B/"/>
    <id>https://evanmeek.github.io/2020/02/05/《十年》/</id>
    <published>2020-02-05T13:07:30.000Z</published>
    <updated>2020-02-05T15:14:51.754Z</updated>
    
    <content type="html"><![CDATA[<p align="center">送給那個她</p> <a id="more"></a><p align="center"><br>如果那兩個字沒有顫抖<br><br>我不會發現 我難受<br><br>怎麼說出口 也不過是分手<br><br>如果對於明天沒有要求<br><br>牽牽手就像旅遊<br><br>成千上萬個門口 總有一個人要先走<br><br>懷抱既然不能逗留<br><br>何不在離開的時候<br><br>一邊享受 一邊淚流<br><br>十年之前<br><br>我不認識你 你不屬於我<br><br>我們還是一樣 陪在一個陌生人左右<br><br>走過漸漸熟悉的街頭<br><br>十年之後<br><br>我們是朋友 還可以問候<br><br>只是那種溫柔 再也找不到擁抱的理由<br><br>情人最後難免淪爲 朋友<br><br>直到和你做了多年朋友<br><br>才明白我的眼淚<br><br>不是爲你而流 也爲別人而流<br></p>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;送給那個她&lt;/p&gt;
    
    </summary>
    
      <category term="個人感想" scheme="https://evanmeek.github.io/categories/%E5%80%8B%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>解決Linux下Minecraft無法輸入中文的問題</title>
    <link href="https://evanmeek.github.io/2020/01/31/%E8%A7%A3%E6%B1%BALinux%E4%B8%8BMinecraft%E7%84%A1%E6%B3%95%E8%BC%B8%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E5%95%8F%E9%A1%8C/"/>
    <id>https://evanmeek.github.io/2020/01/31/解決Linux下Minecraft無法輸入中文的問題/</id>
    <published>2020-01-31T09:42:57.000Z</published>
    <updated>2020-01-31T10:51:29.360Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章解決Linux下Minecraft無法輸入中文的問題.</p><a id="more"></a><h1 id="廢話"><a href="#廢話" class="headerlink" title="廢話"></a>廢話</h1><p>自從我用Linux開始，玩得最多的遊戲是Minecraft，可是Minecraft在Linux下無法使用輸入<br>法，這讓我這個國內的玩家十分憋屈，單人遊戲還好，聯機時不能交流就比較憋屈了。</p><p>網上流傳着一些腳本可以使得使用腳本時跳出一個輸入框，然後自動複製輸入的內容，並且<br>關閉輸入框，可是這樣十分麻煩，並且像Minecraft中的木牌等物品是無法粘貼的，所以腳<br>本也是有侷限性的。</p><p>今天無意中看到一個Mods，貌似是專門解決Linux用戶無法輸入中文的情況，那麼下面就讓<br>我們開始解決這個問題吧！</p><h1 id="正題"><a href="#正題" class="headerlink" title="正題"></a>正題</h1><p><strong>僅支持1.12.2帶有forge的Minecraft</strong></p><p>下載由<code>Yesterday17</code>開發的<br><a href="https://github.com/Yesterday17/KokoaLinux/releases" title="KokaoLinux" target="_blank" rel="noopener">KokoaLinux</a>模組，然後將這個模組丟到<code>mods</code>目錄下啓動遊戲即可。</p><h2 id="效果圖"><a href="#效果圖" class="headerlink" title="效果圖"></a>效果圖</h2><p><img src="/2020/01/31/解決Linux下Minecraft無法輸入中文的問題/../解決Linux下Minecraft無法輸入中文的問題/效果圖.gif" alt="效果圖" title="效果圖"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章解決Linux下Minecraft無法輸入中文的問題.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://evanmeek.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
      <category term="Minecraft" scheme="https://evanmeek.github.io/tags/Minecraft/"/>
    
  </entry>
  
  <entry>
    <title>Doom Emacs Tramp Sending卡死问题</title>
    <link href="https://evanmeek.github.io/2020/01/22/Doom-Emacs-Tramp-Sending%E5%8D%A1%E6%AD%BB%E9%97%AE%E9%A2%98/"/>
    <id>https://evanmeek.github.io/2020/01/22/Doom-Emacs-Tramp-Sending卡死问题/</id>
    <published>2020-01-22T02:13:12.000Z</published>
    <updated>2020-01-22T04:44:27.711Z</updated>
    
    <content type="html"><![CDATA[<p>在使用DoomEmacs<a href="https://github.com/bbatsov/prelude/issues/594的" target="_blank" rel="noopener">https://github.com/bbatsov/prelude/issues/594的</a> sudo-thin-file函数时出现不能输入密码的解决方案。<br><a id="more"></a></p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><blockquote><p>使用 sudo-this-file函数出现:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tramp: Sending Password</span><br></pre></td></tr></table></figure><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>原因是因为projectile占用了minibuffer，当Tramp试图请求输入密码时就会出现问题。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>我在这个Issue找到的<a href="https://github.com/bbatsov/prelude/issues/594" title="外部链接-&gt;Github" target="_blank" rel="noopener">解决方案</a></p><p>我是在<code>Domm Emacs</code>的<code>config.el</code>里加上下面代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(projectile-global-mode)</span><br><span class="line">(set projectile-mode-line &quot; Projectile&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>TG群里的Citreu还说可以设置~/.authinfo解决，这样好像更加安全。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用DoomEmacs&lt;a href=&quot;https://github.com/bbatsov/prelude/issues/594的&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/bbatsov/prelude/issues/594的&lt;/a&gt; sudo-thin-file函数时出现不能输入密码的解决方案。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="折腾日记" scheme="https://evanmeek.github.io/categories/%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="Emacs" scheme="https://evanmeek.github.io/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>ProxyChains入门使用教程</title>
    <link href="https://evanmeek.github.io/2020/01/07/ProxyChains%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://evanmeek.github.io/2020/01/07/ProxyChains入门使用教程/</id>
    <published>2020-01-07T08:59:41.000Z</published>
    <updated>2020-01-22T04:44:27.731Z</updated>
    
    <content type="html"><![CDATA[<p>身为天朝的一名开发者，fq已经成为必备技能了。ProxyChains就是一个强大的强制代理工<br>具。<br><a id="more"></a></p><h1 id="ArchLinux"><a href="#ArchLinux" class="headerlink" title="ArchLinux"></a>ArchLinux</h1><p>Arch下直接安装<code>ProxyChains-ng</code>这个包即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S proxychains-ng</span><br></pre></td></tr></table></figure><p>安装好后编辑<code>/etc/proxychains.conf</code>。</p><p>找到最下面的<code>[ProxyList]</code>，往里面添加映射的类型，例如我想要<code>http</code>协议走代理就可<br>以这么写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"># add proxy here ...</span><br><span class="line"># meanwile</span><br><span class="line"># defaults set to &quot;tor&quot;</span><br><span class="line">http 127.0.0.1 8000</span><br><span class="line"># socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure><p>使用非常简单，可以直接在需要走代理的程序前加上<code>proxychains</code>即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ proxychains curl google.com</span><br><span class="line">[proxychains] config file found: /etc/proxychains.conf</span><br><span class="line">[proxychains] preloading /usr/lib/libproxychains4.so</span><br><span class="line">[proxychains] DLL init: proxychains-ng 4.14</span><br><span class="line">[proxychains] Strict chain  ...  127.0.0.1:8000  ...  google.com:80  ...  OK</span><br><span class="line">&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;</span><br><span class="line">&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;</span><br><span class="line">&lt;H1&gt;301 Moved&lt;/H1&gt;</span><br><span class="line">The document has moved</span><br><span class="line">&lt;A HREF="http://www.google.com/"&gt;here&lt;/A&gt;.</span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure><p>如果闲命令太长可以写一个<code>alias</code>，在这里就不演示了。</p><h1 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h1><p>如果你使用包管理器，例如<code>homebrew</code>可以直接执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> brew install proxychains-ng</span><br></pre></td></tr></table></figure><p>但是会很慢，所以有第二种方式————手动编译安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> git clone --depth 1 git@github.com:rofl0r/proxychains-ng</span><br><span class="line"><span class="meta">&gt;</span> cd proxychains-ng &amp;&amp; ./configure --prfix=/usr --sysconfdir=/etc</span><br><span class="line"><span class="meta">&gt;</span> make &amp;&amp; make install</span><br><span class="line"><span class="meta">&gt;</span> sudo make install-config # 生成proxychains.conf配置文件</span><br></pre></td></tr></table></figure><p>这里可能会有一个坑————执行<code>make install</code>出错，想要解决很简单：</p><p>进入<code>configure</code>目录，修改<code>config.mak</code>文件，将<code>bindir=/usr/bin</code>改为<code>bindir=/usr/local/bin</code></p><p>就算你安装好，并且配置好文件后可能照样不能使用，这一切都是因为苹果电脑的<code>SIP</code>保<br>护系统，有关<code>SIP</code>的信息自己谷歌一下，再考虑要不要关闭。</p><p>关闭分两种，一种是让<code>SIP</code>进入debug模式，再一种就是永久关闭（除非手动启动）。</p><p>首先重启Mac，在重启时按住<code>option</code>键，进入选择启动磁盘项，然后按组合键<br><code>Command+R</code>即可进入恢复模式，进入恢复模式后先验证密码，然后在<strong>顶栏找到实用工具<br>的终端</strong>,再看下一步吧。</p><p>debug模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> csrutil enable --without debug</span><br></pre></td></tr></table></figure><p>永久关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> csrutil disable</span><br></pre></td></tr></table></figure><p>进行设置了后重启打开终端输入<code>csrutil status</code>，如果显示<code>System IntegrityProtection status:disbaled</code>则说明关闭成功了。</p><p>除了配置文件路径不同其他都跟<code>Arch</code>下配置一样————<code>/usr/local/etc/proxychains.conf</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;身为天朝的一名开发者，fq已经成为必备技能了。ProxyChains就是一个强大的强制代理工&lt;br&gt;具。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件分享" scheme="https://evanmeek.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>《GNU Emacs Lisp编程入门》读书笔记</title>
    <link href="https://evanmeek.github.io/2019/12/21/%E3%80%8AGNU-Emacs-Lisp%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://evanmeek.github.io/2019/12/21/《GNU-Emacs-Lisp编程入门》读书笔记/</id>
    <published>2019-12-21T08:17:25.000Z</published>
    <updated>2020-02-15T05:52:09.947Z</updated>
    
    <content type="html"><![CDATA[<p>借了本Elisp的书，不厚，200多页，大概一周(两周(一個月))就能看完吧!</p><a id="more"></a><h1 id="第一章-列表处理"><a href="#第一章-列表处理" class="headerlink" title="第一章 列表处理"></a>第一章 列表处理</h1><p>列表是Lisp的基础。</p><h2 id="Lisp列表"><a href="#Lisp列表" class="headerlink" title="Lisp列表"></a>Lisp列表</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>简单的Lisp列表书写形式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;(rose violet daisy buttercup) ;; =&gt; (rose violet daisy buttercup)</span><br></pre></td></tr></table></figure><p>这个简单的列表中的四个元素时四种不同花的名称。<strong>元素之间用空格隔开，并且被括号包住。</strong></p><p>另有一种在elisp中常用到的写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+ 2 2) ;; =&gt; 4</span><br></pre></td></tr></table></figure><p>这种写法是Lisp的一个特性————<strong>数据和代码都用相同的方式表示</strong>。</p><p><strong>列表还允许嵌套列表，也就是说列表的元素也可以是列表</strong>。</p><h3 id="Lisp原子"><a href="#Lisp原子" class="headerlink" title="Lisp原子"></a>Lisp原子</h3><p>原子意味着”不可再分”。例如刚刚列表内的’2’或者是’rose’等等，这些都是原子。</p><p>而列表却不是原子，因为<strong>列表是由CAR和CDR与CONS构成的</strong>。</p><p>技术上说，Lisp的列表有三种组合方式:</p><ul><li>括号和括号中由空格分隔的原子</li><li>括号和括号中的其他列表</li><li>括号和括号中的其他列表和原子</li></ul><p><strong>一个列表可以仅有一个原子或完全没有原子</strong></p><p>无任何原子的列表称作空列表: <code>()</code>。你可以把空列表看为原子或列表。</p><p><em>原子和列表可以被称为<strong>符号表达式</strong>(symbolic expression)，又可称为<strong>S-表达式</strong> </em>。</p><p>Lisp编程几乎都是关于列表中的符号的(且有时是关于数字的).</p><p><strong>双引号中的文本，都是单个原子</strong>:<code>&#39;(Info &quot;Name:EvanMeek Age:18 Sex:Men**)</code></p><p>这种被双引号括起来的文本叫做<strong>字符串(string)</strong>。</p><h3 id="列表中的空格"><a href="#列表中的空格" class="headerlink" title="列表中的空格"></a>列表中的空格</h3><p>Lisp中括号的数量无关紧要。下面两个的列表是完全相同的。</p><p>括号多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;(1 2 3 4      5       6) ;; =&gt; (1 2 3 4 5 6)</span><br></pre></td></tr></table></figure></p><p>括号少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;(1 2 3 4 5 6) ;; =&gt; (1 2 3 4 5 6)</span><br></pre></td></tr></table></figure></p><p>适当的在列表中加入一些空格以及换行符可以提高可读性。</p><h3 id="GNU-Emacs帮助你输入列表"><a href="#GNU-Emacs帮助你输入列表" class="headerlink" title="GNU Emacs帮助你输入列表"></a>GNU Emacs帮助你输入列表</h3><p>在Emacs中使用Emacs Lisp模式或Lisp交互模式输入Lisp表达式时可以用<code>Tab</code>按键使光标所在行自动缩排到适当的位置。要使某个区域的表达式都自动缩排的快捷键是<code>C-M-\</code></p><p>并且Emacs会具有括号匹配的功能，以防你迷失在Lisp的括号海洋中。</p><p>有兴趣的可以看下这个知乎提问。<a href="https://www.zhihu.com/question/356026550" target="_blank" rel="noopener">https://www.zhihu.com/question/356026550</a></p><h2 id="运行一个程序"><a href="#运行一个程序" class="headerlink" title="运行一个程序"></a>运行一个程序</h2><p>如果你想运行一段Lisp程序，那么计算机可能会做三种事:</p><ul><li>只返回列表本身;</li><li>提示出错信息;</li><li>将列表中第一个符号作为要执行的命令;<br>大多数情况，我们希望计算机做的是第三件事</li></ul><p>前面我们看到过一些列表的前面有一个单引号”‘“，它其实是Lisp中的一个引用(quote)。它的作用是告诉Lisp不要做对这个列表做任何操作，只返回列表本身即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;(只是返回本身 即可) ;; =&gt; (只是返回本身 即可)</span><br></pre></td></tr></table></figure><p>而如果列表前没有quote，那么列表的第一个符号就会称为Lisp要执行的命令(函数)，后面的则是函数的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+ 1 2 3 4) ;; =&gt; 10</span><br></pre></td></tr></table></figure><p>Emacs中可以将光标放置一对S-表达式后按 <code>C-x C-e</code>就会将表达式读入至Lisp解释器中，进行解释，将结果输出至回显区，英文叫 <code>mini buffer</code>。</p><p>也可以对原子(没有被括号括起来)求值</p><h2 id="产生错误消息"><a href="#产生错误消息" class="headerlink" title="产生错误消息"></a>产生错误消息</h2><p>编写Lisp代码时难免遇到错误，而Lisp解释器会在程序出错时输出报错信息。与其说是报错信息，不如说是有助的信息(书上这么说)。</p><p>下面，我们对一个没有引用并且第一个元素不是一个有意义的符号的列表进行求值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Just Error!) ;; =&gt; Symbol&apos;s function definition is void: Just</span><br></pre></td></tr></table></figure><p>这个输出结果就像是出错了一样，它告诉我们Just符号命令没有定义。也就是说Lisp解释器视图将<code>(Just Error!)</code>当成类似<code>(+ 1 2)</code>这种列表进行求值，但由于后者的第一个元素”+”是有意义的(已定义)，不会有任何问题，而我们编写的列表中第一个元素”Just”是没有任何意义(未定义)的，Lisp解释器不知道怎么办了，只好告诉我们一些有用的信息。</p><p> ##</p><p>我们已经讨论过一些符号或函数，例如”+”。就以”+”为例子，当我们对<code>(+ 2 2)</code>表达式求值时，计算机并不是执行的”+”这个命令，而是执行其对应的指令。我们甚至可以随意改变，例如我把”+”改为”Plus”。</p><h2 id="Lisp解释器"><a href="#Lisp解释器" class="headerlink" title="Lisp解释器"></a>Lisp解释器</h2><p>下面，简单解释下Lisp解释器在对一个列表求值时做了些什么。</p><ul><li>首先，检查列表前是否有单引号(quote)，如果有则直接返回这个列表的输出形式。</li><li>若没有单引号则查看列表的第一个元素，是否有相对应的函数定义，如果有则执行对应的指令。</li><li><p>若没有则提示错误消息。<br>以上就是Lisp解释器的工作方式。但都比较简单，下面将会介绍几种比较复杂的工作方式。</p></li><li><p>第一种。Lisp解释器还可以对符号求值(并不是只能对列表)，但这个符号前不能有单引号和被括号括起。</p></li><li>第二种，Lisp解释器在遇到一些特殊函数时。这些特殊的函数以特殊的方式运行着，这些特殊函数通常被称为特殊表(special form)。见名知意，它用于一些特殊的工作，例如定义函数之类的。</li><li>第三种，Lisp解释器在遇到一些不是特殊表，而是列表的一部分时。这可能意味着是一个嵌套列表，Lisp解释器首先查看列表中是否有另外一个列表，如果有则先解释内部列表，如果内部列表仍然具有一个列表，那么就再次解释更深的列表层级中的列表，最终以此返回结果。</li></ul><p>否则Lisp解释器将会从左往右依次执行。</p><h3 id="字节编译"><a href="#字节编译" class="headerlink" title="字节编译"></a>字节编译</h3><p>Lisp解释器还可以将Lisp代码编译成字节。这样的好处是可以让程序的执行速度更快，缺点是可读性几乎为零。</p><p>被编译成字节码后的源码叫做elc，可以通过命令<code>(byte-compile-file)</code>进行编译。</p><h2 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h2><p>前面我们所得到的一些结果，都是由Lisp解释器求值得到的。求值也就是Lisp解释器处理表达式时进行的操作。</p><p>解释器对表达式求值时几乎总是会返回值，如果没有返回值，通常是会提示一些错误信息。</p><p>解释器对表达式求值不仅会返回值，还可能会有一些附加效果，可能是移动光标或拷贝文件、刷新Buffer之类的动作。</p><h3 id="对一个内部列表求值"><a href="#对一个内部列表求值" class="headerlink" title="对一个内部列表求值"></a>对一个内部列表求值</h3><p>上一节我们讨论过嵌套列表，这一小节解释了为什么内层列表总是首先被求值。首先给出答案:因为内层列表的返回值要被外层列表所使用。</p><p>下面通过一个例子了解这个求值的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+ 1 (+ 2 3))</span><br></pre></td></tr></table></figure><p>我们知道使用快捷键<code>C-x C-e</code>可以对一个表达式求值，那么我们将光标放置<code>(+ 2 3)</code>表达式之后，然后按下这个快捷键，看看会发生什么。很显然，我们得到返回值<code>5</code>，那么再将光标放置整个表达式之后，按下快捷键得到返回值<code>6</code>。这就很好的解释了Lisp解释器对嵌套列表的求值过程。</p><p>我们可以通过快捷键<code>C-h k</code>然后键入<code>C-x C-e</code>查看这个快捷键所对应的符号(命令\函数)，也就是<code>eval-last-sexp</code>。 这个函数的作用是<strong>对最近的一个表达式进行求值，并且将结果打印至输出区域</strong>。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>其他语言中，我们经常将某值赋值给一个变量，但你有见过可以将一个函数赋值给一个变量的语言吗(Python)?</p><p><strong>在Lisp中，我们可以把值赋值给符号，并且这个符号的值可以使Lisp中任意表达式(符号、数字、列表、字符串)</strong>，并且符号的值是可变的，我们把一个有值的符号称为变量。</p><p>前面提到的将一个函数定义赋值给一个符号就是通过Lisp中变量的特性。<strong>Lisp的符号可以同时具有一个函数定义和一个值。</strong>我们可以把这种概念想象成具有多个抽屉的柜子。</p><p>例如变量<code>fill-column</code>是一个有值的符号，对它求值可以获取自动换行的字符数。</p><p>任何值都可以赋给符号，这个操作是:变量与一个值进行绑定。</p><p><code>fill-column</code>只是一个很普通的值而已，如果我们对其求值时加上括号，将会发生一些错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(fill-column) ;; =&gt; Symbol&apos;s function definition is void: fill-column</span><br></pre></td></tr></table></figure><p>这个错误被打印在回显区，很容易可以理解为什么会出现这个错误。因为Lisp解释器将这个列表读入后试图寻找第一个元素与之相联系的函数定义，让而fill-column只是一个值为数字的变量罢了，所以就会引发这个错误。</p><h3 id="符号无值时的错误信息"><a href="#符号无值时的错误信息" class="headerlink" title="符号无值时的错误信息"></a>符号无值时的错误信息</h3><p>下面我对一个没有赋值的符号进行求值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+ 2 2) ;; =&gt; 4</span><br></pre></td></tr></table></figure></p><p>很显然，如果是在这个表达式右括号后执行<code>eval-last-sexp</code>将不会有任何问题，但我们现在将光标移动至<code>+</code>后，执行<code>eval-last-sexp</code>，会引发这个报错提示:<code>Symbol&#39;s value as variable void: +</code>。</p><p>这是因为Lisp解释器将无值的符号当成一个变量处理了，而Lisp解释器却没有找到任何关于<code>+</code>的变量，只找到了函数定义，因为就报错了。</p><h2 id="参量"><a href="#参量" class="headerlink" title="参量"></a>参量</h2><p>参量对应着<code>argument</code>，也就是其他语言中参数的意思。例如<code>(+ 2 3**</code>这个列表的参数就是<code>2</code>和<code>3</code>，而这个<code>+</code>则是函数，<code>+</code>允许由多个参量。</p><p><strong>不同的函数需要不同数目的参量，有些函数甚至不需要参量。</strong></p><h3 id="参量的数据类型"><a href="#参量的数据类型" class="headerlink" title="参量的数据类型"></a>参量的数据类型</h3><p>函数所接收的参量也是有数据类型的限制的，例如<code>+</code>函数就规定其参量的值必须是数字。</p><p>有些函数允许有任意数量个参量，例如<code>concat</code>函数，它将任意多个字符串类型的参量合并为一个字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(concat &quot;My name is:&quot; &quot;EvanMeek&quot;) ;; =&gt; &quot;My name is: EvanMeek&quot;</span><br></pre></td></tr></table></figure><p><strong>请注意，<code>concat</code>函数的参量类型需要字符串并不意味着参量就必须写上字符串，这里指的是参量的值必须是字符串，请不要混淆。</strong></p><p>例如我们可以在<code>concat</code>的参量中写上<code>substring</code>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(concat &quot;Nice to meet &quot; (substring &quot;fuck you&quot; 5 8))</span><br></pre></td></tr></table></figure><p>上面的<code>concat</code>是一个参量必须都为字符串类型且任意数量的函数，而<code>substring</code>是一个可变数量参量且有多种参量类型的函数。<br><code>substring</code>是可以对字符串这种单原子抽取出子字符串的，而这种操作可以取个好玩的名称<code>原子分裂机</code>。</p><h3 id="作为变量和列表的值的参量"><a href="#作为变量和列表的值的参量" class="headerlink" title="作为变量和列表的值的参量"></a>作为变量和列表的值的参量</h3><blockquote><p>上一小节提到————有些函数允许有任意数量个参量，且参量数据类型不同，我们可以理解为有些函数的参量可以是任意任意数量个符号。</p></blockquote><p>这一节，我们将谈谈函数的参量还支持那些。</p><p>函数参量还支持列表和变量，当参量为变量时，Lisp解释器就会寻找是否有有值的变量，如果有就返回值，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;; 结果可能不同，取决于你的Emacs配置。</span><br><span class="line">(+ 2 fill-column) ;; =&gt; 82</span><br></pre></td></tr></table></figure><p>并且参量还可以是一个列表，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+ 2 (+ 3 (+ 4))) ;; =&gt;  9</span><br></pre></td></tr></table></figure><h3 id="数目可变的参量"><a href="#数目可变的参量" class="headerlink" title="数目可变的参量"></a>数目可变的参量</h3><p>前面提到过的函数已经具有这个规则了，参量的数目可变，例如我们已经知道的<code>+</code>函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(+) ;; =&gt; 0</span><br><span class="line">(+ 2) ;; =&gt; 2</span><br></pre></td></tr></table></figure><p>又或是<code>\*</code>函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*) ;; =&gt; 1</span><br><span class="line">(* 2) ;; =&gt; 2</span><br></pre></td></tr></table></figure><p>所以它们都具有一个特性————参量数量可变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(* 1 2 3) ;; =&gt; 66</span><br><span class="line">(+ 1 2 3) ;; =&gt; 6</span><br></pre></td></tr></table></figure><h3 id="用一个错误类型的数据对象作为参量"><a href="#用一个错误类型的数据对象作为参量" class="headerlink" title="用一个错误类型的数据对象作为参量"></a>用一个错误类型的数据对象作为参量</h3><p>试想下，如果我们对函数提供了错误类型的参量会发生什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(+ 2 &apos;hello) ;; =&gt; Wrong type argument: number-or-marker-p,hello</span><br></pre></td></tr></table></figure><p>我们知道<code>+</code>函数的参量必须是数字，而我们传入的参量2的<code>&#39;hello</code>被Lisp解释器操作时会试图将<code>2</code>和<code>&#39;hello</code>的返回值相加，但是<code>&#39;hello</code>的返回值不是一个数字，所以就会引发这个错误。</p><p>让我们来试着解读下Lisp解释器提示的错误信息。首先Lisp解释器明确的告诉了我们————Wrong type argument(参量类型错误)，再是一段我们看不懂的符号<code>number-or-marker-p</code>这个符号意味着:Lisp解释器提示我们<code>+</code>函数的参量所需的数据类型，<code>number</code>也就是数字，而<code>marker</code>是一个标记(Elisp的一个特性，缓冲区的位置是由标记决定的，我们可以通过快捷键C-@C-SPC命令设置标记)， 而<code>p</code>则是Lisp的一个历史问题(早期Lisp程序员中用”p”替代”predicate”用于表示是否为真)，类似的有<code>zerop</code>用于判断参量值是否为零。最后的<code>hello</code>则是我们传给<code>+</code>函数出错的参量的值。</p><h3 id="message函数"><a href="#message函数" class="headerlink" title="message函数"></a>message函数</h3><p><code>message</code>函数用于给用户发送消息。这些消息是被打印在回显区的，它的第一个参量要求为一个<code>FORMAT STRING</code>(可格式化字符串)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(message &quot;Should you sleep now?&quot;) ;; =&gt; Should you sleep now?</span><br></pre></td></tr></table></figure><p>双引号中的文本被打印在回显区(我们看到的是表达式的返回值，而打印只是一个附加效果)，这显得没什么新奇的，我们直接写一个字符串原子并且对其求值貌似也有同样的结果，下面将会介绍格式化字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(message &quot;The name of this buffer is: %s&quot; (buffer-name)) ;; =&gt; &quot;The name of this buffer is: 《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br></pre></td></tr></table></figure><p>这输出了我当前buffer的名称。重点在于第一个参量中存在一段特殊的子串<code>%s</code>，<code>message</code>函数的第二个参量的值将用于它，这个<code>%s</code>代表了接收一段字符传，类似的还有<code>%d</code>用于接收一个十进制数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(message &quot;The value of fill-column is %d&quot; fill-column) ;; =&gt; &quot;The value of fill-column is 80&quot;</span><br></pre></td></tr></table></figure><p>这些特殊子串都支持变量、列表或符号，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(message &quot;我想吃%s，各来%d斤!&quot; (concat &quot;苹果、&quot; &quot;梨子、&quot; &quot;葡萄&quot;) (+ 1 1)) ;; =&gt; &quot;我想吃苹果、梨子、葡萄，各来2斤!&quot;</span><br></pre></td></tr></table></figure><p>从第二个参量开始将会一次取代第一个参量中特殊子串的位置。</p><h2 id="给一个变量赋值"><a href="#给一个变量赋值" class="headerlink" title="给一个变量赋值"></a>给一个变量赋值</h2><p>这一小节学习为一个变量赋值，常用的操作有<code>set</code>、<code>setq</code>、<code>let</code>，在这节主要将<code>set</code>和<code>setq</code>。并且描述这两个函数是如何工作的。</p><h3 id="使用set函数"><a href="#使用set函数" class="headerlink" title="使用set函数"></a>使用set函数</h3><p>我们要为<code>flowers</code>符号附上一个列表值，那么可以这么写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(set &apos;flowers &apos;(菊花 百合 玫瑰)) ;; =&gt; (菊花 百合 玫瑰)</span><br></pre></td></tr></table></figure></p><p>这意味着我们将列表<code>菊花 百合...</code>绑定给了<code>flowers</code>符号。</p><p>两个参量的引用是为了让其不要求值，所以你可以知道<code>set</code>函数的第一个参量最好要加上引用，这大概是很常用的搭配。</p><h3 id="使用setq函数"><a href="#使用setq函数" class="headerlink" title="使用setq函数"></a>使用setq函数</h3><p><code>setq</code>函数与<code>set</code>函数很相似，它们只有一个区别，就是<code>setq</code>函数会自动给第一个参量加上引用，例如用<code>setq</code>完成上一小节的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(setq flowers &apos;(菊花 百合 玫瑰)) ;; =&gt; (菊花 百合 玫瑰)</span><br></pre></td></tr></table></figure><p>并且它们俩都是可以为多个变量绑定多个值的，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(setq 学生 &apos;(学号 地址 姓名 电话)</span><br><span class="line">      老师 &apos;(教师号 地址 姓名 电话))</span><br><span class="line">学生 ;; =&gt; (学号 地址 姓名 电话)</span><br><span class="line">老师 ;; =&gt; (教师号 地址 姓名 电话)</span><br></pre></td></tr></table></figure><p>其中参量二绑定给参量一，参量四绑定给参量三，以此类推。</p><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>就是用<code>setq</code>函数完成了一个递增的操作。</p><p>首先生成一个初始化器，再生成一个递增器，再进行输出数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(setq count 0) ;; 初始器</span><br><span class="line">(setq count (1+ count)) ;; 递增器</span><br><span class="line">count ;;输出</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>记录一下，加油努力，毕竟书中都说了，我已经跨过了最陡峭的那段山路。</p><ul><li>Lisp程序由表达式组成，表达式是列表或单个原子。</li><li>列表由0个或更多的原子或内部列表组成，原子或列表之间由空格隔开，并由括号括起来，列表可为空。</li><li>原子是多字符的符号(如fill-column)，单字符的符号(如+号)，双引号之间的字符串或者数字。</li><li>对数字求值就是其本身</li><li>对双引号之间的字符串求值也是其本身</li><li>当对一个符号求值时，将返回它的值。</li><li>当对一个列表求值时，Lisp解释器查看列表首符号绑定在其上的函数定义，并执行其指令。</li><li>单引号告诉Lisp解释器返回后续表达式的书写形式，而不是像没有单引号时那样对其求值。</li><li>参量是传递给函数的信息。除了作为列表的第一个元素的函数之外，通过对列表的其余元素求值来计算函数的参量。</li><li><p>当对一个函数求值时总是返回一个值(除非得到错误信息)。另外，它也可以完成一些被称作附带效果的操作。在许多情况下，一个函数的主要目的是产生一个附带效果。</p><p><strong>最后，希望这篇博客可以记录好第一章所讲。</strong></p></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>一个一个来，题目写在博客内吧…</p><ul><li>通过对一个不在括号内的适当符号求值，产生一个错误信息。</li></ul><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个不存在的变量 ;; =&gt; Symbol&apos;s value as variable is void: 一个不存在的变量</span><br></pre></td></tr></table></figure><ul><li>通过对一个在括号内的适当符号求值，产生一个错误信息。</li></ul><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(又一个不存在的符号) ;; =&gt; Symbol&apos;s function definition is void: 又一个不存在的符号</span><br></pre></td></tr></table></figure><ul><li>创建一个每次增加2而不是1的计数器。</li></ul><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(setq count 0) ;; 初始器 </span><br><span class="line">(setq count (+ 2 count)) ;; 递增器</span><br><span class="line">count ;;输出</span><br></pre></td></tr></table></figure><ul><li>写一个表达式，当对它求值时，它在回显区输出一条消息。</li></ul><p>解答:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(message &quot;这段消息是要输出至%s%s的&quot; &apos;回显 &quot;区&quot;)</span><br></pre></td></tr></table></figure><h1 id="第二章-求值实践"><a href="#第二章-求值实践" class="headerlink" title="第二章 求值实践"></a>第二章 求值实践</h1><p>这一章主要讲了关于buffer的一些知识，讲了一些关于buffer的函数，并且讲解了一些buffer的注意事项。</p><h2 id="缓冲区名"><a href="#缓冲区名" class="headerlink" title="缓冲区名"></a>缓冲区名</h2><p>讲了两个函数，分别是<code>(buffer-name)</code>以及<code>(buffer-file-name)</code>。</p><p>首先得清楚buffer和文件的概念，buffer的中文翻译叫做缓冲区，它其实是将文件中的内容拷贝到Emacs中，所以在我们修改buffer时，文件并不会改动，只有当我们进行保存修改时才会。而文件是保存在磁盘上的信息，人们常常在修改buffer时说成”我在修改xx文件”，这严格意义上讲是错误的，但人们都知道其实我只是在修改buffer，而不是那个文件，只不过说成文件罢了，所以各位小伙伴不要误解。</p><p>计算机没有人类那么聪明，所以大家在写代码时要分清楚这两个的不同。</p><figure class="highlight plain"><figcaption><span>(buffer-name) ;; </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(buffer-file-name) ;; =&gt;&quot;/home/evanmeek/Documents/Blog/source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br></pre></td></tr></table></figure><p><strong>表达式<code>(buffer-name)</code>用于获取当前buffer的名称而<code>(buffer-file-name)</code>用于获取当前buffer所对应文件的完整路径</strong>，还要说明一点，并不是所有的buffer都有所对应的文件，例如<code>\*scratch\*</code>buffer就没有所对应的文件。</p><h2 id="获得缓冲区"><a href="#获得缓冲区" class="headerlink" title="获得缓冲区"></a>获得缓冲区</h2><p>如果想获得缓冲区本身，那么可以使用<code>current-buffer</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(buffer-name) ;; =&gt; &quot;《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br><span class="line">(current-buffer) ;; =&gt; #&lt;buffer 《GNU-Emacs-Lisp编程入门》读书笔记.md&gt;</span><br></pre></td></tr></table></figure><p>我们发现这两个函数的返回值挺相似的，但实际上他们却完全不同，<code>buffer-name</code>获取到的只是一个名称罢了，而<code>current-buffer</code>函数获取到的是一个名称所指向的对象或实体。举个生活上的例子:你对小明说:”小明，帮我拿个苹果”，然后小明就拿给了你”苹”和”果”字，显然这不是你真正想要的，你想要的是叫苹果的那个实体，可以吃的，有维生素的水果。经过这个例子，希望大家都能理解。 </p><h2 id="切换缓冲区"><a href="#切换缓冲区" class="headerlink" title="切换缓冲区"></a>切换缓冲区</h2><p>先介绍一个函数————<code>other-buffer</code>，这个函数用于发挥最近常打开过的buffer对象。例如最近常在<code>\*scratch\*</code>与<code>test.el</code>之间切换buffer，那么当前buffer为<code>\*scratch\*</code>时调用<code>(other-buffer)</code>时将会返回<code>test.el</code>的buffer对象。</p><p>再介绍一个函数————<code>switch-to-buffer</code>，这个函数接收一个<code>Buffer</code>对象的参量，可以切换当前buffer为<code>Buffer</code>参量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(buffer-name) ;; =&gt; &quot;《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br><span class="line">(other-buffer) ;; =&gt; #&lt;buffer *Backtrace*&gt;</span><br><span class="line">;; 根据最近最常打开过的buffer对象切换buffer</span><br><span class="line">(switch-to-buffer (other-buffer))</span><br><span class="line">(buffer-name) ;; =&gt; &quot;*Backtrace*&quot;</span><br></pre></td></tr></table></figure><p>如果想要回到上一个buffer可以键入键序列<code>C-x b RET</code>，RET是回车。</p><p>前面几次提到<code>调用(call)</code>这个概念，实际上Lisp解释器对一个列表的首元素为一个函数进行处理时，就是在调用那个函数。</p><h2 id="缓冲区大小和位点的定位"><a href="#缓冲区大小和位点的定位" class="headerlink" title="缓冲区大小和位点的定位"></a>缓冲区大小和位点的定位</h2><p>先为大家介绍下四个函数:</p><ul><li><code>(point)</code><br>;; 获取当前光标在当前buffer的位点。</li><li><code>(buffer-size)</code><br>;; 获取当前buffer的字符数(包括空格)</li><li><code>(point-min)</code><br>;; 获取当前光标中位点的最小可能值。默认是1,除非设置了变窄,毕竟默认是从第一个字符开始</li><li><code>(point-max)</code><br>;; 获取当前光标中位点的最大可能值。默认是最后一个字符的point,除非设置了增宽。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;; 获取当前buffer的字符数(包括空格)</span><br><span class="line">(buffer-size) ;; =&gt; 10636</span><br><span class="line">;; 获取当前光标在当前buffer的位点。</span><br><span class="line">(point) ;; =&gt; 10525</span><br><span class="line">;; 获取当前光标中位点的最小可能值。默认是1,除非设置了变窄,毕竟默认是从第一个字符开始</span><br><span class="line">(point-min) ;; =&gt; 1</span><br><span class="line"></span><br><span class="line">;; 获取当前光标中位点的最大可能值。默认是最后一个字符的point,除非设置了增宽。</span><br><span class="line">(point-max) ;; =&gt; 10670</span><br></pre></td></tr></table></figure><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>找一个文件，对它进行操作，将光标移动到缓冲区的中间部分。找出它的缓冲区名、文件名、长度、和你在文件中的位置。</p><ul><li>缓冲区名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(buffer-name) ;; =&gt; &quot;《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br></pre></td></tr></table></figure><ul><li>文件名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(buffer-file-name) ;; =&gt; &quot;/home/evanmeek/Documents/Blog/source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;</span><br></pre></td></tr></table></figure><ul><li>长度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(buffer-size) ;; =&gt; 11005</span><br></pre></td></tr></table></figure><ul><li>在文件中的位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(point) ;; =&gt; 11033</span><br></pre></td></tr></table></figure><h1 id="第三章-如何编写函数定义"><a href="#第三章-如何编写函数定义" class="headerlink" title="第三章 如何编写函数定义"></a>第三章 如何编写函数定义</h1><p>本章内容较多，不止于函数定义，还介绍了一些常用的函数。</p><h2 id="defun-特殊表"><a href="#defun-特殊表" class="headerlink" title="defun 特殊表"></a>defun 特殊表</h2><p><code>defun</code>不以通常的方式对它的参量求值，因为它是特殊表。</p><p>这节将简单描述函数定义的过程。</p><p>一个函数定义在<code>defun</code>之后最多可有5个部分:</p><ul><li>符号名，这个符号指向了这个函数的定义。</li><li>一个列表，包含了要传给函数的参量。若没有任何参量要传递，那么可以写空列表。</li><li>这个函数的文档，由双引号括住，此选项为可选。</li><li>使当前函数成为一个交互式函数的列表，此选项为可选。交互式函数将会在后的小节讲到。</li><li>函数的主题，也就是一系列的命令。<br>下面是一个包含了五个部分的函数模板:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defun funciton-name (arguments...)</span><br><span class="line">  &quot;optional-documentation&quot;</span><br><span class="line">  (interactive argument-passing-info) ;; optional</span><br><span class="line">  body...)</span><br></pre></td></tr></table></figure><p>我们通过这个模板写一个简单的函数吧，这个函数的功能呢是让其参量乘以7。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(defun multiply-by-seven (number)</span><br><span class="line">  &quot;使number(参量)乘以7&quot;</span><br><span class="line">  (* number 7))</span><br></pre></td></tr></table></figure><p>这个函数的函数名就是<code>multiply-by-seven</code>，而函数名后面的列表也就是函数的参量，当我们调用函数时，传递给函数的参量的值就会被绑定到这个<code>number</code>上。并且<code>number</code>也可以为其他的名称，这取决于写代码的人，你可以改为<code>multiplicand</code>，这可能更符合函数定义的意思。并且这里的<code>number</code>的范围是仅在函数定义内才有效的，如果我们在函数定义外对<code>number</code>求值，可能会返回个错误信息。所以说，参量列表内的参量名可以是任意的，只要不与参量列表内的其他参量相同即可。这就比如：你班上的外号叫李大头，那么在这个班里的李大头代表的人就是你，而如果是在学校中，也有人的名字叫李大头，这时这个李大头就不代表你了。</p><p>跟随参量列表后的叫做函数文档，它的作用是当我们或任何人使用<code>C-h f</code>并键入函数名时所查看的函数帮助文档中的文本。这里还要注意一点，有些函数例如<code>apropos</code>在查看函数文档时会只显示文档的第一行，所以我们要在第一行就尽量写清楚这个函数的作用。通过<code>C-h f</code>查看函数文档将会弹出一个<code>\*Help\*</code>Buffer。</p><p>而这个例子的第三行就是函数的主体(往往比例子里多很多**，它是一个列表，功能是将<code>number</code>乘以7。</p><p>函数定义好了，但我们不要直接尝试调用，我先告诉你们调用的方式吧，<strong>把函数名作为一个列表的首元素，其余的作为参量</strong>最后eval即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(multiply-by-seven 7)</span><br></pre></td></tr></table></figure></p><p>但可千万不要急着求值，因为肯定会报错。这主要是因为你只是写好了函数定义，并没有把函数定义给安装上。</p><h2 id="安装函数定义"><a href="#安装函数定义" class="headerlink" title="安装函数定义"></a>安装函数定义</h2><p>将光标移动到我们写好的函数定义之后，eval一下即可安装好函数。安装完成后的函数就被包含在Emacs之中了，直到退出Emacs之前。如果已经尝试安装函数定义的童鞋应该已经发现了，在我们eval函数定义后，会在回显区显示函数名，这就代表我们成功安装了这个函数。</p><h3 id="改变函数定义"><a href="#改变函数定义" class="headerlink" title="改变函数定义"></a>改变函数定义</h3><p>想要修改已经安装好的函数定义很简单，我们只需要重新安装一遍即可，例如我们想要将<code>multiply-by-seven</code>函数改为用<code>+</code>来实现，这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defun multiply-by-seven (number)</span><br><span class="line">  &quot;使number(参量)加7次&quot;</span><br><span class="line">  (+ number number number number number number number)) ;; =&gt; multiply-by-seven</span><br><span class="line"></span><br><span class="line">(multiply-by-seven 7) ;; =&gt; 49</span><br></pre></td></tr></table></figure><p>所以编写Emacs Lisp代码时的流程通常是:<strong>写函数，装函数，测函数，改函数，装函数</strong>。</p><h2 id="使函数成为交互式函数"><a href="#使函数成为交互式函数" class="headerlink" title="使函数成为交互式函数"></a>使函数成为交互式函数</h2><p>交互式函数的特点是可以通过<code>M-x</code>调用，还可以通过键序列调用，例如常用的移动光标<code>C-n</code>就是一个交互式函数，并且交互式函数是不会自动将返回值输出至回显区的，因为让一个函数称为交互式函数通常被认为是想得到函数的附加效果，而不是返回值。</p><p>想要使一个函数称为交互式函数，可以在函数定义时，将<code>defun</code>特殊表开头的列表的第四个元素写成一个<code>interactive</code>特殊表开头的列表。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defun multiply-by-seven-interactive (number)</span><br><span class="line">  &quot;打印 number(参量) 乘以 7</span><br><span class="line">这是个交互式函数&quot;</span><br><span class="line">  (interactive &quot;p&quot;)</span><br><span class="line">  (message &quot;7 * %d = %d&quot; number (* number 7))) ;; =&gt; multiply-by-seven-interactive</span><br></pre></td></tr></table></figure><p>安装好这个函数后，可以有三种方式调用它:</p><ul><li>对表达式<code>(multiply-by-seven-interactive 7**</code>求值</li><li>键入<code>C-u</code>然后输入一个数字作为函数的参量，键入<code>M-x</code>然后键入函数名最后键入<code>RET</code>。</li><li>还有一种暂时没搞成功，等学到16章的第7节就知道了。</li></ul><p><strong>交互式函数不会自动将返回值打印至回显区</strong> 并且当使用第二种调用方式时，没有在<code>C-u</code>之后键入数字的话将会以默认值4来替代。</p><h3 id="交互的multiply-by-seven函数"><a href="#交互的multiply-by-seven函数" class="headerlink" title="交互的multiply-by-seven函数"></a>交互的multiply-by-seven函数</h3><p>我们为<code>multiply-by-seven</code>函数定义了交互式版本，但没有解释其中的<code>(interactive &quot;p&quot;)</code>列表是个什么东西，这里就说一下。</p><p>首先<code>(interactive &quot;p&quot;)</code>中的<code>p</code>代表将接收一个前缀参量，这个前缀参量也就是我们通过<code>C-u 数字 M-x 函数名</code>这种方式调用时的<code>数字</code>了，例如这个数字是<code>5</code>那么就会把<code>5</code>传递给<code>number</code>参量，然后在<code>message</code>函数中的<code>(* 7 5)</code>求值，最终由于函数是一个交互式函数，所以函数不会自动将返回值输出到回显区中，而<code>message</code>函数的返回值原本是带双引号的，由于是交互式函数，我们要的只是函数带来的附加效果，而不是返回值。</p><h3 id="interactive函数的不同选项"><a href="#interactive函数的不同选项" class="headerlink" title="interactive函数的不同选项"></a>interactive函数的不同选项</h3><p>前面已经解释过<code>interactive</code>函数的<code>p</code>选项，其实<code>interactive</code>特殊表有20多个预定义的选项，我们可以结合多个选项使得将信息正确交互地选送给函数。</p><p>下面介绍两个选项，首先是<code>r</code>，<strong>它可以让Emacs将位点所在区域的开始值和结束值作为函数的两个参量</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(interactive &quot;r&quot;) ;; =&gt; (13945 13978)</span><br></pre></td></tr></table></figure><p>再则是<code>B</code>选项，<strong>它可告诉Emacs用缓冲区的名字作为函数的参量</strong>，它会让Emacs在小缓冲区提示用户输入缓冲区名字，并将跟在<code>B</code>后面的字符串作为提示，而且Emacs还会进行函数名的补全（按TAB）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;; 会出来一个交互式的窗口</span><br><span class="line">(interactive &quot;B请输入Buffer名称:&quot;) ;; =&gt; (&quot;test.el&quot;)</span><br></pre></td></tr></table></figure><p>下面再看一个例子，可以获取任意Buffer所对应的文件路径以及位点的开始及结束点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defun get-buffer_name-point_start-point_end (buffer start end)</span><br><span class="line">  &quot;获取buffer所对应的文件以及位点的开始结束值&quot;</span><br><span class="line">  (interactive &quot;B请输入Buffer名称: \nr&quot;)</span><br><span class="line">  (message &quot;Buffer-file:%s\npoint-start:%d\npoint-end:%d&quot;(buffer-file-name (get-buffer buffer)) start end))</span><br></pre></td></tr></table></figure><p>通过<code>interactive</code>的<code>B</code>选项获取任意buffer的名称，再通过<code>r</code>选项后去位点的开始和结束值。最后在输出时通过<code>get-buffer</code>获取Buffer对象，从而达到目的。</p><p><strong><code>interactive</code>是支持控制字符的，例如上个例子中用到的<code>\n</code>。并且<code>interactive</code>还可以无参量，这样的话跟<code>mark-whole-buffer</code>函数差不多。如果<code>interactive</code>的选项不能满足你的要求，那么你可以将参量传递给<code>nteractive</code>做为一个列表。</strong></p><h3 id="永久地安装代码"><a href="#永久地安装代码" class="headerlink" title="永久地安装代码"></a>永久地安装代码</h3><p>前面我们写了那么多的函数，在我们没有关闭Emacs之前这些函数都是可以被我们随意求值的，但是当我们关闭Emacs之后再打开就必须重新安装函数才能求值了。所以有几种方式可以永久地安装函数或其他的代码。</p><ul><li>如果代码作为个人使用，可以把函数定义的代码放到<code>.emacs</code>初始化文件中，当启动Emacs时，将会自动对<code>.emacs</code>文件中的代码求值。</li><li>如果代码很多，可以将函数定义存放至多个文件，然后使用<code>load</code>函数使得emacs对单独存放函数的文件求值。</li><li>如果是当前计算机其他用户需要使用的代码，可以将代码放入<code>site-init.el</code>文件中，这样使得所有的用户都可以使用你的代码。</li><li>如果你想让你的作为全世界的人使用，那么你可以将代码放到互联网上，或着给自由软件基金会发送一份拷贝，它有可能被加入下一个发行版本中。</li></ul><p><strong>Emacs在过去的年代里成长的道路————奉献。</strong></p><h2 id="let函数"><a href="#let函数" class="headerlink" title="let函数"></a>let函数</h2><p><code>let</code>函数与<code>defun</code>函数一样，都是EmacsLisp中的特殊表。</p><p><code>let</code>函数将一个符号附着到或者绑定到一个值上。这些被绑定的值是只能在<code>let</code>函数之内使用，就像说<code>defun</code>特殊表举的例子，两个同名的事物在不同的场景下代表了不同的意思，例如你的房子和你朋友的房子都是房子，你对你朋友说，你要粉刷房子，在你听来是要粉刷你家的房子，但你朋友有可能会认为你要粉刷他的房子。</p><p>而<code>let</code>函数就避免了这种问题，在<code>let</code>函数中绑定的变量都只能在<code>let</code>函数中访问，这就是局部变量的概念。</p><p><code>let</code>函数跟<code>setq</code>以及<code>set</code>函数有个很大的区别就在于:</p><ul><li><code>let</code>函数绑定的变量可有任意个 <code>setq</code>和<code>set</code>只能有一个</li><li><code>let</code>函数可以执行一个或多个列表。</li><li><code>let</code>函数绑定的变量都是局部的。</li></ul><h3 id="let表达式的各个部分"><a href="#let表达式的各个部分" class="headerlink" title="let表达式的各个部分"></a>let表达式的各个部分</h3><p><code>let</code>表达式分为三个部分，第一个就是<code>let</code>符号，第二个是变量列表，第三个是主体。</p><p><strong>第二个部分的变量列表是由一个列表组成的，这个列表内可以是任意多个符号或任意多个由两个元素组成且第一个元素必定是符号的列表。*</strong></p><p><strong>第三个部分是<code>let</code>表达式主体，由任意多个列表组成。</strong></p><p><code>let</code>表达式的模板看起来像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(let varlist body...)</span><br></pre></td></tr></table></figure><p>其中变量列表的符号是由<code>let</code>特殊表赋初始化值的变量.符号本身的初始值是nil.而作为两元素列表的首元素的每一个符号被绑定到对第二个元素求值后的返回值.</p><p>所以一个简单的变量列表看起来可能是这样的:<code>(apple (pear 10))</code>.在这个例子中,<code>apple</code>的值是nil,因为我们没有为其赋予初始值.而<code>pear</code>的值为10.</p><p>那么当变量是由两个元素的列表组成,就可以是下面这样的模板:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(let ((variable value) (variable value) variable...)</span><br><span class="line">  (body1)</span><br><span class="line">  (body2)...)</span><br></pre></td></tr></table></figure><h3 id="let表达式例子"><a href="#let表达式例子" class="headerlink" title="let表达式例子"></a>let表达式例子</h3><p>现在需要创建一些关于水果的栗子,不同的水果有不同的数量.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(let (apple (pear 10) (banana &apos;4斤) watermelon)</span><br><span class="line">  (message &quot;苹果数量:%S\t梨子数量:%d\t香蕉数量:%s\t西瓜数量:%S&quot; apple pear banana watermelon)) ;; =&gt; &quot;苹果数量:nil梨子数量:10香蕉数量:4斤西瓜数量:nil&quot;</span><br></pre></td></tr></table></figure><p>我们创建了两个初始值为nil的变量<code>apple</code>和<code>watermelon</code>,以及一个绑定到10的变量pear,还有一个绑定到<code>4斤</code>的变量banana.随后在<code>let</code>主体中将创建的变量都用<code>message</code>函数打印在回显区.</p><h3 id="let语句中的未初始化变量"><a href="#let语句中的未初始化变量" class="headerlink" title="let语句中的未初始化变量"></a>let语句中的未初始化变量</h3><p>在<code>let</code>表达式的变量列表中,允许不给予变量初始化值,那么Lisp解释器将会为其默认绑定到nil值上.</p><p>并且,如果没有给予初始值,那么它可以称作:<code>作为独立的原子出现</code>.</p><h2 id="if特殊表"><a href="#if特殊表" class="headerlink" title="if特殊表"></a>if特殊表</h2><p><code>if</code>函数是除了<code>defun</code>/<code>let</code>特殊表之外的一个特殊表,它用于让计算机做一些判断的工作.</p><p>首先来看<code>if</code>函数的模板:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(if if-part</span><br><span class="line">    then)</span><br></pre></td></tr></table></figure><p>其工作方式是：首先测试<code>if-part</code>的返回值是否不为nil，如果不为nil，那么就执行<code>then</code>的表达式。</p><p><strong>通常会把then部分放在if-part的下一行，这样更有利于阅读。</strong></p><p>下面做一个简单的栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(if (&gt; 5 4)</span><br><span class="line">    (message &quot;5 比 4 大!&quot;)) ;; =&gt; &quot;5 比 4 大!&quot;</span><br></pre></td></tr></table></figure><p>其中<code>&gt;</code>函数测试它的第一个参量和第二个参量进行比较大小，如果第一个参量大于第二个参量则返回“真”，否则返回nil。</p><p>可往往在日常编码中，<code>if-part</code>的值不能直接确定，它可能是一个表达式，又可能是一个函数调用。</p><p>例如测试参量可能被绑定在函数定义的参量上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(defun type-of-animal (animal-name)</span><br><span class="line">  &quot;根据animal-name打印信息到回显区</span><br><span class="line">如果animal-name是符号&apos;fierce则返回&apos;tiger&quot;</span><br><span class="line">  (if (equal animal-name &apos;fierce)</span><br><span class="line">      (message &quot;It&apos;s a tiger&quot;)))</span><br><span class="line">(type-of-animal &apos;fierce) ;; =&gt; &quot;It’s a tiger&quot;</span><br></pre></td></tr></table></figure><p><strong>type-of-animal函数详解</strong></p><p>首先<code>type-of-animal</code>是包含了两个特殊表模板，分别是<code>defun</code>和<code>if</code>。<code>type-of-animal</code>是函数名，紧跟着函数名的是函数参量列表，然后跟着的是函数的文档。最后函数的主体内是一个if函数，if函数的的一个参量是一个列表，这个列表的首元素的符号是一个函数<code>equal</code>，在Lisp中，<code>equal</code>函数用于比较参量一和参量二是否相等，如果相等则输出<code>if</code>函数的第二个参量，也是一个列表，这个列表的首元素是符号且是函数<code>message</code>，将<code>It&#39;s a tiger</code>打印至回显区。</p><h2 id="if-then-else表达式"><a href="#if-then-else表达式" class="headerlink" title="if-then-else表达式"></a>if-then-else表达式</h2><p>其实<code>if-then-else</code>表达式就是在<code>if</code>特殊表之上加了一个参量，其他没什么不同，新增的参量是当参量一的值为nil时，对参量三求值。</p><p>它的函数模板可以写成这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(if true-or-false-test</span><br><span class="line">    action-to-carry-out-if-the-test-returns-true</span><br><span class="line">  action-to-carry-out-if-the-test-returns-false)</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(if (&gt; 4 5)</span><br><span class="line">  (message &quot;5 大于 4!&quot;)</span><br><span class="line">(message &quot;4 小于 5&quot;)) ;; =&gt; &quot;4 小于 5&quot;</span><br></pre></td></tr></table></figure><p>通过这个例子，我们发现当<code>if</code>函数的第一参量值为nil时就会对第三参量求值。并且第三参量的缩进也要少于第二参量。</p><p>那我们现在将<code>type-of-animal</code>函数改造成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(defun type-of-animal (animal-name) ;second version</span><br><span class="line">  &quot;根据animal-name打印信息到回显区</span><br><span class="line">如果animal-name是符号&apos;fierce则输出&apos;It&apos;s tiger!否则输出Tt not fierce&quot;</span><br><span class="line">  (if (equal animal-name &apos;fierce)</span><br><span class="line">      (message &quot;It&apos;s tiger&quot;)</span><br><span class="line">    (message &quot;It not fierce&quot;)))</span><br><span class="line">(type-of-animal &apos;fierce) ;; =&gt;&quot;It’s tiger&quot;</span><br><span class="line">(type-of-animal &apos;notfierce)  ;; =&gt; &quot;It not fierce&quot;</span><br></pre></td></tr></table></figure><h2 id="Lisp中的真与假"><a href="#Lisp中的真与假" class="headerlink" title="Lisp中的真与假"></a>Lisp中的真与假</h2><p>Lisp中所有除了nil的都是真，nil也就是我们常说的假，nil有多种意思，一种就是nil代表假，另一种则是代表空列表，但往往都把空列表写成<code>()</code>，而当Lisp解释器对表达式求值时，只要值不是nil或空列表那么都是真，不管得到的值为一个数字或字符串或列表，它都代表真。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(if nil</span><br><span class="line">    &apos;true</span><br><span class="line">  &apos;false) ;; =&gt; false</span><br><span class="line">(if t</span><br><span class="line">    &apos;true</span><br><span class="line">  &apos;false) ;; =&gt; true</span><br></pre></td></tr></table></figure><p>真也有另外一种表示方式，在表达式求值后没什么可返回时就会返回<code>t</code>，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&gt; 5 4) ;; =&gt; t</span><br></pre></td></tr></table></figure><h2 id="save-excursion函数"><a href="#save-excursion函数" class="headerlink" title="save-excursion函数"></a>save-excursion函数</h2><p>各位还记得什么是位点(point)，什么是标记(mark)吗?</p><p>Emacs是一个文本编辑器，主要还是与文本打交道，那么<code>save-excursion函数</code>就是与文本打交道的一个经典函数。</p><p>先让我们来回顾一下位点与标记:</p><ul><li><p>位点(point)：及当前buffer中光标所在字符位置，例如当光标置于buffer的开头，那么point应该是1，若置于buffer的末尾，那么point就是当前buffer的字符数了。</p></li><li><p>标记(mark)：标记是buffer的另外一个位置，其中一个就是位点。在buffer中可以自定义很多标记，这样可以方便我们跳转至某个位点。设置标记的函数是<code>(set-mark-command)</code>，它绑定了一个键序列<code>C-SPC</code>，如果此时想要快速跳转至某个标记点，就可以使用命令<code>(exehange-point-and-mark</code>快速回到标记处，它绑定了一个键序列<code>C-x C-x</code>，并且还会将当初的位点设置一个标记，方便来回跳转。</p></li></ul><p><strong>位点与标记之间的缓冲区叫做现域(region)</strong>，有很多条命令是专用于操作现域的，例如:<code>center-region|count-lines-region|kill-region|print-region</code></p><p>前面将了很多关于位点与标记的知识，下面正式介绍<code>save-excursion</code>函数，这个函数的作用主要是将位点和标记的当前位置保存，然后当其他会影响位点或标记的函数执行完后，再将标记的位点复原。 </p><p><code>save-excursion</code>函数模板:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(save-excursion</span><br><span class="line">  body...)</span><br></pre></td></tr></table></figure><p><strong>注意，<code>save-excursion</code>函数的函数体允许有多条表达式，但是只返回最后一条表达式的值。</strong></p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>这一章学的东西还是挺多的，下面我就把书中的所有文字一字不差的抄下来。</p><p>先说几个提到但是没有过多解释的函数:</p><ul><li><p>eval-last-sexp<br>对光标所处的位点前的最后一个符号表达式求值。如果这个函数激活时没有参量，那么将返回值输出在回显区，否则将打印在当前缓冲区中。</p></li><li><p>defun<br>定义函数。这个特殊表最多可有五个部分：函数名、传送给函数的参量的模板、文档、一个可选的交互函数声明以及函数体。</p></li><li><p>interactiv<br>向解释器声明这个函数可以被交互的使用，并且这个特殊表还可以用一个字符串，分成单个或多个部分，依次传送信息至这个函数的参量。 </p></li><li><p>let<br>声明在<code>let</code>表达式主体中使用的变量列表并且给它们赋初始值，初始值要么是nil，要么是一个指定的值，然后对<code>let</code>表达式主体的其他表达式求值并返回最后一个表达式的值。</p></li><li><p>save-excursion<br>对这个函数主体求值前，记录位点和标记的值以及当前缓冲区。求值后恢复位点和标记。</p></li><li><p>if<br>对函数的第一个参量求值，如果值为真，则对第二个参量求值，否则对第三个参量求值。</p></li><li><p>equal、eq<br>测试两个对象的结构或内容是否相等用equal，测试两个对象是否完全相当用eq</p></li><li><p>&lt; &gt; &lt;= &gt;=<br>用于判断第一个参量的值是否大于/小于/大于或等于/小于或等于第二个参量的值，如果是则返回真，否则返回nil</p></li><li><p>message<br>用于往回显区内打印消息</p></li><li><p>setq set<br>setq 用于将第一个参量的值绑定到第二个参量的值，而第一个参量的值由<code>setq</code>自动加上引用。<br>set 用于将第一个参量的值绑定到第二个参量的值，但是不会自动为第一个参量加上引用。</p></li><li><p>buffer-name<br>这个函数用于获取一个缓冲区的名字</p></li><li><p>buffer-file-name<br>这个函数用于获取缓冲区所对饮的名字</p></li><li><p>current-buffer<br>这个函数用于获取当前缓冲区的buffer对象</p></li><li><p>other-buffer<br>返回最近选择过的缓冲区</p></li><li><p>switch-to-buffer<br>选择一个缓冲区</p></li><li><p>set-buffer<br>设置当前缓冲区为某一个缓冲区</p></li><li><p>buffer-size<br>返回当前缓冲区的字符数</p></li><li><p>point<br>返回当前光标所对应缓冲区的位置</p></li><li><p>point-min<br>返回当前缓冲区最小的字符数</p></li><li><p>point-max<br>返回当前缓冲区最大的字符数</p></li></ul><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><ul><li>编写一个非交互的函数，这个函数将其第一个参量(是一个数)的值翻倍。然后使这个函数成为一个交互函数</li></ul><p>非交互:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defun double(number)</span><br><span class="line">  &quot;使number翻倍&quot;</span><br><span class="line">  (setq number (* number 2)))</span><br><span class="line"></span><br><span class="line">(double 10) ;; =&gt; 20</span><br></pre></td></tr></table></figure><p>交互式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defun double(number)</span><br><span class="line">  &quot;使number翻倍&quot;</span><br><span class="line">  (interactive &quot;n请输入要翻倍的数字: &quot;)</span><br><span class="line">  (setq number (* number 2))</span><br><span class="line">  (message &quot;翻倍后:%d&quot; number))</span><br></pre></td></tr></table></figure><ul><li>编写一个函数，测试<code>fill-column</code>的当前值是否大于传送给函数参量的值，如果是则打印适当的信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(defun is-bigger-to-fill-column (number)</span><br><span class="line">  &quot;判断number是否比fill-column大&quot;</span><br><span class="line">  (if (&gt; number fill-column)</span><br><span class="line">      (message &quot;%d比fill-column要大&quot; number)</span><br><span class="line">    (message &quot;%d比fill-column要小&quot; number)))</span><br><span class="line"></span><br><span class="line">(is-bigger-to-fill-column 79) ;; =&gt; &quot;79比fill-column要小&quot;</span><br><span class="line">(is-bigger-to-fill-column 81) ;; =&gt; &quot;81比fill-column要大&quot;</span><br></pre></td></tr></table></figure><h1 id="第四章-与缓冲区有关的函数"><a href="#第四章-与缓冲区有关的函数" class="headerlink" title="第四章 与缓冲区有关的函数"></a>第四章 与缓冲区有关的函数</h1><p>本章将会介绍大量的函数定义。</p><h2 id="查找更多的信息"><a href="#查找更多的信息" class="headerlink" title="查找更多的信息"></a>查找更多的信息</h2><p>可以使用<code>C-h f</code>查看一个函数所对应的文档，使用<code>C-h v</code>查看一个变量所对应的文档，如果要在源代码文件中查看函数定义，可以使用函数<code>find-tags</code>，跳到相应的位置。</p><p>Lisp代码可以分为多个模块或包，如果想要查看某个模块的帮助，可以键入<code>C-h p</code>。</p><h2 id="简化的beginning-of-buffer函数定义"><a href="#简化的beginning-of-buffer函数定义" class="headerlink" title="简化的beginning-of-buffer函数定义"></a>简化的beginning-of-buffer函数定义</h2><p>对于<code>beginning-of-buffer</code>函数你们可能已经使用过了，其绑定的键序列是<code>M-&lt;</code>。其作用是将当前光标移动至buffer的起始处。</p><p>下面我们将自己实现一个简单的<code>beginning-of-buffer</code>函数。</p><p>让我们来看看我们需要做什么事:</p><ol><li>首先这个函数得是个交互式函数，以便我们能通过键序列调用或用<code>M-x</code>调用。</li><li>其次我们需要记录个位点为标记</li><li>最后我们再跳转到buffer起始处</li></ol><p>相比与真正的<code>beginning-of-buffer</code>函数定义，没有考虑一些复杂的选项，但是我们先完成这个简化版本吧!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defun simple-beginning-of-buffer ()</span><br><span class="line">  &quot;移动光标至buffer开始处&quot;</span><br><span class="line">  (interactive)</span><br><span class="line">  (push-mark)</span><br><span class="line">  (goto-char (point-min)))</span><br></pre></td></tr></table></figure><p>这个<code>defun</code>函数包含了5个部分:</p><ol><li>首先是这个函数的函数名————<code>simple-beginning-of-buffer</code></li><li>再就是函数的文档</li><li>随后是交互式表达式</li><li>然后记录位点为标记</li><li>最后跳转至buffer的起始处 </li></ol><p>由于这个函数是无参量的，所以交互式表达式内也不用写任何字符串，而<code>push-mark</code>函数默认将<code>point</code>加入到标记中，最后通过<code>goto-char</code>跳转至<code>point-min</code>的位置。如果想要回到原来的位置可以使用<code>C-x C-x</code>。</p><p>既然已经写了一个<code>simple-beginning-of-buffer</code>那我们也可以写一个<code>simple-end-of-buffer</code>吧!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defun simple-end-of-buffer()</span><br><span class="line">  &quot;移动光标至buffer结束处&quot;</span><br><span class="line">  (interactive)</span><br><span class="line">  (push-mark)</span><br><span class="line">  (goto-char (point-max)))</span><br></pre></td></tr></table></figure><p>最后则是，如果遇到不了解的函数，可以将光标放置函数之上，键入键序列<code>C-h f RET</code>即可。 </p><h2 id="mark-whole-buffer函数定义"><a href="#mark-whole-buffer函数定义" class="headerlink" title="mark-whole-buffer函数定义"></a>mark-whole-buffer函数定义</h2><p><code>mark-whole-buffer</code> 不比<code>simple-end-of-buffer</code>复杂多少。</p><p>这次我们来看一个函数的完整定义</p><p>这是书中的定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(defun mark-whole-buffer ()</span><br><span class="line">  &quot;Put point at beginning and mark at end of buffer.&quot;</span><br><span class="line">  (interactive)</span><br><span class="line">  (push-mark (point))</span><br><span class="line">  (push-mark (point-max))</span><br><span class="line">  (goto-char (point-min)))</span><br></pre></td></tr></table></figure><p>书中讲不知道为啥函数体内的第一条表达式<code>push-mark</code>内还需要写<code>(point)</code>，但我现在再去看，这个函数已经改变了，并且也改掉了这个冗余的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(defun mark-whole-buffer ()</span><br><span class="line">  &quot;Put point at beginning and mark at end of buffer.</span><br><span class="line">If narrowing is in effect, only uses the accessible part of the buffer.</span><br><span class="line">You probably should not use this function in Lisp programs;</span><br><span class="line">it is usually a mistake for a Lisp function to use any subroutine</span><br><span class="line">that uses or sets the mark.&quot;</span><br><span class="line">  (declare (interactive-only t))</span><br><span class="line">  (interactive)</span><br><span class="line">  (push-mark)</span><br><span class="line">  (push-mark (point-max) nil t)</span><br><span class="line">  ;; This is really `point-min&apos; in most cases, but if we&apos;re in the</span><br><span class="line">  ;; minibuffer, this is at the end of the prompt.</span><br><span class="line">  (goto-char (minibuffer-prompt-end)))</span><br></pre></td></tr></table></figure><p>并且还改了一些代码，先不看<code>declare</code>，我们发现变化的有<code>(push-mark (point-max))</code>，最新的<code>mark-whole-buffer</code>函数中函数体第二个表达式多了两个参量，第二个参量代表如果值不为nil则显示<code>Mark set</code>。第三个参量代表如果在瞬时标记模式下，值不为nil则激活。</p><p>并且最后一条表达式也修改过了，原本是<code>point-min</code>但改为<code>minibuffer-prompt-end</code>，其区别在于:</p><p><code>minibuffer-prompt-end会在返回buffer位置时输出信息至minibuffer</code></p><p>在是如果当前buffer不是minibuffer那么就返回<code>point-min</code></p><h2 id="append-to-buffer函数定义"><a href="#append-to-buffer函数定义" class="headerlink" title="append-to-buffer函数定义"></a>append-to-buffer函数定义</h2><p>由于我看的这本书年代久远(2001)，现在是2019年，整整过去18年，Emacs也已经发生了巨大的变化。</p><p>所以我将先试着记录书中所讲的<code>append-to-buffer</code>函数再对Emacs 26.3版本的<code>append-to-buffer</code>函数进行讲解，希望对看到这篇博客的同仁们提供一些微薄的帮助。</p><blockquote><p>这个计划已经鸽了，我发现用我现在所学还是很难解释清楚26.3版本的append-to-buffer函数的工作方式。所以后面的26.版 append-to-buffer会在以后完成，十分抱歉。</p></blockquote><p>首先<code>append-to-buffer</code>函数的作用是将指定buffer区域(region)中的文本追加到当前Buffer的point前。</p><h3 id="旧版append-to-buffer"><a href="#旧版append-to-buffer" class="headerlink" title="旧版append-to-buffer"></a>旧版append-to-buffer</h3><p>先让我们看看书中的<code>append-to-buffer</code>函数定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(defun append-to-buffer (buffer start end)</span><br><span class="line">  &quot;Append to specified buffer the text of the region.</span><br><span class="line">It is inserted into that buffer before its point.</span><br><span class="line">When alling from a program, give three arguments:</span><br><span class="line">a buffer or the name of one, and two character numbers</span><br><span class="line">specifying the portion of the current buffer to be copied.&quot;</span><br><span class="line">  (interactive &quot;BAppend to buffer: \nr&quot;)</span><br><span class="line">  (let ((oldbuf (current-buffer)))</span><br><span class="line">    (save-excursion</span><br><span class="line">      (set-buffer (get-buffer-create buffer))</span><br><span class="line">      (insert-buffer-substring oldbuf start end))))</span><br></pre></td></tr></table></figure><p>通过阅读这个函数的文档就能很清晰的了解这个函数的工作方式。</p><p>略过函数名和文档，我们直接来看<code>interactive</code>。<code>interative</code>中的<code>B</code>代表让用户选择一个Buffer(可能不存在)并将buffer名称传给函数参量一，其次是一些友好的文本<code>Append to buffer:</code>，紧跟其后的<code>\n</code>用于控制换行，最后的<code>r</code>获取当前区域(point和mark)，并将其传给函数的参量二和参量三。 </p><p>随后是一个<code>let</code>特殊表，在<code>let</code>的变量列表中，定义了一个<code>oldbuf</code>，其绑定的值是<code>(current-buffer)</code>的返回值，也就是当前Buffer对象。在<code>let</code>的表达式体中有一个<code>save-excursion</code>函数。</p><p><code>save-excursion</code>函数体中有两条表达式，第一条表达式<code>(set-buffer)</code>用于将当前缓冲区变换到另外一个缓冲区，而其参量又是一个函数<code>get-buffer-create</code>，这个函数的作用是获取指定BUFFER对象或名(称为BUFFER-OR-NAME)，如果这个BUFFER-OR-NAME不存在，将会自动创建。</p><p><code>save-excursion</code>函数体的第二条表达式是一个<code>(insert-buffer-substring)</code>函数这个函数将参量一从参量二到参量三的区域的字符串插入到当前Buffer的point之前。</p><h3 id="26-3版append-to-buffer"><a href="#26-3版append-to-buffer" class="headerlink" title="26.3版append-to-buffer"></a>26.3版append-to-buffer</h3><p>由于本人水平有限，如有错误，欢迎提出issue.</p><p>先让我们看函数定义原型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(defun append-to-buffer (buffer start end)</span><br><span class="line">  &quot;Append to specified BUFFER the text of the region.</span><br><span class="line">The text is inserted into that buffer before its point.</span><br><span class="line">BUFFER can be a buffer or the name of a buffer; this</span><br><span class="line">function will create BUFFER if it doesn&apos;t already exist.</span><br><span class="line"></span><br><span class="line">When calling from a program, give three arguments:</span><br><span class="line">BUFFER (or buffer name), START and END.</span><br><span class="line">START and END specify the portion of the current buffer to be copied.&quot;</span><br><span class="line">  (interactive</span><br><span class="line">   (list (read-buffer &quot;Append to buffer: &quot; (other-buffer (current-buffer) t))</span><br><span class="line"> (region-beginning) (region-end)))</span><br><span class="line">  (let* ((oldbuf (current-buffer))</span><br><span class="line">         (append-to (get-buffer-create buffer))</span><br><span class="line">         (windows (get-buffer-window-list append-to t t))</span><br><span class="line">         point)</span><br><span class="line">    (save-excursion</span><br><span class="line">      (with-current-buffer append-to</span><br><span class="line">        (setq point (point))</span><br><span class="line">        (barf-if-buffer-read-only)</span><br><span class="line">        (insert-buffer-substring oldbuf start end)</span><br><span class="line">        (dolist (window windows)</span><br><span class="line">          (when (= (window-point window) point)</span><br><span class="line">            (set-window-point window (point))))))))</span><br></pre></td></tr></table></figure><p>我们发现函数参量没有变化，并且注释也没有大的变化，只是函数体内发生了较大的变化。</p><p>首先是<code>interactive</code>函数参量发生了变化，变成了一个<code>list</code>函数，回想一下，<code>list</code>函数是用于构造一个列表的函数，这个<code>list</code>函数的第一个参量是<code>(read-buffer)</code>函数。</p><p><code>read-buffer</code>函数可以通过buffer名称读取buffer中的字符串并返回。其第一个参量是用于提示用户的友好信息，并且特意指出这个提示信息必须是由冒号和空格结尾且被双引号包围的字符串。第二个参量用于也就是返回值，它的默认值为列表</p><h2 id="回顾-1"><a href="#回顾-1" class="headerlink" title="回顾"></a>回顾</h2><p>惯例抄书</p><ul><li><p>describe-function\describe-variable<br>打印一个函数或一个变量的文档。通常将其绑定到<code>C-h f</code>和<code>C-h v</code></p></li><li><p>find-tag<br>找到存放某个函数或变量的源代码的文件，并切换到这个缓冲区，将位点(光标)置于相应函数或这变量的开始处。习惯上将其绑定到<code>M--</code>。</p></li><li><p>save-excursion<br>保存位点和标记的位置，并在对<code>save-excursion</code>参量求值之后恢复这些值。它也保存当前缓冲区并返回到该缓冲区。</p></li><li><p>push-mark<br>在指定位置设置一个标记，并在标记环中记录原来标记的值。标记是缓冲区中的一个位置，即使由一些文本被从缓冲区删除或者增加到缓冲区，标记仍将保持它的相对位置。</p></li><li><p>goto-char<br>将位点设置为由参量指定的位置。参量值可以是一个数，也可以是一个标记，甚至可以是一个返回一个位置数字的表达式(point-min)</p></li><li><p>insert-buffer-substring<br>将来自一个缓冲区（这是被作为一个参量而传递给函数的）的文本域拷贝到当前缓冲区</p></li><li><p>mark-whole-buffer<br>将整个缓冲区标记为一个域。一般将这个函数绑定到<code>C-x h</code>。</p></li><li><p>set-buffer<br>将Emacs的注意力转移到另一个缓冲区，但是不该便显示的窗口。 </p></li><li><p>get-buffer-create\get-buffer<br>寻找一个已指定名字的缓冲区，或当指定名字的缓冲区不存在时就创建它。如果指定名称的缓冲区不存在，get-buffer函数就返回nil。</p></li></ul><h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><ul><li>编写自己的<code>simplified-end-of-buffer</code>函数定义，然后测试它是否能工作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defun simple-end-of-buffer()</span><br><span class="line">  &quot;移动光标至buffer结束处&quot;</span><br><span class="line">  (interactive)</span><br><span class="line">  (push-mark)</span><br><span class="line">  (goto-char (point-max)))</span><br></pre></td></tr></table></figure><ul><li>用if和get-buffer编写一个函数，这个函数要打印一个说明某个缓冲区是否存在的消息 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(defun is-exist-buffer (buffer-or-name)</span><br><span class="line">  &quot;判断buffer-or-name是否为一个已存在的buffer&quot;</span><br><span class="line">  (if (bufferp (get-buffer buffer-or-name))</span><br><span class="line">      (message &quot;%s存在!&quot; buffer-or-name)</span><br><span class="line">    (message &quot;此缓冲区不存在!&quot;)))</span><br><span class="line">    </span><br><span class="line">(is-exist-buffer &quot;test.el&quot;) ;; =&gt; &quot;test.el存在!&quot;</span><br></pre></td></tr></table></figure><ul><li>用find-tag找到copy-to-buffer函数的源代码</li></ul><p>不会…</p><h1 id="第五章-更复杂的函数"><a href="#第五章-更复杂的函数" class="headerlink" title="第五章 更复杂的函数"></a>第五章 更复杂的函数</h1><p>本章我们将在已学内容的基础之上学习更复杂的函数，例如有使用两次<code>save-excursion</code>的<br><code>copy-to-buffer</code>函数，以及一个在<code>interactive</code>中使用<code>*</code>和<code>or</code>函数的函数。</p><h2 id="copy-to-buffer函数的定义"><a href="#copy-to-buffer函数的定义" class="headerlink" title="copy-to-buffer函数的定义"></a>copy-to-buffer函数的定义</h2><p><code>copy-to-buffer</code>函数与前面学过的<code>append-to-buffer</code>的定义很类似。</p><p><code>copy-to-buffer</code>是替换指定<code>BUFFER</code>的内容，而<code>append-to-buffer</code>是在指定<code>BUFFER</code>中追加内容。</p><p>首先来看看<code>copy-to-buffer</code>的函数定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(defun copy-to-buffer-t (BUFFER START END)</span><br><span class="line">  &quot;docutments...&quot;</span><br><span class="line">  (interactive &quot;BCopy to buffer: \nr&quot;)</span><br><span class="line">  (let ((oldbuf (get-buffer-create BUFFER)))</span><br><span class="line">    (save-excursion</span><br><span class="line">      (set-buffer BUFFER)</span><br><span class="line">      (save-excursion</span><br><span class="line">        (insert-buffer-substring oldbuf START END)))))</span><br></pre></td></tr></table></figure><p>略过函数名与文档不看，可以看到这个函数被定义为交互式函数，并且这个函数的参量要求<br>是一个BUFFER对象，以及两个表示位置的数字。这三个参量都由<code>interactive</code>所解决，其<br>使得让用户选择一个BUFFER，然后获取当前<code>Buffer</code>的<code>point</code>和<code>mark</code>，作为<code>START</code>和<br><code>END</code>。</p><p>随后是一个<code>let</code>表达式，其在它的<code>varlist</code>部分将<code>BUFFER</code>参量通过<br><code>get-buffer-create</code>函数获取了其对象(就算<code>BUFFER</code>参量的值不存在也会创建一个)，并<br>且将这个BUFFER对象赋值给<code>oldbuf</code>。在<code>let</code>表达式的<code>BODY</code>部分，出现了一个<br><code>save-excursion</code>函数，这个函数用于记录当前<code>point</code>和<code>mark</code>的位置，然后在其参量求<br>值完毕后恢复记录的位置，这个参量也就是<code>set-buffer</code>，这个函数用于改变当前BUFFER为<br>  参量<code>BUFFER</code>。随后又是一个<code>save-excursion</code>函数，其参量<br>  <code>insert-buffer-substring</code>函数我们也了解过，其用于将当前BUFFER的START到END之间<br>  的区间插入到<code>oldbuf</code>内。</p><h2 id="insert-buffer函数的定义"><a href="#insert-buffer函数的定义" class="headerlink" title="insert-buffer函数的定义"></a>insert-buffer函数的定义</h2><p>前面我们用过<code>append-to-buffer</code>以及<code>copy-to-buffer</code>，他们都是将当前<code>BUFFER</code>的内容<br>拷贝或追加到某一个<code>BUFFER</code>中，而<code>insert-buffer</code>可以将当前<code>BUFFER</code>的内容，拷贝至<br>一个已存在的<code>BUFFER</code>当中。</p><p>先来看看其函数定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(defun insert-buffer-t (buffer)</span><br><span class="line">  &quot;docutmens..&quot;</span><br><span class="line">  (interactive &quot;*bInsert buffer: &quot;)</span><br><span class="line">  (or (bufferp buffer)</span><br><span class="line">      (setq buffer (get-buffer buffer)))</span><br><span class="line">  (let (start end newmark)</span><br><span class="line">    (save-excursion</span><br><span class="line">      (save-excursion</span><br><span class="line">        (set-buffer buffer)</span><br><span class="line">        (setq start (point-min) end (point-max)))</span><br><span class="line">      (insert-buffer-substring buffer start end)</span><br><span class="line">      (setq newmark (point)))</span><br><span class="line">    (push-mark newmark)))</span><br></pre></td></tr></table></figure><p>先简单整理一下这个函数都包含了什么东西:</p><ul><li>一个参量</li><li>函数文档</li><li>定义交互式函数</li><li><code>interactive</code>参量说明有*和 <code>b</code></li><li>以及一个<code>or</code>函数，这个函数内有两个参量</li><li>第一个参量是<code>bufferp</code>函数</li><li>第二个参量是<code>setq</code>函数，<code>setq</code>的第二个参量是<code>get-buffer</code>函数。</li><li>随后是一个<code>let</code>表达式</li><li><code>let</code>表达式中先是初始化了三个空变量</li><li>一个外层<code>save-excursion</code>函数</li><li>一个内层<code>save-excursion</code>函数</li><li>其第一个参量是一个<code>set-buffer</code>函数</li><li>第二个参量是<code>setq</code>函数</li><li>外层<code>save-excursion</code>的第二个参量是一个<code>insert-buffer-substring</code>函数</li><li>第三个参量是一个<code>setq</code>函数。</li><li>最后是一个<code>push-mark</code>函数。 </li></ul><h3 id="insert-buffer函数中的交互表达式"><a href="#insert-buffer函数中的交互表达式" class="headerlink" title="insert-buffer函数中的交互表达式"></a>insert-buffer函数中的交互表达式</h3><p>让我们先从<code>interactive</code>表达式说起，首先起表达式说明分为三个部分：</p><ol><li><code>*</code>代表只读缓冲区，这个说明会在当<code>b</code>说明返回的buffer是一个只读缓冲区时在回显<br>区提示错误。也就是说当这个<code>insert-buffer</code>函数当在一个只读缓冲区被调用时，将不<br>被允许。</li><li><p><code>b</code>代表要求是一个存在的缓冲区或者是缓冲区名，它与<code>B</code>说明不同。</p></li><li><p><code>Insert buffer:</code>是友好的提示。</p></li></ol><p><strong>提示:*控制符无需后接一个换行符来分割不同的参量。</strong></p><h3 id="insert-buffer函数体"><a href="#insert-buffer函数体" class="headerlink" title="insert-buffer函数体"></a>insert-buffer函数体</h3><p>主要有两个部分，分别是<code>or</code>函数和<code>let</code>函数。</p><p>先让我们来看看<code>or</code>函数，其第一个参量是一个<code>bufferp</code>函数，这个函数用于当其参量是<br>是一个已存在的buffer或buffer的名称才会返回<code>non-nil</code>的值，也就是真/非假，其第二个<br>参量是一个<code>setq</code>函数，里面有一个<code>get-buffer</code>函数，这个函数是用于获取一个已存在的<br>buffer对象根据buffer对象或buffer的名称，并将buffer绑定到<code>get-buffer</code>的值之上。</p><p>其实这个函数的意思是，要让<code>buffer</code>参量确定是一个已存在的buffer，我们可以用<code>if</code>函<br>数重写一遍。</p><h3 id="用if表达式编写insert-buffer函数"><a href="#用if表达式编写insert-buffer函数" class="headerlink" title="用if表达式编写insert-buffer函数"></a>用if表达式编写insert-buffer函数</h3><p>我们的需求是，必须确保<code>buffer</code>的值是一个已存在的buffer或buffer的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(if (not (bufferp buffer)</span><br><span class="line">         (setq buffer (get-buffer buffer))))</span><br></pre></td></tr></table></figure><p>就可以这样写，当<code>bufferp</code>函数的值为nil时，那么就会尝试获取<code>buffer</code>的对象并且保存，<br>否则则报错。</p><h3 id="insert-buffer函数中的let表达式"><a href="#insert-buffer函数中的let表达式" class="headerlink" title="insert-buffer函数中的let表达式"></a>insert-buffer函数中的let表达式</h3><p>在我们确保<code>buffer</code>参量是一个非只读缓冲区后，可以开始写拷贝内容的代码了。</p><p>首先我们初始化三个空变量: start end newmark</p><p>  <code>let</code>表达式体中有一个外层<code>save-excursion</code>函数，其记录了我们的<code>point</code>和<code>mark</code>，<br>其第一个参量又是一个<code>save-excursion</code>函数，我们称为内层<code>save-excursion</code>。内层<br><code>save-excursion</code>主要做了两件事，首先是将Emacs的注意力转移到<code>buffer</code>之上，随后为<br><code>start</code>以及<code>end</code>附上<code>buffer</code>的<code>point-min</code>和<code>point-max</code>的值，并且由于内层<br><code>save-excursion</code>已经求值完毕，那么会恢复在求值过程中可能变动的位点和标记的值。随<br>后外层<code>save-excursion</code>函数的第二个参量是将<code>buffer</code>参量的内容插入到当前buffer从<br><code>start</code>到<code>end</code>结束的内容，这个<code>start</code>和<code>end</code>也就是<code>buffer</code>参量所有的内容。随后又<br>把<code>newmark</code>变量绑定到值<code>point</code>之上，最后将<code>newmark</code>记录为<code>标记</code>。</p><h2 id="beginning-of-buffer函数的完整定义"><a href="#beginning-of-buffer函数的完整定义" class="headerlink" title="beginning-of-buffer函数的完整定义"></a>beginning-of-buffer函数的完整定义</h2><p>前面我们尝试写了<code>beginning-of-buffer</code>函数的部分定义，它是一个无参量的函数，那么<br>这次我们来写一个有参量的<code>beginning-of-buffer</code>函数。</p><p>这个带参量的<code>beginning-of-buffer</code>函数可以指定在当前缓冲区的几分之几标记位置。</p><p>那么现来说下需求:<code>beginning-of-buffer</code>函数接受一个可选参量，这个参量的返回是1-10<br>之间，这个参量作为标记点的位置。</p><h3 id="可选参量"><a href="#可选参量" class="headerlink" title="可选参量"></a>可选参量</h3><p>在需求里我们提到: </p><blockquote><p><code>beginning-of-buffer</code>函数接受一个可选参量</p></blockquote><p>除非特别声明，否则Lisp会认为函数的参量是必须在函数被调用时传递一个值给该参量的。<br>如果不传入参量，则该函数就会出错:<code>Wrong number of arguments</code>。</p><p>而如果需要使一个或多个参量变为可选参数只需要在参量前加上<code>&amp;optional</code>关键字，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(defun beginning-of-defun-function-t (&amp;optional arg1 arg2)</span><br><span class="line">  &quot;documentation&quot;</span><br><span class="line">  (interactive &quot;P&quot;)</span><br><span class="line">  (push-mark)</span><br><span class="line">  (goto-char</span><br><span class="line">   ;; if-there-is-an-argument</span><br><span class="line">   ;;   xxxx</span><br><span class="line">   ;; else-go-to</span><br><span class="line">   (point-min)))</span><br></pre></td></tr></table></figure><p>对比前面的<code>simple-beginning-to-buffer</code>函数，好像唯一多的地方是在<code>goto-char</code>函数<br>的第一个参量，变成了<code>if</code>特殊表。这个<code>if</code>函数判断由<code>interactive</code>的<code>P</code>参量获得到的前<br>缀参量是否为一个非nil值，如果是则执行<code>if then</code>部分，否则执行跟<br><code>simple-beginning-to-buffer</code>一样的操作。</p><h3 id="带参量的beginning-of-buffer函数"><a href="#带参量的beginning-of-buffer函数" class="headerlink" title="带参量的beginning-of-buffer函数"></a>带参量的beginning-of-buffer函数</h3><p><code>goto-char</code>函数中有一个<code>if</code>表达式，这个表达式做了很多关于算术的操作。 </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(defun beginning-of-defun-function-t (&amp;optional arg)</span><br><span class="line">  &quot;documentation&quot;</span><br><span class="line">  (interactive &quot;P&quot;)</span><br><span class="line">  (push-mark)</span><br><span class="line">  (goto-char</span><br><span class="line">   (if (&gt; (buffer-size) 10000)</span><br><span class="line">       (/ (prefix-numeric-value arg) 10)</span><br><span class="line">     (/</span><br><span class="line">      (+ 10</span><br><span class="line">         (*</span><br><span class="line">          (buffer-size) (prefix-numeric-value arg))) 10))</span><br><span class="line">   (point-min)))</span><br></pre></td></tr></table></figure><p> 一眼看上去有些复杂，其实我们通过函数模板来揭开其中的奥秘，十分简单。</p><p>我们看将<code>if</code>函数的结构看成这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(if (buffer-is-large</span><br><span class="line">     divide-buffer-size-by-10-and-multiply-by-arg)</span><br><span class="line">    else-use-alternate-calculation)</span><br></pre></td></tr></table></figure><p>要吃饭了</p><p>这里的<code>if</code>函数用于检查缓冲区的大小，这是因为书中使用的是第18版本的Elisp，其使用<br>了不大于800w的数字来描述缓冲区的大小，如果有在某次求值中遇到更大的缓冲区，Emacs<br>就会试图用更大的数来描述它(通常叫做overflow溢出)。</p><p>那么现在就有两种情况了，分别是超大缓冲区和正常的缓冲区，这两种不同数量级的缓冲区<br>有不同的处理方式，先来看看那超大缓冲区的处理方式</p><p>当<code>(if (&gt; (buffer-size) 10000))</code>时，执行<code>if</code>表达式的<code>then</code>部分，这部分内有一个<br><code>prefix-numeric-value</code>用于将从<code>(interactive &quot;P&quot;)</code>读入的参数转为一个数字，也就是<br>把<code>arg</code>的值转为数字，并且将其除以10，這樣可以讓產生的數比緩衝區中相應的比例多只<br>多一個字符。 </p><h3 id="完整的beginning-of-buffer函數"><a href="#完整的beginning-of-buffer函數" class="headerlink" title="完整的beginning-of-buffer函數"></a>完整的beginning-of-buffer函數</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(defun beginning-of-buffer-t (&amp;optional arg)</span><br><span class="line">  &quot;Move point to the beginning of the buffer;</span><br><span class="line">leave mark at previous position.</span><br><span class="line">Wwith arg N, put point N/10 of the way from the true beginning.</span><br><span class="line">Don&apos;t use this in Lisp programs!</span><br><span class="line">\(goto-char (point-min)) is faster</span><br><span class="line">and does not set the mark.&quot;</span><br><span class="line">  (interactive &quot;P&quot;)</span><br><span class="line">  (push-mark)</span><br><span class="line">  (goto-char</span><br><span class="line">   (if arg</span><br><span class="line">       (if (&gt; (buffer-size) 10000)</span><br><span class="line">           ;; Avoid overflow for large buffer sizes!</span><br><span class="line">           (* (prefix-numeric-value arg)</span><br><span class="line">              (/ (buffer-size) 10))</span><br><span class="line">         (/ (+ 10 (* (buffer-size)</span><br><span class="line">                     (prefix-numeric-value arg)))</span><br><span class="line">            10))</span><br><span class="line">     (point-min))) (if arg (forward-line 1)))</span><br></pre></td></tr></table></figure><h2 id="回顧"><a href="#回顧" class="headerlink" title="回顧"></a>回顧</h2><p>慣例抄書</p><ul><li>or</li></ul><p>逐一對每一個參量求值，並返回第一個非空值（不是nil)。如果所有參量的值都是nil，則<br>返回nil。</p><ul><li>and</li></ul><p>逐一對每一個參量求值，如果有任意一個參量的值爲nil，則返回nil，並且隨後的參量不會<br>進行求值。</p><ul><li>&amp;optional</li></ul><p>指定函數定義時參量爲可選項，如果有任意參量前有&amp;optional則表明當前且隨後的參量都<br>是可選參量。</p><ul><li>prefix-numberic-value</li></ul><p>將由 <code>(interactive &quot;P&quot;)</code>產生的尚未加工的前綴參量轉換成一個數值。</p><ul><li>erase-buffer</li></ul><p>刪除當前緩衝區的所有內容 </p><ul><li>bufferp</li></ul><p>如果參量是一個buffer對象則返回真，否則返回 nil。</p><h2 id="amp-optional-參量練習"><a href="#amp-optional-參量練習" class="headerlink" title="&amp;optional 參量練習"></a>&amp;optional 參量練習</h2><p>題目</p><blockquote><p>編寫一個帶可選參量的交互參量，這個函數要測試函數被調用時是否有參量（其值是一個<br>數），這個數是否大於或小於fill-column的值，並將結果以一個消息的形式給出。然而，<br>如果不帶參量調用這個函數時，則使用56作爲默認值。</p></blockquote><p>解答</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(defun bigger-fill-column (&amp;optional arg)</span><br><span class="line">  &quot;判斷是否大於fill-column</span><br><span class="line">ARG爲可選參量，默認值爲56&quot;</span><br><span class="line">  (interactive &quot;P&quot;)</span><br><span class="line">  (if arg</span><br><span class="line">      (if (&gt; arg fill-column)</span><br><span class="line">          (message &quot;%d大於fill-column的值&quot; arg)</span><br><span class="line">        (message &quot;%d小於fill-column的值&quot; arg))</span><br><span class="line">    (if (&lt; 56 fill-column)</span><br><span class="line">        (message &quot;fill-column的值大於於56&quot;))))</span><br></pre></td></tr></table></figure><h1 id="第六章-變窄和增寬"><a href="#第六章-變窄和增寬" class="headerlink" title="第六章 變窄和增寬"></a>第六章 變窄和增寬</h1><p>變窄(narrowing)是Emacs的一個特性，它的作用是使得當前buffer在開啓變窄後將變窄範圍<br>之外的內容屏蔽。</p><p>上面提到的屏蔽不僅有視覺效果而且還對EmacsLisp解釋器有效。</p><h2 id="save-restriction特殊表"><a href="#save-restriction特殊表" class="headerlink" title="save-restriction特殊表"></a>save-restriction特殊表</h2><p>前面我們學習過<code>save-excursion</code>函數，其作用是記錄當前位點和標記的位置，而對於變窄，<br>Emacs提供了一個<code>save-restriction</code>函數，其作用是記錄當前變窄的標記位置，當其表達<br>式內參量求值完成後再恢復記錄過的變窄的標記位置，這麼做可以讓當遇到取消變窄的表達<br>式後可以恢復。</p><p>其函數模板見:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(save-restriction body...)</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>如果同時連續使用<code>save-excursion</code>函數和<code>save-restriction</code>函數時必須將<br><code>save-excursion</code>函數放在<code>save-restriction</code>之前，類似於:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(save-excursion</span><br><span class="line">  (save-restriction))</span><br></pre></td></tr></table></figure><p>如果位置反過來則會出現<code>save-excursion</code>無法記錄變窄範圍之外的標記。</p><h2 id="what-line函數"><a href="#what-line函數" class="headerlink" title="what-line函數"></a>what-line函數</h2><p>這個函數是一個典型的同時使用<code>save-restriction</code>和<code>save-excursion</code>的例子，其作用是<br>返回當前光標所在當前buffer的行數。</p><p>先看看它的實現:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(defun what-line ()</span><br><span class="line">  &quot;Print the current line number (in the buffer) of point.&quot;</span><br><span class="line">  (interactive)</span><br><span class="line">  (save-restriction</span><br><span class="line">  (widen)</span><br><span class="line">  (save-excursion</span><br><span class="line">    (beginning-of-line)</span><br><span class="line">    (message &quot;Line %d&quot;</span><br><span class="line">    (1+ (count-lines 1 (point)))))))</span><br></pre></td></tr></table></figure><p>首先看到<code>widen</code>函數，這個函數可以取消變窄開啓，但是它被<code>save-restriction</code>包住，<br>這意味着就算取消了變窄開啓，<code>save-restriction</code>也可以保證變窄範圍不會變化.</p><p>再看到<code>beginning-of-line</code>，這個函數會移動point到當前行的首個字符.明顯這個函數改<br>變了<code>point</code>值，不過由於<code>save-excursion</code>的出現，這些改變位點和標記的操作都將會被<br>恢復。</p><p>前面所做的類似<code>widen</code>和<code>beginning-of-line</code>都可以說是爲了後面真正求出行數的計算做<br>的準備。</p><p>現在再讓我們看向<code>(message)</code>函數，裏面只是簡單的做了一個友好提示以及格式化，隨後<br>讓我們注意<code>(1+ (count-lines 1 (point)))</code>，<code>count-lines</code>的作用是計算其第一個參量<br>到第二個參量之間的總行數，至於<code>1+</code>是爲了處理一些疑難雜症。</p><h2 id="練習：變窄"><a href="#練習：變窄" class="headerlink" title="練習：變窄"></a>練習：變窄</h2><p>題目</p><blockquote><p>編寫一個函數，這個函數在即使設置了變窄開啓而使緩衝區的前一半不可見的情況下也能<br>顯示出當前緩衝區的頭60個字符。要在顯示完成之後恢復位點、標記和變窄開啓等相關設<br>置。對於這個練習題，要使用<code>save-restriction</code>、<code>widen</code>、<code>goto-char</code>、<br><code>point-min</code>、<code>buffer-substring</code>、<code>message</code> 和其他函數，真可以算得上是一個大雜<br>燴。</p></blockquote><p>解題</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(defun print-60-char ()</span><br><span class="line">  &quot;輸出當前buffer前60個字符</span><br><span class="line">變窄範圍之外也算&quot;</span><br><span class="line">  (interactive)</span><br><span class="line">  (save-restriction</span><br><span class="line">    (widen)</span><br><span class="line">    (save-excursion</span><br><span class="line">      (message &quot;%s&quot;</span><br><span class="line">               (buffer-substring</span><br><span class="line">                (point-min)</span><br><span class="line">                60)))))</span><br></pre></td></tr></table></figure><h1 id="第七章-基本函數-car、cdr、cons"><a href="#第七章-基本函數-car、cdr、cons" class="headerlink" title="第七章 基本函數: car、cdr、cons"></a>第七章 基本函數: car、cdr、cons</h1><p>本章學習car、cdr、cons等函數，這三個函數都是Lisp中非常基礎的函數。 </p><p><code>car</code></p><blockquote><p>Contents of the address part of the Register.</p></blockquote><p><code>cdr</code></p><blockquote><p>Contents of the Decrement part of the Register.</p></blockquote><p><code>cons</code></p><blockquote><p>construct</p></blockquote><h2 id="car和cdr函數"><a href="#car和cdr函數" class="headerlink" title="car和cdr函數"></a>car和cdr函數</h2><p>我們見過類似這樣的列表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;(cat dog tiger lion)</span><br></pre></td></tr></table></figure><p>而這個列表的car也就是<code>cat</code>，car函數用於獲取列表的第一部分(也就是第一個符號)。</p><p>這個列表的cdr是<code>(dog tiger lion)</code>，cdr函數用於獲取列表的第二部分(除了首符號之外<br>的符號)。</p><p><strong>注意:</strong></p><ul><li><p>這裏由cdr獲取的部分是一個列表，而<code>car</code>獲取的部分只是一個符號罷了。</p></li><li><p><code>car</code>和<code>cdr</code>函數都是非破壞性的，也就是說他們不會對操作對象有任何修改操作，只是<br>讀取。</p></li></ul><h2 id="cons函數"><a href="#cons函數" class="headerlink" title="cons函數"></a>cons函數</h2><p><code>cons</code>函數用於構造新列表，例如想要爲<code>(cat dog tiger lion)</code>中添加一個<code>panda</code>可以<br>這麼寫:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(cons &apos;panda &apos;(cat dog tiger lion)) ;; =&gt; (panda cat dog tiger lion)</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p><code>cons</code>函數不能憑空構造一個新列表，<strong>其必須有一個待插入新元素的列表</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(cons &apos;panda ()) </span><br><span class="line">(cons &apos;water &apos;(milk nongfu_spring)) ;; =&gt; (water milk nongfu_spring)</span><br></pre></td></tr></table></figure><h3 id="查詢列表的長度-length函數"><a href="#查詢列表的長度-length函數" class="headerlink" title="查詢列表的長度: length函數"></a>查詢列表的長度: length函數</h3><p><code>length</code>函數可以獲取列表的長度，也就是元素的個數。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(length &apos;(a b c d)) ;; =&gt; 4</span><br></pre></td></tr></table></figure><p>也可以查詢空列表的長度:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(length ()) ;; =&gt; 0</span><br></pre></td></tr></table></figure><p>但是此函數必須有一個列表對象的參量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(length ) ;; =&gt; eval: Wrong number of arguments: length, 0</span><br></pre></td></tr></table></figure><h2 id="nthcdr函數"><a href="#nthcdr函數" class="headerlink" title="nthcdr函數"></a>nthcdr函數</h2><p><code>nthcdr</code>函數於<code>cdr</code>函數是有聯繫的，試想下如果你想要通過<code>cdr</code>函數獲取列表<code>(catdog lion)</code>的最後一個元素，你可以這麼做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(cdr (cdr &apos;(cat dog lion))) ;; =&gt; (lion)</span><br></pre></td></tr></table></figure><p>但假如這個列表的長度有10000，你想獲取最後一個元素還是用這種方式將會十分麻煩，這<br>時候就可以使用<code>nthcdr</code>函數了，它可以重複<code>cdr</code>函數的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;; 返回移出前五個元素的列表</span><br><span class="line">(nthcdr 5 &apos;(car dog lion tiger panda fish)) ;; =&gt; fish</span><br><span class="line">;; 返回移出前三個元素的列表</span><br><span class="line">(nthcdr 3 &apos;(car dog lion tiger panda fish)) ;; =&gt; (tiger panda fish)</span><br><span class="line">;; 留下全部列表</span><br><span class="line">(nthcdr 0 &apos;(car dog lion tiger panda fish)) ;; =&gt; (car dog lion tiger panda fish)</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>當<code>nthcdr</code>第一個參量大於等於列表長度時將永遠得到<code>nil</code>值。</p><p><code>nthcdr</code>函數也是不據破壞性的。</p><h2 id="setcar函數"><a href="#setcar函數" class="headerlink" title="setcar函數"></a>setcar函數</h2><p><code>setcar</code>函數有些類似<code>cons</code>函數，只不過其會改變列表的值，也就是說具有破壞性的。</p><p><code>setcar</code>將某個值替換某個列表的第一部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(setq animal &apos;(cat dog lion riger panda fish)) ;; =&gt; cat dog lion riger panda fish</span><br><span class="line"></span><br><span class="line">(setcar animal &apos;cow) ;; =&gt; cow</span><br><span class="line"></span><br><span class="line">animal ;; =&gt; (cow dog lion riger panda fish)</span><br></pre></td></tr></table></figure><p>於<code>setcar</code>類似的還有一個<code>setcdr</code>函數，其作用是將列表的第二個參量設置爲第一個參量<br>的第二部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(setq animal &apos;(cat dog lion riger panda fish)) ;; =&gt; cat dog lion riger panda fish</span><br><span class="line"></span><br><span class="line">(setcdr animal &apos;(a b c d)) ;; =&gt; (a b c d)</span><br><span class="line"></span><br><span class="line">animal ;; =&gt; (cat a b c d)</span><br></pre></td></tr></table></figure><h2 id="練習"><a href="#練習" class="headerlink" title="練習"></a>練習</h2><p>題目</p><blockquote><p>通過對幾個cons表達式求值，來構建一個四元素的，有關鳥的列表。試一試，當你對列表<br>本身使用cons函數時會發生什麼？用一種魚取代這個列表的第一個元素。用其他魚的列表<br>取代這個列表的其餘部分。</p></blockquote><p>解題</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">;; 鳥列表</span><br><span class="line">(setq fishes</span><br><span class="line">      (cons &apos;sparrow</span><br><span class="line">            (cons &apos;owl</span><br><span class="line">                  (cons &apos;kingfisher</span><br><span class="line">                        (cons &apos;ostrich ())))))</span><br><span class="line"></span><br><span class="line">;; 魚取代鳥列表第一部分</span><br><span class="line">(setcar fishes &apos;多寶魚)</span><br><span class="line">;; 魚列表取代鳥列表第二部分 </span><br><span class="line">(setcdr fishes (cons &apos;(甲魚 中華鱘) ()))</span><br><span class="line"></span><br><span class="line">fishes</span><br></pre></td></tr></table></figure><h1 id="第八章-剪切和存儲文本"><a href="#第八章-剪切和存儲文本" class="headerlink" title="第八章 剪切和存儲文本"></a>第八章 剪切和存儲文本</h1><blockquote><p>本人又可以用回简体中文啦！ 而且词库还增加了！可以打字更快了呢！</p></blockquote><p>首先需要先引入一个概念————在Emacs中有一个kill环，这个环记录了kill的数据，在这里<br>的kill不代表“杀死”，而是clip的意思。</p><h2 id="zap-to-char函数"><a href="#zap-to-char函数" class="headerlink" title="zap-to-char函数"></a>zap-to-char函数</h2><p>书中讲了zap-to-char函数的两个版本，分别是第19版和第18版。 </p><p>先让我们来看啊可能<code>zap-to-char</code>函数的第<code>19版本</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(defun zap-to-char (arg char) ;; version 19 implementation</span><br><span class="line">  &quot;Kill up to and including ARG&apos;th occurrence of CHAR.</span><br><span class="line">Goes backward if ARG is negative; error if CHAR not found.&quot;</span><br><span class="line">  (interactive &quot;*p\ncZap to char: &quot;)</span><br><span class="line">  (kill-region (point)</span><br><span class="line">               (progn</span><br><span class="line">                 (search-forward</span><br><span class="line">                 (char-to-string char) nil nil arg))</span><br><span class="line">               (point)))</span><br></pre></td></tr></table></figure><p>简单的描述下这个函数做了什么:</p><p>这个函数的功能是将当前位点到指定字符之间的字符串剪切到kill环内，其ARG的作用是指<br>定指定字符的次数(可能会有多个指定字符，所以可以选择是哪一个)。</p><p>例如有这么一段文字:<code>Thus,if the cursor were are begining of this sentence...</code></p><p>我们的光标处于<code>if the</code>的<code>t</code>之上，当我们通过传递前缀参量<code>2</code>给<code>zap-to-char</code>函数，<br>并且指定<code>zap-to-char</code>函数的<code>CHAR</code>参量为<code>s</code>就会发现<code>the cursor were are beginningof this</code>被截取了，并且通过<code>C-y(Yark)</code>可以将剪切掉的文本找回。</p><h3 id="interactive-表达式"><a href="#interactive-表达式" class="headerlink" title="interactive 表达式"></a>interactive 表达式</h3><p>让我们看看<code>interactive</code>表达式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(interactive &quot;*p\ncZap to char: &quot;)</span><br></pre></td></tr></table></figure><p>双引号部分的作用:</p><p>-r <code>*</code>代表只读缓冲区，也就是说当我们尝试对一个只读缓冲区使用<code>zap-to-char</code>函数将会<br>  获得一个报错信息。</p><ul><li><code>p</code>代表这个函数可以传递一个数值类型的前缀参量。</li><li><code>\n</code> 换行</li><li><code>c</code>代表这个函数会提示输入一个字符类型的值。</li><li><code>Zap to char:</code>一个友好的提示，冒号后面的空格只是让格式更好看罢了。</li></ul><p><strong>通过分析我们大概能知道，这个<code>interactive</code>表达式可以做到 监测是否为只读缓冲区，并<br>且支持通过前缀参量传递数值类型的值，在使用这个函数时还会提示输入一个字符。</strong></p><h3 id="zap-to-char函数体"><a href="#zap-to-char函数体" class="headerlink" title="zap-to-char函数体"></a>zap-to-char函数体</h3><p>函数体内通过几行简短的代码完成将当前位点到指定字符之间的文本添加到kill环内并删除<br>的操作。</p><p>跳过<code>interactive</code>表达式，可以看到所有的代码都被一个<code>kill-region</code>函数给包裹起来了，<br>其第一个参量是<code>(point)</code>，也就是当前的位点位置，第二个参量是<code>progn</code>函数，要讲解这<br>个函数的作用先让我们看看<code>search-forward</code>函数。</p><h3 id="search-forward函数"><a href="#search-forward函数" class="headerlink" title="search-forward函数"></a>search-forward函数</h3><p>或许你曾经使用过<code>search-forward</code>函数，它接收四个参量:</p><ul><li>第一个参量是要查找的字符</li><li>第二个参量(可选)是指定查找范围，可以绑定当前Buffer的一个位置.</li><li>第三个参量(可选)是当查找不到时，可以指定一个返回值，如果为t，则再出错时只返回<br>一个nil，如果既不为nil也不为t，则使搜索改变，并且返回一个nil，如果为nil则返回<br>出错信息。</li><li>第四个参量(可选)是重复计数值————待查找字符出现的次数，如果值为负数则从后查找。默认值为1。</li></ul><p><strong>注意:</strong></p><p>找到某个字符后位点也会随之改变。</p><h3 id="progn函数"><a href="#progn函数" class="headerlink" title="progn函数"></a>progn函数</h3><p><code>progn</code>函数很简单，它的作用就是将任意多个参量进行一一求值，并且返回最后一个参量<br>的值。</p><p>在这个函数内将<code>kill-region</code>所需的第二个参量获取出来了。</p><p>首先使用<code>search-forward</code>函数将位点改变到要查找的字符上，然后再对<code>(point)</code>求值，<br>利用自身特性返回最后一个参量的值，从而让<code>kill-region</code>函数正常工作。</p><h3 id="总结zap-to-char函数"><a href="#总结zap-to-char函数" class="headerlink" title="总结zap-to-char函数"></a>总结zap-to-char函数</h3><p>了解了<code>search-forward</code>以及<code>progn</code>函数后我们大致能了解<code>zap-to-char</code>函数的工作方式<br>了。</p><p>其中<code>kill-region</code>作用是将某个区域的字符添加到kill环，并且删除，其接收两个参量，<br>第一个参量作为区域的开始，第二个参量作为区域的结束，区域开始很容易获取，通过对<br><code>(point)</code>求值可以得到，而区域的结束也就是我们要查找的字符的位置，首先通过<br><code>progn</code>函数将多条函数放在一个函数内，其中里面的<code>search-forward</code>将位点改变为待查<br>找的字符上，由于<code>search-forward</code>函数的第一个参量必须要是一个字符串类型的值，所以<br>我们将通过<code>interactive</code>函数获取的字符由<code>char-to-string</code>转化为字符类型，其次由于<br>位点改变后我们再对<code>(point)</code>求值，可以获取区域结束的位置了。</p><h3 id="第18版本的zap-to-char函数"><a href="#第18版本的zap-to-char函数" class="headerlink" title="第18版本的zap-to-char函数"></a>第18版本的zap-to-char函数</h3><blockquote><p>个人感觉18版本的zap-to-char很复杂，但是也很精妙的体现出Emacs开发者的智慧。</p></blockquote><p><strong>第18版本的zap-to-char函数跟第19版本的区别在于，第18版本的剪切区域是去除待查找字<br>符本身的。</strong></p><p>先让我们看看代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(defun zap-to-char-18 (arg char)</span><br><span class="line">  (interactive &quot;*p\ncZap to char: &quot;)</span><br><span class="line">  (kill-region (point)</span><br><span class="line">               (if (search-forward</span><br><span class="line">                    (char-to-string char) ;; target</span><br><span class="line">                    nil ;; bind buffer position</span><br><span class="line">                    t ;; return </span><br><span class="line">                    arg) ;; repetition count</span><br><span class="line">                   (progn</span><br><span class="line">                     (goto-char</span><br><span class="line">                      (if (&gt; arg 0)</span><br><span class="line">                          (1- (point))</span><br><span class="line">                        (1+ (point))))</span><br><span class="line">                     (point))</span><br><span class="line">                 (if (&gt; arg 0) ;; else-part</span><br><span class="line">                     (point-max)</span><br><span class="line">                   (point-min)))))</span><br></pre></td></tr></table></figure><p>18版本的<code>zap-to-char</code>看起来更加复杂，并且功能也更多。</p><p>首先，两个版本的主要作用基本相同，都是为了将当前位点到指定字符的位置之间的区域剪<br>切，18版本相比较于19版本，多了几个特性:</p><ul><li>不会剪切指定字符(忽略指定的字符，其他的剪切)</li><li>当指定字符不存在将会改变位点为buffer的位点最小值或最大值。 </li></ul><p>下面让我们来分析下吧!</p><p>看到<code>interactive</code>表达式，并没有任何改变，这里可以忽略。而<code>kill-region</code>的第一个参<br>量仍然是当前位点，后面则有巨大的改变。第二个参量被一个<code>if</code>表达式包裹住，这个<br><code>if</code>表达式的CONS部分是一个<code>search-forward</code>函数，其作用是判断指定字符是否存在，如<br>果存在则执行THEN部分的<code>progn</code>表达式。</p><h3 id="progn表达式主体"><a href="#progn表达式主体" class="headerlink" title="progn表达式主体"></a>progn表达式主体</h3><p><code>progn</code>函数的表达式主体内有两个参量，根据<code>progn</code>函数的特性，我们知道，只有最后一<br>个参量会被返回，先看看第一个参量，  是一个<code>goto-char</code>函数，让我们回顾下18版本的<br>特性，其在剪切时会忽略指定的字符，那么这个<code>goto-char</code>函数就是做了这么件事，当ARG<br>大于0时(往前搜索时字符出现的次数)，那么就将位点往后挪一，反之加一。最后由于改变<br>了位点， 并且<code>progn</code>函数的第二个参量是<code>(point)</code>又将改变后的位点返回，也就成了<br><code>kill-region</code>函数的结束区域了。</p><p>最后是<code>if</code>表达式的ELSE部分，其作用是当为查找到指定字符时，将会根据ARG的值来判断<br>剪切到最后还是最前。</p><h2 id="kill-region函数"><a href="#kill-region函数" class="headerlink" title="kill-region函数"></a>kill-region函数</h2><p>在前面的<code>zap-to-char</code>函数使用了<code>kill-region</code>函数，现在让我们来康康这个函数的内部<br>实现吧！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(defun kill-region-19 (begin end)</span><br><span class="line">  &quot;Kill between point and mark.</span><br><span class="line">The text is deleted but saved in the kill ring.&quot;</span><br><span class="line">  (interactive &quot;*r&quot;)</span><br><span class="line">  (copy-region-as-kill begin end)</span><br><span class="line">  (delete-region begin end))</span><br></pre></td></tr></table></figure><p><strong>注意: 看注释</strong></p><h2 id="delete-region函数-接触C"><a href="#delete-region函数-接触C" class="headerlink" title="delete-region函数:接触C"></a>delete-region函数:接触C</h2><p><code>kill-region</code>函数的<code>delete-region</code>函数是一个由C语言宏编写的函数，让我们看看它的<br>第一部分:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DEFUN (<span class="string">"delete-region"</span>, Fdelete_region, Sdelete_region, <span class="number">2</span>, <span class="number">2</span>, <span class="string">"r"</span>,</span><br><span class="line">       doc: <span class="comment">/* Delete the text between START and END.</span></span><br><span class="line"><span class="comment">If called interactively, delete the region between point and mark.</span></span><br><span class="line"><span class="comment">This command deletes buffer text without modifying the kill ring.  */</span>)</span><br><span class="line">  (Lisp_Object start, Lisp_Object end)</span><br><span class="line">&#123;</span><br><span class="line">  validate_region (&amp;start, &amp;end);</span><br><span class="line">  del_range (XINT (start), XINT (end));</span><br><span class="line">  <span class="keyword">return</span> Qnil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不过多解释(书中没讲，本人也不太了解)</p><p>这个宏可以分为7个部分分别是:</p><ul><li>Lisp 中的函数名，也就是被双引号括住的”delete-region”。</li><li>C语言中的函数名，也就是<code>Fdelete_region</code>。</li><li>C常数结构名，<code>Sdelete_region</code>。</li><li>第四和第五部分是指明函数参量数目的最小和最大值。</li><li>第六部分就像interactive函数的说明表达式一样， 这里是”r”，代表函数的两个参量是<br>某个缓冲区中某个区域的开始和结束。</li><li>第七部分是文档字符串，跟Emacs Lisp的函数文档不同在于换行时必须显式的写出<code>\n</code>。</li></ul><p>再后面就是真正的函数参量，并且每个参量所对应的数据类型都有一段解释。</p><p>下面则是函数的主体了，其中<code>validate-region</code>函数用于检查参量的值的类型，而<br><code>del-range</code>函数则是用于删除区域内字符的函数。</p><h2 id="用defvar初始化变量"><a href="#用defvar初始化变量" class="headerlink" title="用defvar初始化变量"></a>用defvar初始化变量</h2><p><code>defvar</code>用于初始化变量，想必有些小伙伴会想到<code>setq</code>，<code>defvar</code>与其的区别在于:</p><ul><li><code>defvar</code>只能为无值的变量赋值。</li><li><code>defvar</code>如果在为一个有值的变量赋值时将不会覆盖。</li><li>由<code>defvar</code>设置的变量可以给予变量文档。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(defvar box nil</span><br><span class="line">  &quot;Just a test box&quot;)</span><br><span class="line">box ;; =&gt; nil</span><br><span class="line">(defvar box 20</span><br><span class="line">  &quot;Just a test box&quot;)</span><br><span class="line">  box ;; = &gt; nil</span><br></pre></td></tr></table></figure><p>不是说由 <code>defvar</code>定义的变量就不能够重新赋值了，其实是可以的，但是必须在变量文档<br>前加上<code>*</code>，并且由<code>setq</code>变量重新赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(defvar t-box nil</span><br><span class="line">  &quot;*Just a test box&quot;)</span><br><span class="line">t-box ;; =&gt; nil</span><br><span class="line">(defvar t-box 20</span><br><span class="line">  &quot;*Just a test box&quot;)</span><br><span class="line">t-box ;; =&gt; nil</span><br><span class="line">(setq t-box 20)</span><br><span class="line">t-box ;; =&gt; 20</span><br></pre></td></tr></table></figure><h2 id="copy-region-as-kill函数"><a href="#copy-region-as-kill函数" class="headerlink" title="copy-region-as-kill函数"></a>copy-region-as-kill函数</h2><blockquote><p>这一小节我鸽了好久，原因是内容有点多，我懒得写。。</p></blockquote><blockquote><p>好了，让我们继续写吧(刚刚看了欧阳娜娜的Vlog，感觉真好)！</p></blockquote><p>先让我们看看这个函数的源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(defun copy-region-as-kill (begin end)</span><br><span class="line">  &quot;Save the region as if killed, but don&apos;t kill it.&quot;</span><br><span class="line">  (interactive &quot;r&quot;)</span><br><span class="line">  (if (eq last-command &apos;kill-region)</span><br><span class="line">      ;; then-part: Combine newly copied text with previously copied text</span><br><span class="line">      (kill-append (buffer-substring begin end) (&lt; end begin))</span><br><span class="line"></span><br><span class="line">``    ;; else-part: Add newly copied text as new element</span><br><span class="line">``    ;; to the kill ring and shorten the kill ring if necessary</span><br><span class="line">    (setq kill-ring</span><br><span class="line">          (cons (buffer-substring begin end) kill-ring))</span><br><span class="line">    (if (&gt; (length kill-ring) kill-ring-max)</span><br><span class="line">        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))</span><br><span class="line">  (setq this-command &apos;kill-region)</span><br><span class="line">  (setq kill-ring-yank-pointer kill-ring))</span><br></pre></td></tr></table></figure><p>由于书上的内容我是前几天看的，而我每次写笔记又是直接根据源码来解读的，所以跟书上<br>有些表达不同（甚至有错误），希望各位能理解（有没有人看都是个问题..)。</p><p>根据这个函数的文档可以知道，这个函数的作用是:如果某个区域被剪切过了那么就将其保<br>存，但是并不再一次剪切。</p><p><code>copy-region-as-kill</code>函数接收两个参量，它们分别代表了两个位置，通过这两个位置可<br>以确定一个区域。</p><h3 id="copy-region-as-kill函数体"><a href="#copy-region-as-kill函数体" class="headerlink" title="copy-region-as-kill函数体"></a>copy-region-as-kill函数体</h3><p>把视野转向<code>interactive</code>函数，其表达式只有一个<code>r</code>，它的作用是：代表这个函数接收一<br>个<code>region</code>，也就是把<code>point</code>和<code>mark</code>作为这个函数的两个参量以数值类型传递过去。</p><p>随后让我们看到<code>if</code>特殊表，它几乎涵盖了整个函数体，下面我们来看看其<code>CONS</code>部分的作<br>用。<code>CONS</code>部分如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(eq last-command &apos;kill-region)</span><br></pre></td></tr></table></figure><p>这里有一个我们没有遇到过的函数————<code>eq</code>，其作用跟<code>equal</code>函数类似，用于比较，但<br><code>eq</code>函数比较的是其参量的对象是否相同，然而<code>eqaul</code>函数用于判断其参量的内容或结构<br>是否相同。</p><p>这里就是将<code>last-command</code>与<code>kill-region</code>进行比较，其中<code>last-command</code>是一个变量，<br>其作用是记录最后一个执行过的命令。在这个例子中就是将 Emacs最后一次执行的命令与<br><code>kill-region</code>进行对象比对，测试其是否为同一个对象。换种说法就是<code>if</code>特殊表判断最<br>后一次执行的命令是否为<code>kill-region</code>。</p><p>如果是<code>kill-region</code>那么会发生什么呢？先让我们回顾前一章所学的<code>kill-region</code>，其作<br>用是将某个<code>region</code>添加到<code>kill环</code>中，并将其删除，从而实现剪切的操作。并且由于其通<br>常只被<code>kill-region</code>函数所使用，所以对于<code>kill-region</code>进行单独适配。</p><p>让我们看向<code>THEN</code>部分吧！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(kill-append (buffer-substring begin end) (&lt; end begin))</span><br></pre></td></tr></table></figure><p>整个<code>THEN</code>部分只有一个<code>kill-append</code>函数， 通过这个函数名我们就大概能猜到其作用是<br>将数据<code>追加</code>到<code>kill环</code>的操作。</p><p>首先，<code>kill-append</code>函数接收两个参量，先说第一个，其要求第一个参量是一个<br><code>STRING</code>类型的数值，而这里就可以使用<code>buffer-substrin</code>函数获得要追加的字符串。第<br>二个参量用于判断将<code>STRING</code> 放置于<code>kill环</code>中原数据之前还是之后，这里就是将<code>end</code>与<br><code>begin</code>进行比较，如果结束位置小于开始位置则代表用户想要从缓冲区的开始往后剪切，<br>否则是从缓冲区后往前进行剪切。</p><p>下面我们看<code>ELSE</code>部分，这个部分是当最后一个执行的命令不是<code>kill-region</code>时触发的，<br>其作用让我们潸潸道来，首先是用<code>setq</code>函数更新<code>kill-ring</code>中的数据:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(setq kill-ring</span><br><span class="line">      (cons (buffer-substring begin end) kill-ring))</span><br></pre></td></tr></table></figure><p>其为<code>kill-ring</code>重新赋值，值为通过<code>buffer-substring</code>函数获取的字符串，并将其通过<br><code>cons</code>函数将字符串设置为<code>kill-ring</code>的car部分。</p><p>随后是一个<code>if</code>表达式，这个表达式的作用是防止<code>kill环</code>的长度超过<code>kill-ring-max</code>的<br>值，如果当前<code>kill-ring</code>的长度超过<code>kill-ring-max</code>，那么就将<code>kill-ring</code>最后一个元<br>素去除。去除的方式是通过<code>setcdr</code>以及<code>nthcdr</code>函数，首先通过<code>nthcdr</code>函数获取<code>kill环</code>中最后一个元素，再通过<code>setcdr</code>函数将其设置为<code>nil</code>。</p><p>到此，涵盖整个函数体的<code>if</code>表达式就执行完了，后面的则一些后续的工作，例如设置<br><code>this-command</code>值为<code>kill-region</code>函数。</p><p>最后的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(setq kill-ring-yank-pointer kill-ring)</span><br></pre></td></tr></table></figure><p>中的<code>kill-ring-yank-pointer</code>也只不过是<code>kill-ring</code>的一个全局变量的复制品罢了。</p><h2 id="回顾-2"><a href="#回顾-2" class="headerlink" title="回顾"></a>回顾</h2><ul><li><p>cdr,car<br>car 返回一个列表的第一个元素，cdr返回从列表第二个元素开始到最后一个元素的列表。</p></li><li><p>cons<br>这个函数用于将其第一个参量插入至第二个参量从而构造一个新列表。</p></li><li><p>nthcdr<br>获取第一个参量个第二个参量的cdr部分。</p></li><li><p>setcdr、setcar<br>setcar用于设置列表的car部分，setcdr用于设置列表的car部分。</p></li><li><p>progn<br>这个函数可以依次对其多个参量求值并最终返回最后一个参量的值。</p></li><li><p>save-restriction<br>这个函数用于记录当前缓冲区变窄是否设置，如果设置那么其后续的参量求值后都将恢<br>复记录过的变窄设置。</p></li><li><p>search-forward<br>这个函数用于查找字符串，如果查找就将当前位点改变为查找到的字符串的位点。<br>并且其还自带四个参量:</p><ul><li>要查找的字符串</li><li>查找的限制范围(region)</li><li>如果查找失败的处理方式，如果为nil则返回错误信息。</li><li>重复查找多次</li></ul></li><li><p>kill-region<br>此函数将<code>region</code>复制进<code>kill环</code>并 将其在buffer中删除。</p></li><li><p>delete-region<br>将某个<code>region</code>之间的数据全部删除。</p></li><li><p>copy-region-as-kill<br>将某个<code>region</code>之间的数据复制进<code>kill环</code>。</p></li></ul><h2 id="查找练习"><a href="#查找练习" class="headerlink" title="查找练习"></a>查找练习</h2><ul><li>编写一个查找字符串的交互函数。如果找到需要的字符串，在其后设置位点并显示这样的<br>一条消息:”Found!”</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defun search-forward-t (str)</span><br><span class="line">  (interactive &quot;MSearch String:&quot;)</span><br><span class="line">  (let ((isfound nil))</span><br><span class="line">    (if (search-forward str nil nil nil)</span><br><span class="line">        (message &quot;Found!&quot;))))</span><br></pre></td></tr></table></figure><ul><li>编写一个函数，这个函数在回显区打印kill环的三个元素，如果kill环没有第三个元素，<br>则打印一条适当的消息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defun print-kill-ring-three ()</span><br><span class="line">  (if (nthcdr 3 kill-ring)</span><br><span class="line">      (nthcdr 3 kill-ring)</span><br><span class="line">    (message &quot;kill-ring not have 3&apos;th cdr&quot;)))</span><br></pre></td></tr></table></figure><ul><li>在第19.29版中，copy-region-as-kill函数不再设置this-command变量。这种变化的后果<br>是什么？要采取什么相应的变化，才能达到相同的效果? </li></ul><p>答: 不会</p><h1 id="第九章-列表是如何实现的"><a href="#第九章-列表是如何实现的" class="headerlink" title="第九章 列表是如何实现的"></a>第九章 列表是如何实现的</h1><p>本章讲述的是列表的原理而不是实现，也不知道书中为何要这么起标题。</p><p>列表是由一系列的成对指针构成的，这每对指针的第一个指针要么指向一个原子，要么指向<br>另一个列表，而第二个指针要么指向下一个系列列表要么指向nil，nil也就代表这整个列表<br>系列中最后一个列表。 </p><p>指针其实就是一个指向电子地址的玩意，由此可得知列表就是一堆指向电子地址的指针。</p><p>那一个简单的列表举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;(rose violet buttercup)</span><br></pre></td></tr></table></figure><p>这个列表中有三个元素，每个元素也就是我们所说的一个成对的指针，如图:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> ___ ___       ___ ___       ___ ___</span><br><span class="line">|___|___| --&gt; |___|___| --&gt; |___|___| --&gt; nil</span><br><span class="line">  |             |             |</span><br><span class="line">  |             |             |</span><br><span class="line">  --&gt;rose       --&gt; violet    --&gt; buttercup</span><br></pre></td></tr></table></figure><p>上图每个方框都代表计算机中的某个地址，例如，第一个方框中保存的就是指向”rose”的地<br>址，你也可以直接理解为保存的就是”rose”的地址，计算机可以直接通过地址来访问”rose”<br>这个数据。而第二个方框要么指向下一个元素要么指向nil，这里是指向的下一个元素的地<br>址，这个地址也就是第二个成对方框的地址，而这第二个元素的第一个方框中保存的是<br>“violet”的地址，跟第一个元素的第一个方框一样，有不同的在于第三个元素的第二个方框，<br>它指向的是一个nil，代表这个元素是这个列表最后的元素，也就是用于标记结束。</p><p>如果我们通过<code>setq</code>函数将这个整个列表赋值给一变量这个图会怎么表示呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(setq bouquet &apos;(rose violet buttercup))</span><br></pre></td></tr></table></figure><p>我们知道<code>setq</code>的第二个参量是一个列表，所以只需要将这个列表的第一个元素的地址赋值<br>给<code>bouquet</code>，这样就可以通过<code>bouquet</code>访问这个花(上面的这个列表可以称为花列表，因<br>为它们都是花的名称)列表了。</p><p>用图表示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bouquet</span><br><span class="line">      |</span><br><span class="line">      |</span><br><span class="line">      |     ___ ___       ___ ___       ___ ___</span><br><span class="line">      --&gt;  |___|___| --&gt; |___|___| --&gt; |___|___| --&gt; nil</span><br><span class="line">              |             |             |</span><br><span class="line">              |             |             |</span><br><span class="line">              --&gt;rose       --&gt; violet    --&gt; buttercup</span><br></pre></td></tr></table></figure><p>前面说过Lisp中除了列表就是原子，像前面这个花列表的每个元素也可以称为一个列表或是<br>cons，因为是成对的结构，我们可以理解为<code>car</code>和<code>cdr</code>的关系，如果用图可以这样表示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bouquet</span><br><span class="line">      |</span><br><span class="line">      |     ________ _______       ________ ________       _________ ________</span><br><span class="line">      --&gt;  | car    | cdr   |     |  car   | cdr    |     | car     | cdr    |</span><br><span class="line">           | rose   | 0     ----&gt; | violet | 0      ----&gt; | butter- | 0      |</span><br><span class="line">           |        |       |     |        |        |     | cup     |        |</span><br><span class="line">            -------   ------       -------- --------       --------- --------</span><br></pre></td></tr></table></figure><p>对于函数来说，我们可以将它的结构想象成一个抽屉，通过下图来将想象的抽屉画出来:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      抽屉箱子              抽屉内容</span><br><span class="line"> ___________________</span><br><span class="line">|                   |</span><br><span class="line">| symbol name       | --&gt; bouquet</span><br><span class="line">|                   |</span><br><span class="line"> -------------------</span><br><span class="line">|                   |</span><br><span class="line">| symbol definition | --&gt; [none]</span><br><span class="line">|                   |</span><br><span class="line"> -------------------</span><br><span class="line">|                   |</span><br><span class="line">| variable value    | --&gt; (rose violet buttercup)</span><br><span class="line">|                   |</span><br><span class="line"> -------------------</span><br><span class="line">|                   |</span><br><span class="line">| property list     | --&gt; [not describe here]</span><br><span class="line">|                   |</span><br><span class="line"> -------------------</span><br><span class="line">|/                 \|</span><br></pre></td></tr></table></figure><p>ELisp把符号定义、变量值、符号名放在单独的抽屉内，每个抽屉内存储的是其指向的真正<br>数据的地址，这样做的好处是例如在改变变量值时其他的符号不会有任何改变。</p><p>其实还有一个属性列表，书中没有讲，有兴趣的可以点下这个连接<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Property-Lists.html" target="_blank" rel="noopener">Property List With GNU-EMACS Manual</a></p><p>符号讲完，我们再继续讨论，如果将一个列表的cdr部分赋值给一个变量，那么用图怎么表<br>示它的结构呢？先看看如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(setq flowers (cdr bouquet))</span><br></pre></td></tr></table></figure><p>其实十分简单，也只不过是通过<code>cdr</code>函数取出<code>bouquet</code>变量所指向的花列表的第二部分，<br>然后将其地址赋值给<code>flowers</code>变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bouquet</span><br><span class="line">      |        flowers</span><br><span class="line">      |              |</span><br><span class="line">      |     ___ ___  |    ___ ___       ___ ___</span><br><span class="line">      |    |   |   | --&gt; |   |   |     |   |   | </span><br><span class="line">       --&gt; |___|___| --&gt; |___|___| --&gt; |___|___| --&gt; nil</span><br><span class="line">              |             |             |</span><br><span class="line">              --&gt;rose       --&gt; violet    --&gt; buttercup</span><br></pre></td></tr></table></figure><h2 id="带点偶对"><a href="#带点偶对" class="headerlink" title="带点偶对"></a>带点偶对</h2><p>带点偶对(dotted pair)又被称为cons原胞(cons cell)，它代表一个成对的地址框。</p><p>我们都知道<code>cons</code>函数会把第一个参量作为新元素插入到第二个列表类型的参量中作为<br><code>car</code>部分，那如果插入一个新值其他与其他元素有关系的符号会不会有影响呢？请看代码<br>和图:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(setq bouquet (cons &apos;lily bouquet))</span><br></pre></td></tr></table></figure><p>上段代码可以得到下图:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bouquet</span><br><span class="line">      |                    flowers</span><br><span class="line">      |                          |</span><br><span class="line">      |    ___ ___      ___ ___  |    ___ ___       ___ ___</span><br><span class="line">      |   |   |   |    |   |   | --&gt; |   |   |     |   |   | </span><br><span class="line">       --&gt;|___|___|--&gt; |___|___| --&gt; |___|___| --&gt; |___|___| --&gt; nil</span><br><span class="line">              |             |             |</span><br><span class="line">              --&gt; lily      --&gt;rose       --&gt; violet    --&gt; buttercup</span><br></pre></td></tr></table></figure><p>如果用<code>eq</code>函数将<code>flowers</code>与<code>bouquet</code>的<code>nthcdr</code> 2 部分进行比较会是怎样呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(eq flowers (nthcdr 2 bouquet))</span><br></pre></td></tr></table></figure><p>我们发现<code>flowers</code>的值并没有变化，这完全是因为Lisp中，想要得到一个列表的<code>cdr</code>，只<br>要得到地址系列中下一个cons原胞的地址即可；要得到一个列表的<code>car</code>只需要的得到这个<br>列表的第一个元素的地址；而要插入一个新元素，只不过是往列表中添加了新的cons原胞罢<br>了。</p><p>经过上面的演示，可以得到一个列表最后一个cons原胞的最后一个地址指向的是。</p><h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><p>将符号flowers设置为violet和buttercup两个元素组成的列表啊。 往这个列表中增加两种<br>新的花名，并将这个列表赋值给more-flowers变量。将flowers的car设置为一种鱼的名字。<br>看一看more-flowers列表现在的内容是什么?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(setq flowers &apos;(violet buttercup)) ;; ==&gt; (violet buttercup)</span><br><span class="line">(setq more-flowers (cons &apos;chrysanthemum (cons &apos;carnation flowers)))  ;; ==&gt; (chrysanthemum carnation violet buttercup)</span><br><span class="line">(setcar flowers &apos;shark) ;; ==&gt; shark</span><br><span class="line">more-flowers ;; ==&gt; (chrysanthemum carnation shark buttercup)</span><br></pre></td></tr></table></figure><h1 id="第十章-找回文本"><a href="#第十章-找回文本" class="headerlink" title="第十章 找回文本"></a>第十章 找回文本</h1><blockquote><p>女朋友闹分手，很好(都是我的错)，我又有时间学习了.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;借了本Elisp的书，不厚，200多页，大概一周(两周(一個月))就能看完吧!&lt;/p&gt;
    
    </summary>
    
    
      <category term="EmacsLisp" scheme="https://evanmeek.github.io/tags/EmacsLisp/"/>
    
  </entry>
  
  <entry>
    <title>参加广州LUG线下见面会</title>
    <link href="https://evanmeek.github.io/2019/12/15/%E5%8F%82%E5%8A%A0%E5%B9%BF%E5%B7%9ELUG%E7%BA%BF%E4%B8%8B%E8%A7%81%E9%9D%A2%E4%BC%9A/"/>
    <id>https://evanmeek.github.io/2019/12/15/参加广州LUG线下见面会/</id>
    <published>2019-12-15T15:57:36.000Z</published>
    <updated>2020-01-22T04:44:27.751Z</updated>
    
    <content type="html"><![CDATA[<p>今天下午我去参加了广州LUG线下见面会!</p><a id="more"></a><p>&Emsp;&emsp;首先先对持续关注(Nobody)我博客的同仁们说声抱歉，博客好像有几个月没有更新了，主要是因为从NeoVim换为Emacs还未习惯。再加上我一直在找直接编写org文件，然后让后端渲染器能直接渲染org文件的博客后端渲染器。中间也确实见到过几个，例如<code>org-page</code>，但折腾来折腾去也未折腾好，所以还是使用Emacs编写Markdown吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天下午我去参加了广州LUG线下见面会!&lt;/p&gt;
    
    </summary>
    
      <category term="个人感想" scheme="https://evanmeek.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-文本处理三剑客-3</title>
    <link href="https://evanmeek.github.io/2019/12/12/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-3/"/>
    <id>https://evanmeek.github.io/2019/12/12/Linux-文本处理三剑客-3/</id>
    <published>2019-12-12T09:07:28.000Z</published>
    <updated>2020-01-22T04:44:27.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-1-grep-文本过滤工具"><a href="#4-1-grep-文本过滤工具" class="headerlink" title="4.1 grep: 文本过滤工具"></a>4.1 grep: 文本过滤工具</h1><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><p>功能说明</p><p>grep命令可以从文本文件或管道数据流中筛选匹配的行或数据，还可以配合正则表达式一起<br>使用。</p><p>语法格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [参数] [匹配模式] [需要查找的文件]</span><br></pre></td></tr></table></figure><p>选项说明</p><table><thead><tr><th>参数选项</th><th>解释说明</th></tr></thead><tbody><tr><td>-v</td><td>排除某行</td></tr><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-i</td><td>不区分大小写</td></tr><tr><td>-c</td><td>统计匹配行数</td></tr><tr><td>-E</td><td>使用egrep命令替代grep</td></tr><tr><td>–color=auto</td><td>为grep过滤后匹配的字符串添加颜色</td></tr><tr><td>-w</td><td>只匹配过滤的单词</td></tr><tr><td>-o</td><td>只输出匹配的内容</td></tr></tbody></table><h2 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h2><ol><li>基础范例</li></ol><p>使用grep过滤不包括evanmeek字符串的行(-v参数实践)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜   cat test.txt </span><br><span class="line">China</span><br><span class="line">Japan</span><br><span class="line">root</span><br><span class="line">EvanMeek</span><br><span class="line">MyBlog</span><br><span class="line">evanmeek</span><br><span class="line"></span><br><span class="line">➜   grep -v "evanmeek" test.txt</span><br><span class="line">China</span><br><span class="line">Japan</span><br><span class="line">root</span><br><span class="line">EvanMeek</span><br><span class="line">MyBlog</span><br></pre></td></tr></table></figure><p><em>提示:</em> grep命令-v参数正如刚刚输出所示，会将过滤参数后的内容。</p><p>使用grep过滤包括evanmeek字符串的行，并显示其所在行行号(-n实践)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 文本内容相同，我们使用下面这条命令，看看会发生什么</span><br><span class="line">➜   grep -n "evanmeek" test.txt </span><br><span class="line"><span class="meta">#</span> 我们得到了test.txt中包含evanmeek的行且行号。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 我们也可以使用.匹配任意内容，相当于看test.txt文件内容加上行号</span><br><span class="line">➜   grep -n "." test.txt </span><br><span class="line">1:China</span><br><span class="line">2:Japan</span><br><span class="line">3:root</span><br><span class="line">4:EvanMeek</span><br><span class="line">5:MyBlog</span><br><span class="line">6:evanmeek</span><br><span class="line">6:evanmeek</span><br></pre></td></tr></table></figure><p>不区分大小写参数实践</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> grep在过滤时可以选择忽略区分大小写，默认是区分的</span><br><span class="line"><span class="meta">#</span> 文件内容相同,使用-i参数忽略大小写，-n参数选择要筛选的内容并有行号</span><br><span class="line">➜   grep -i -n "evanmeek" test.txt</span><br><span class="line">4:EvanMeek</span><br><span class="line">6:evanmeek</span><br></pre></td></tr></table></figure><p>计算匹配的字符串的数量(-c参数实践)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;4-1-grep-文本过滤工具&quot;&gt;&lt;a href=&quot;#4-1-grep-文本过滤工具&quot; class=&quot;headerlink&quot; title=&quot;4.1 grep: 文本过滤工具&quot;&gt;&lt;/a&gt;4.1 grep: 文本过滤工具&lt;/h1&gt;&lt;h2 id=&quot;命令详解&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Linux系列" scheme="https://evanmeek.github.io/categories/Linux%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Linux" scheme="https://evanmeek.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>[Python-07]Python函数和Lambda表达式</title>
    <link href="https://evanmeek.github.io/2019/10/09/Python-07-Python%E5%87%BD%E6%95%B0%E5%92%8CLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://evanmeek.github.io/2019/10/09/Python-07-Python函数和Lambda表达式/</id>
    <published>2019-10-09T07:34:55.000Z</published>
    <updated>2020-01-22T04:44:27.745Z</updated>
    
    <content type="html"><![CDATA[<p>Python系列第七章笔记，查看Python系列所有文章，请点击<a href="http://c.biancheng.net/python/str_method/" target="_blank" rel="noopener">💿</a></p><a id="more"></a><p>本章记录定义函数、调用函数以及大量有关Python的高级内容。</p><p>还会记录Lambda表达式，学习完Lambda表达式后可以让源代码更加简洁。</p><h1 id="Python函数（函数定义、函数调用）用法详解"><a href="#Python函数（函数定义、函数调用）用法详解" class="headerlink" title="Python函数（函数定义、函数调用）用法详解"></a>Python函数（函数定义、函数调用）用法详解</h1><p>我们之前以及用到过很多的函数，例如:<code>print() range() len()</code> 等等，不过这些都是Python的内置函数，Python还允许我们自定义函数，也就是将一段代码定义成函数，从而达到<code>一次编写、多次调用的目的</code> 。</p><h2 id="Python函数的定义"><a href="#Python函数的定义" class="headerlink" title="Python函数的定义"></a>Python函数的定义</h2><p>想要定义函数需要使用def关键字实现，语法格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def function_name([params]):</span><br><span class="line">    code_space</span><br><span class="line">    [return [value]]</span><br></pre></td></tr></table></figure><p>其中由<code>[]</code> 括起来的为可选部分。</p><p>语法格式解释:</p><ul><li><p>function_name: 函数名，需要符合合法的标识符。</p></li><li><p>params: 形式参数列表，也就是定义该函数可以接受的参数。可以有多个，多个之间使用英文逗号(<code>,</code> )隔开。</p></li><li><p>code_space: 代码块，也就是调用函数时需要执行的代码，记得缩进。</p></li></ul><p><strong>注意: 在创建函数时，即使函数不需要参数，也必须保留括号。</strong> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 求最大值</span><br><span class="line">def my_max(x,y):</span><br><span class="line">    return  x if x &gt; y else y</span><br></pre></td></tr></table></figure><h2 id="Python函数的调用"><a href="#Python函数的调用" class="headerlink" title="Python函数的调用"></a>Python函数的调用</h2><p>调用函数也就是执行定义过的函数。</p><p>函数调用语法格式:</p><p><code>function_name([params])</code></p><p><strong>注意:函数定义时有多少个参数，我们调用时就必须传入相同数量的参数个数。并且如果调用的函数原型没有参数，调用时也不能省略括号。</strong> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(my_max(10,20))</span><br></pre></td></tr></table></figure><p>运行过程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h2 id="为函数提供说明文档"><a href="#为函数提供说明文档" class="headerlink" title="为函数提供说明文档"></a>为函数提供说明文档</h2><p>前目提到过可以使用<code>help()</code> 命令查看指定函数的帮助文档。</p><p>想要为函数添加说明文档可以在函数声明后，代码块之前插入字符串以作为函数的说明文档。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def say_helloworld():</span><br><span class="line">    &quot;输出HelloWorld&quot;</span><br><span class="line">    print(&quot;HelloWorld&quot;)</span><br><span class="line"></span><br><span class="line">print(help(say_helloworld))</span><br><span class="line">print(say_helloworld.__doc__)</span><br></pre></td></tr></table></figure><p>运行过程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Help on function say_helloworld in module __main__:</span><br><span class="line"></span><br><span class="line">say_helloworld()</span><br><span class="line">    输出HelloWorld</span><br><span class="line">(END)</span><br><span class="line"></span><br><span class="line">None</span><br><span class="line">输出HelloWorld</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h1 id="Python函数值传递和引用传递-包括形式参数和实际参数的区别"><a href="#Python函数值传递和引用传递-包括形式参数和实际参数的区别" class="headerlink" title="Python函数值传递和引用传递(包括形式参数和实际参数的区别)"></a>Python函数值传递和引用传递(包括形式参数和实际参数的区别)</h1><h2 id="形参实参的区别"><a href="#形参实参的区别" class="headerlink" title="形参实参的区别"></a>形参实参的区别</h2><p>形参又被称为形式参数，也就是指：在定义函数时，函数列表中的参数，叫做形参。</p><p>实参又被称作实际参数，也就是指：在调用函数时，向函数列表中传递的参数，叫做实际参数。</p><h2 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h2><p>值传递使用场景: 不可变类型(字符串，数字，元组)<br>引用传递: 可变类型（列表、字典）</p><p>两者区别: <strong>值传递的时候，实参传递给形参后，如果形参被修改，实参不收影响。引用传递时，则会改变。</strong> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def change_param(x):</span><br><span class="line">    x+=[4] if isinstance(x,list) else 1</span><br><span class="line">    print(x)</span><br><span class="line">a = 10</span><br><span class="line">change_param(a)</span><br><span class="line">print(a)</span><br><span class="line">b = [1,2,3]</span><br><span class="line">change_param(b)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>运行过程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">10</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h1 id="Python函数参数传递机制-超级详细"><a href="#Python函数参数传递机制-超级详细" class="headerlink" title="Python函数参数传递机制(超级详细)"></a>Python函数参数传递机制(超级详细)</h1><p>本笔记不讨论，想要了解<a href="http://c.biancheng.net/view/2258.html" target="_blank" rel="noopener">查看原文</a> </p><h1 id="Python位置参数"><a href="#Python位置参数" class="headerlink" title="Python位置参数"></a>Python位置参数</h1><p>一句话解释:<code>调用函数时传入的实参的数量和位置必须和定义函数时的形参保持一致</code> </p><h1 id="Python关键字参数"><a href="#Python关键字参数" class="headerlink" title="Python关键字参数"></a>Python关键字参数</h1><p>如果不想要记住参数的位置，我们可以使用关键字参数特性，在调用函数时为实际参数指定一个参数名。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test(x,y,z):</span><br><span class="line">    return x*y+z</span><br><span class="line">print(test(10,20,10))</span><br><span class="line">print(test(z=10,y=20,x=10))</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">210</span><br><span class="line">210</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p><strong>注意:如果要在传递实参时混用关键字参数与位置参数，必须确保关键字参数置于位置参数之前。</strong></p><h1 id="Python默认参数"><a href="#Python默认参数" class="headerlink" title="Python默认参数"></a>Python默认参数</h1><p>我们可以给形参指定默认参数，这样在调用时，可以省略传入实参。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def user_name(name=&quot;未命名&quot;):</span><br><span class="line">    print(&quot;你的姓名:&quot;,name)</span><br><span class="line"></span><br><span class="line">user_name()</span><br><span class="line">user_name(&quot;EvanMeek&quot;)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你的姓名: 未命名</span><br><span class="line">你的姓名: EvanMeek</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h1 id="Python-函数可变参数"><a href="#Python-函数可变参数" class="headerlink" title="Python 函数可变参数"></a>Python 函数可变参数</h1><p>如果在编写函数时，不确定需要使用多少个参数，我们就可以使用可变参数这个特性。</p><p>可变参数有两种形式，分别是在形参之前添加个<strong>一</strong><code>*</code> 与在形参之前添加个<strong>两</strong><code>*</code> 。</p><h1 id="可变参数-形参前添加一个"><a href="#可变参数-形参前添加一个" class="headerlink" title="可变参数:形参前添加一个*"></a>可变参数:形参前添加一个<code>*</code></h1><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 忽略这个反斜杠，因为markdown的缘故</span><br><span class="line">def test(x,\*y):</span><br><span class="line">    print(type(x),&quot;\n&quot;,x)</span><br><span class="line">    print(type(y),&quot;\n&quot;,y)</span><br><span class="line">test(10,&quot;你好&quot;,&quot;世界&quot;,9.09,0xa)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line"> 10</span><br><span class="line">&lt;class &apos;tuple&apos;&gt;</span><br><span class="line"> (&apos;你好&apos;, &apos;世界&apos;, 9.09, 10)</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p>可以看到，实际上可变参数是将多个参数包含在一个元组内，然后将其输出。</p><h2 id="可变参数-形参前添加两个"><a href="#可变参数-形参前添加两个" class="headerlink" title="可变参数:形参前添加两个*"></a>可变参数:形参前添加两个<code>*</code></h2><p>前面的第一种可变参数形式，是往形参前添加一个*，并且我们知道它其实就是个元组，那么第二种形式提前透露一下，它其实就是个字典</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test(x,**y):</span><br><span class="line">    print(type(x),&quot;\n&quot;,x)</span><br><span class="line">    print(type(y),&quot;\n&quot;,y)</span><br><span class="line">test(10,语文=100,数学=9.99,英语=8.88)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line"> 10</span><br><span class="line">&lt;class &apos;dict&apos;&gt;</span><br><span class="line"> &#123;&apos;语文&apos;: 100, &apos;数学&apos;: 9.99, &apos;英语&apos;: 8.88&#125;</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h2 id="可变参数：形参前添加两个"><a href="#可变参数：形参前添加两个" class="headerlink" title="可变参数：形参前添加两个*"></a>可变参数：形参前添加两个<code>*</code></h2><p>语法格式如下:</p><p><code>**kwargs</code> </p><ul><li>*kw表示创建一个名为kwargs的空字典，该字典可以接收任意多个以关键字参数赋值的实际参数。</li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test(x,**y):</span><br><span class="line">    print(type(x),&quot;\n&quot;,x)</span><br><span class="line">    print(type(y),&quot;\n&quot;,y)</span><br><span class="line">test(10,语文=100,数学=9.99,英语=8.88)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line"> 10</span><br><span class="line">&lt;class &apos;dict&apos;&gt;</span><br><span class="line"> &#123;&apos;语文&apos;: 100, &apos;数学&apos;: 9.99, &apos;英语&apos;: 8.88&#125;</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h1 id="Python逆向参数收集详解"><a href="#Python逆向参数收集详解" class="headerlink" title="Python逆向参数收集详解"></a>Python逆向参数收集详解</h1><p>逆向参数也就是说将程序中定义的列表、元组、字典等对象的元素拆开后传递给函数的参数。</p><p><strong>逆向参数收集需要在传入的列表、元组参数之前添加一个星号，在字典参数之前添加两个星号</strong> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def get_sum(*x):</span><br><span class="line">    sum = 0</span><br><span class="line">    for ele in x:</span><br><span class="line">        sum += ele</span><br><span class="line">    return sum</span><br><span class="line"></span><br><span class="line">num_list = range(1,101)</span><br><span class="line"></span><br><span class="line">print(get_sum(*num_list))</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5050</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p>字典也支持逆向收集，字典会以关键字参数的形式传入。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def get_student(stu_id,stu_name,**x):</span><br><span class="line">    print(&quot;学号:&quot;+str(stu_id))</span><br><span class="line">    print(&quot;姓名:&quot;+str(stu_name))</span><br><span class="line">    print(&quot;其他:&quot;+str(x))</span><br><span class="line"></span><br><span class="line">stu_info = &#123;&quot;stu_id&quot;:0,&quot;stu_name&quot;:&quot;张三&quot;,&quot;stu_age&quot;:18,&quot;stu_address&quot;:&quot;广州市&quot;&#125;</span><br><span class="line">get_student(**stu_info)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">学号:0</span><br><span class="line">姓名:张三</span><br><span class="line">其他:&#123;&apos;stu_age&apos;: 18, &apos;stu_address&apos;: &apos;广州市&apos;&#125;</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h1 id="Python-None-空值-及用法"><a href="#Python-None-空值-及用法" class="headerlink" title="Python None(空值)及用法"></a>Python None(空值)及用法</h1><p>Python中有一个特殊的常量<code>None</code>，其表示为空值，它不等于空列表，也不等于空字符串。</p><p><code>None</code> 具有自己的数据类型，通过<code>type()</code> 可以查看它的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;NoneType&apos;&gt;</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p><code>None</code> 为<code>NoneType</code> 数据类型的唯一值，不能创建其他NoneType类型的变量，但是可以为任何变量赋值为<code>None</code> 。</p><p><code>None</code> 常用场景是:<strong>assert断言，判断，以及函数无返回值。</strong> </p><h1 id="Python-return函数返回值详解"><a href="#Python-return函数返回值详解" class="headerlink" title="Python return函数返回值详解"></a>Python return函数返回值详解</h1><p>语法格式:</p><p><code>return [返回值]</code> </p><p>return 语句是用于给函数的调用处返回一个值。</p><p><strong>return 语句可以在同一函数中出现多次，但只要有一个得到执行，就会结束函数的执行。</strong> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def sum(x,y):</span><br><span class="line">    return x+y</span><br><span class="line"></span><br><span class="line">print(sum(10,20))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">30</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p><strong>return 的返回值可以为任意类型。</strong> </p><h1 id="Python函数返回多个值的方法"><a href="#Python函数返回多个值的方法" class="headerlink" title="Python函数返回多个值的方法"></a>Python函数返回多个值的方法</h1><p>Python允许函数同时返回多个值，它会将多个返回值封装成元组。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def multi_return():</span><br><span class="line">    return 10,20,30,40</span><br><span class="line"># 序列解包</span><br><span class="line">a,b,c,d = multi_return()</span><br><span class="line"># 序列解包</span><br><span class="line">test_list = multi_return()</span><br><span class="line">print(a,b,c,d)</span><br><span class="line">print(test_list)</span><br><span class="line">print(multi_return())</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10 20 30 40</span><br><span class="line">(10, 20, 30, 40)</span><br><span class="line">(10, 20, 30, 40)</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h1 id="Python-partial偏函数及用法"><a href="#Python-partial偏函数及用法" class="headerlink" title="Python partial偏函数及用法"></a>Python partial偏函数及用法</h1><p><a href="http://c.biancheng.net/view/5674.html" target="_blank" rel="noopener">见原文</a> </p><h1 id="Python函数递归"><a href="#Python函数递归" class="headerlink" title="Python函数递归"></a>Python函数递归</h1><p>当一个函数体内调用自身，就被称为<code>函数递归</code> 。</p><p>我们可以使用函数递归来模式循环，但这种循环不需要使用循环控制。</p><p>下面我们做一个数学题: <code>f(0)=1,f(1)=4,f(n+2)=2*f(n+1)+f(n)</code>，其中n是大于0的整数，求f(10)的值。我们将会使用循环和递归两种不同的方式来求当f(10)的值。</p><p>递归例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fn(n):</span><br><span class="line">    if n==0:</span><br><span class="line">        return 1</span><br><span class="line">    elif n==1:</span><br><span class="line">        return 4</span><br><span class="line">    else :</span><br><span class="line">        return 2 * fn(n-1)+fn(n-2)</span><br><span class="line"></span><br><span class="line">print(fn(10))</span><br></pre></td></tr></table></figure><p>可以看到，我们在函数体内调用了自身，这样当我们执行到调用自身时，那么这就是递归，而对于来<code>fn(10)</code>说，也等于式子<code>2*fn(9)+fn(8)</code> ，而其中<code>fn(9)</code> 又等于<code>2*fn(8)+fn(7)</code> ，以此类推，最终当计算到<code>fn(2)</code> 等于<code>2*fn(1)+fn(0)</code> 时，那么就会开始返回，这个递归也就具有了结束的时候，最终得到fn(10)的值。</p><p><strong>注意:递归类似于循环，必须在某个时刻函数的返回值是确定的，也就是不再调用自身，否则递归将会变成无穷递归，也就是死循环。</strong> </p><h1 id="Python变量作用于-全局变量和局部变量"><a href="#Python变量作用于-全局变量和局部变量" class="headerlink" title="Python变量作用于(全局变量和局部变量)"></a>Python变量作用于(全局变量和局部变量)</h1><p>变量有作用的范围，这个范围被称为<code>作用域</code>。<br><strong></strong>作用域是值，代码能够访问该变量的区域，如果超出该区域将不可访问。**</p><p>变量的范围分为两种<code>局部变量</code> 和<code>全局变量</code> 。</p><h2 id="Python局部变量"><a href="#Python局部变量" class="headerlink" title="Python局部变量"></a>Python局部变量</h2><p><strong>局部变量是指在函数内部定义并使用的变量，它只在函数内部有效</strong> 。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def text():</span><br><span class="line">    demo = &quot;HelloWorld&quot;</span><br><span class="line">    print(demo)</span><br><span class="line">text()</span><br><span class="line"></span><br><span class="line"># 获取局部变量demo</span><br><span class="line">print(demo)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    print(demo)</span><br><span class="line">NameError: name &apos;demo&apos; is not defined</span><br><span class="line"></span><br><span class="line">[Process exited 1]</span><br></pre></td></tr></table></figure><p>可以看到程序报错了，那是因为后面的print(demo)语句访问了在当前作用于不存在的变量，所以就会报错。</p><p>局部变量:每个函数执行时，系统都会为该函数分配一块<code>临时内存空间</code> ，所有局部变量都被保存在这块空间内。而当函数执行完后，系统将会将这块内存空间释放，从而局部变量也就失效了，因此当我们再次访问以为存在的局部变量时，解释器就会抛出错误NameError，因为根本不存在。</p><h2 id="Python全局变量"><a href="#Python全局变量" class="headerlink" title="Python全局变量"></a>Python全局变量</h2><p>全局变量与局部变量相反，全局变量是指<strong>能够作用于函数内外的变量，也就是说全局变量可以在任何地方使用。</strong> </p><p>定义全局变量有两种方法:</p><ol><li>在函数体外定义变量，一定是全局变量:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">demo = &quot;HelloWorld&quot;</span><br><span class="line"></span><br><span class="line">def text():</span><br><span class="line">    print(demo)</span><br><span class="line">text()</span><br><span class="line"></span><br><span class="line">print(demo)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld</span><br><span class="line">HelloWorld</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><ol start="2"><li>在函数体内定义全局变量。即使用<code>global</code> 关键字对变量进行修饰后，该变量就会变成为全局变量。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def text():</span><br><span class="line">    global demo</span><br><span class="line">    demo = &quot;HelloWorld&quot;</span><br><span class="line">    print(demo)</span><br><span class="line">text()</span><br><span class="line"></span><br><span class="line">print(demo)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld</span><br><span class="line">HelloWorld</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p><strong>注意:在使用global修饰变量时不可以直接给变量赋值。</strong> </p><h2 id="获取指定作用于范围中的变量"><a href="#获取指定作用于范围中的变量" class="headerlink" title="获取指定作用于范围中的变量"></a>获取指定作用于范围中的变量</h2><p>Python提供了三个函数用于访问指定作用于中的变量。</p><p>我们可以把变量与值理解为一个个字典，把key理解为变量名或变量的内存地址，把值理解为value。</p><p>而下面这三个方法就可以访问某个作用于下的所有字典。</p><ul><li><p>globals() 该函数返回全局范围内所有变量组成的变量字典。</p></li><li><p>locals() 该函数返回当前作用域范围下所有变量组成的变量字典。</p></li><li><p>vars(object) 获取object所在作用域范围下所有变量组成的变量字典，若不给参数，则与<code>locals()</code> 无区别。</p></li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def global_test():</span><br><span class="line">  global name</span><br><span class="line">  global name2</span><br><span class="line">  global name3</span><br><span class="line">  name = &quot;Evan&quot;</span><br><span class="line">  name2 = &quot;Chen&quot;</span><br><span class="line">  name3 = &quot;Li&quot;</span><br><span class="line"></span><br><span class="line">global_test()</span><br><span class="line"></span><br><span class="line">print(&quot;全局作用于下所有变量字典:&quot;,globals())</span><br><span class="line">print(&quot;指定访问全局作用域下key为name2的变量字典:&quot;,globals()[&apos;name2&apos;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def local_test():</span><br><span class="line">    age=age1=age2=age3= 20</span><br><span class="line">    print(&quot;age:&quot;,age)</span><br><span class="line">    print(&quot;age作用域下所有变量字典:&quot;,locals())</span><br><span class="line">    print(&quot;指定访问当前作用于下key为age的变量字典:&quot;,locals()[&apos;age&apos;])</span><br><span class="line">local_test()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python系列第七章笔记，查看Python系列所有文章，请点击&lt;a href=&quot;http://c.biancheng.net/python/str_method/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;💿&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://evanmeek.github.io/categories/Python/"/>
    
    
      <category term="Python系列" scheme="https://evanmeek.github.io/tags/Python%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>[Python-06]Python流程控制</title>
    <link href="https://evanmeek.github.io/2019/09/28/Python-06-Python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://evanmeek.github.io/2019/09/28/Python-06-Python流程控制/</id>
    <published>2019-09-28T06:14:26.000Z</published>
    <updated>2020-01-22T04:44:27.745Z</updated>
    
    <content type="html"><![CDATA[<p>Python系列第六章笔记，查看Python系列所有文章，请点击<a href="http://c.biancheng.net/python/str_method/" target="_blank" rel="noopener">💿</a></p><a id="more"></a><p>Python中的流程结构也就是选择语句，选择语句又分为3种语法形式，分别是if、if else、if elif else。</p><p>if 语句语法格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if 表达式:</span><br><span class="line">  代码块</span><br></pre></td></tr></table></figure><p>if else 语句语法格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 表达式:</span><br><span class="line">  代码块 1</span><br><span class="line">else:</span><br><span class="line">  代码块 2</span><br></pre></td></tr></table></figure><p>if elif else 语句语法格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if 表达式1:</span><br><span class="line">  代码块 1</span><br><span class="line">elif 表达式2:</span><br><span class="line">  代码块 2</span><br><span class="line">elif 表达式3:</span><br><span class="line">  代码块 3</span><br><span class="line">...</span><br><span class="line">else:</span><br><span class="line">  代码块 n</span><br></pre></td></tr></table></figure><p>以上三种选择结构的语法形式差别不大，它们有个共性，就是<strong>当表达式的值为True时会执行代码块内的代码</strong> 。</p><p>选择语句的表达式相当于条件，当表达式的条件满足后，就会执行代码块内的代码啦。</p><p><strong>注意:Python的代码块是通过缩进标记的，具有相同缩进的多行代码属于同一个代码块</strong> .</p><p><strong>if表达式真假值得判断方法</strong> </p><p>表达式可以是任意类型，不过下面的几种类型将会被Python解释器当做False处理:</p><p><code>Flase、None、0、&quot;&quot;、()、[]、{}</code> </p><h1 id="Python-if-else语句用法范例-注意事项"><a href="#Python-if-else语句用法范例-注意事项" class="headerlink" title="Python if else语句用法范例(注意事项_)"></a>Python if else语句用法范例(注意事项_)</h1><p><strong>1)代码块不要忘记缩进</strong> </p><p>每一个缩进就代表了一个代码块，如果没有没有缩进程序可能会出现各种问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s_age = input(&quot;请输入您的年龄:&quot;)</span><br><span class="line">age = int(s_age)</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">print(&quot;你成年了.&quot;)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File &quot;test.py&quot;, line 4</span><br><span class="line">  print(&quot;你成年了.&quot;)</span><br><span class="line">      ^</span><br><span class="line">IndentationError: expected an indented block</span><br></pre></td></tr></table></figure><p>有时没有缩进不代表程序没有错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s_age = input(&quot;请输入您的年龄:&quot;)</span><br><span class="line">age = int(s_age)</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print(&quot;你成年了.&quot;)</span><br><span class="line">print(&quot;成年了，就要修身养性.&quot;)</span><br><span class="line">print(&quot;你未成年.&quot;)</span><br></pre></td></tr></table></figure><p>运行过程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入您的年龄:10</span><br><span class="line">成年了，就要修身养性.</span><br><span class="line">你未成年.</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p>虽然程序没有报错，但是确是不符合逻辑的，应该是当输入的年龄大于等于18岁才输出成年了，就要修身养性，但是由于没有将其缩进，所以造成了代码的运行结果不如人意。</p><p><strong>2)语句不要随意缩进</strong> </p><p>我们必须保证同一个代码块内的代码必须保持相同的缩进，如果多一个缩进或少一个缩进都会出现不可预料的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 10</span><br><span class="line">if a &gt; 9:</span><br><span class="line">    print(&quot;a &gt; 9&quot;)</span><br><span class="line">        print(&quot;====&quot;)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  File &quot;test.py&quot;, line 1</span><br><span class="line">    int a = 10</span><br><span class="line">        ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>Python解释器抛出了一个SyntaxError错误</p><p><strong>3)if表达式不要遗忘冒号</strong> </p><p>Python解释器将冒号表示为代码块的开始，如果遗忘冒号也会引发一些错误，因为Python解释器无法识别代码块的开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 10 &gt; 9</span><br><span class="line">    print(&quot;9 &gt; 10&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;10 &lt; 9&quot;)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  File &quot;test.py&quot;, line 1</span><br><span class="line">    if 10 &gt; 9</span><br><span class="line">            ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"></span><br><span class="line">[Process exited 1]</span><br></pre></td></tr></table></figure><p>以冒号作为代码块的开始在其他语句结构也是如此，例如循环、类等。</p><h1 id="Python-if语句嵌套"><a href="#Python-if语句嵌套" class="headerlink" title="Python if语句嵌套"></a>Python if语句嵌套</h1><p>此笔记不讨论此内容，如需了解，请点击此处<a href="https://evanmeek.github.io/2019/09/23/Python-05-Python字符串常用方法详解/">查看原文</a> </p><h1 id="Python-pass语句及其作用"><a href="#Python-pass语句及其作用" class="headerlink" title="Python pass语句及其作用"></a>Python pass语句及其作用</h1><p>如果你想要一个代码块内什么都不做，但是没有这个代码块语法又不通过，你可以使用<code>pass</code> ，其是Python中的空语句，它什么也不做，唯一的功能就是占位了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if 10 &gt; 9:</span><br><span class="line">    print(&quot;xxx&quot;)</span><br><span class="line">else:</span><br><span class="line">    pass</span><br><span class="line">print(&quot;xxxx&quot;)</span><br></pre></td></tr></table></figure><h1 id="Python-assert断言函数及用法"><a href="#Python-assert断言函数及用法" class="headerlink" title="Python assert断言函数及用法"></a>Python assert断言函数及用法</h1><p><code>assert断言函数</code> 与if分支类似，不过它的特点是:<strong>当它的表达式条件为False时将会抛出异常，程序崩溃</strong> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = int(input(&quot;请输入大于10且小于100的数字:&quot;))</span><br><span class="line">assert 10 &lt; num &lt; 100</span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure><p>当我们输入非大于10且小于100的数字将会抛出异常:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入大于10且小于100的数字:1000</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 2, in &lt;module&gt;</span><br><span class="line">    assert 10 &lt; num &lt; 100</span><br><span class="line">AssertionError</span><br><span class="line"></span><br><span class="line">[Process exited 1]</span><br></pre></td></tr></table></figure><h1 id="Python-如何合理使用assert"><a href="#Python-如何合理使用assert" class="headerlink" title="Python 如何合理使用assert"></a>Python 如何合理使用assert</h1><p>本小节通过一些实际应用的例子，演示assert在Python中的用法。</p><p>某商场促销活动，对商进行打折销售，现在需要做到如果折后价大于0或小于原价，那么输出折后价，否则报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 原价</span><br><span class="line">price = float(input(&quot;请输入原价:&quot;))</span><br><span class="line"># 折扣力度</span><br><span class="line">discount = float(input(&quot;请输入打几折:&quot;))</span><br><span class="line"># 折后价</span><br><span class="line">update_price = price * (discount * 0.1)</span><br><span class="line">assert 0 &lt; update_price &lt; price</span><br><span class="line">print(&quot;折后价为:&#123;:.2f&#125;¥&quot;.format(update_price))</span><br></pre></td></tr></table></figure><p>正常结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入原价:100</span><br><span class="line">请输入打几折:8</span><br><span class="line">折后价为:80.00¥</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p>错误结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">请输入原价:100</span><br><span class="line">请输入打几折:18</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    assert 0 &lt; update_price &lt; price</span><br><span class="line">AssertionError</span><br><span class="line"></span><br><span class="line">[Process exited 1]</span><br></pre></td></tr></table></figure><p>在实际工作中，assert可以提前预防一些问题。</p><h1 id="Python-while循环语句详解"><a href="#Python-while循环语句详解" class="headerlink" title="Python while循环语句详解"></a>Python while循环语句详解</h1><p>本笔记不讨论<code>while</code> 循环语句的使用，想要了解的同学，可以点击<a href="http://c.biancheng.net/view/4427.html" target="_blank" rel="noopener">查看原文</a> </p><h1 id="Python-for循环及用法详解"><a href="#Python-for循环及用法详解" class="headerlink" title="Python for循环及用法详解"></a>Python for循环及用法详解</h1><p>本笔记不讨论<code>for</code> 循环语句的使用，想要了解的同学，可以点击<a href="http://c.biancheng.net/view/2225.html" target="_blank" rel="noopener">查看原文</a> </p><h1 id="Python循环结构中else用法-入门必读"><a href="#Python循环结构中else用法-入门必读" class="headerlink" title="Python循环结构中else用法(入门必读)"></a>Python循环结构中else用法(入门必读)</h1><p>Python中，循环语句后可以跟着一个else语句块。其作用是，当循环条件为Fale时，会直接执行紧跟着循环语句块后的else语句块内的代码。 </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count_i = 0</span><br><span class="line">while count_i &lt; 5:</span><br><span class="line">    print(&quot;count_i小于5:&quot;,count_i)</span><br><span class="line">    count_i+=1</span><br><span class="line">else:</span><br><span class="line">    print(&quot;count_i大于或等于5:&quot;,count_i)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count_i小于5: 0</span><br><span class="line">count_i小于5: 1</span><br><span class="line">count_i小于5: 2</span><br><span class="line">count_i小于5: 3</span><br><span class="line">count_i小于5: 4</span><br><span class="line">count_i大于或等于5: 5</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p>读者可能会想，这样做其实也没什么，就算没有else程序也照样会执行else内的代码。</p><p>其实这种语法是Python中一个为了让代码更加具有可读性、美观而有的一个语法。</p><p>for循环也是可以紧跟else的。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1,6):</span><br><span class="line">    print(i)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;输出完毕&quot;)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">输出完毕</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h1 id="Python-for和while-循环嵌套及用法"><a href="#Python-for和while-循环嵌套及用法" class="headerlink" title="Python(for和while)循环嵌套及用法"></a>Python(for和while)循环嵌套及用法</h1><p>如果将一个循环语句放入一个循环体内，就会形成循环嵌套。</p><p>当程序遇到循环嵌套时，如果外层循环的循环条件允许，则会执行外层循环的循环体，而内层循环将会被外层循环的循环体来执行(只是内层循环需要反复执行自己的循环体而已)。只有当内层循环执行结束且外层循环的循环体也执行结束时，才会再次通过判断外层循环的条件，决定是否再次开始执行外层循环的循环体。</p><p>居上所述，假设外层循环的循环次数为n次，那么内层循环的循环次数为m次，那么可得出内层循环的循环体实际上需要执行<code>n x m</code> 次。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in range(0,3):</span><br><span class="line">    j = 0</span><br><span class="line">    while j &lt; 3:</span><br><span class="line">        print(&quot;i:&#123;&#125;\tj:&#123;&#125;&quot;.format(i,j))</span><br><span class="line">        j += 1</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i:0     j:0</span><br><span class="line">i:0     j:1</span><br><span class="line">i:0     j:2</span><br><span class="line">i:1     j:0</span><br><span class="line">i:1     j:1</span><br><span class="line">i:1     j:2</span><br><span class="line">i:2     j:0</span><br><span class="line">i:2     j:1</span><br><span class="line">i:2     j:2</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p>i 为外层循环的数，j为内层循环的数，可以看到每次内层循环结束后外层循环的i才会发生改变，当时每次外层循环结束后，再次进入循环体后，将会重置内层循环j的值。</p><p>嵌套循环可以无限嵌套，但开发者最好不要超过三层循环，不然逻辑很容易混乱。</p><h1 id="Python嵌套循环实现冒泡排序"><a href="#Python嵌套循环实现冒泡排序" class="headerlink" title="Python嵌套循环实现冒泡排序"></a>Python嵌套循环实现冒泡排序</h1><p>冒泡排序算法的实现思想:</p><ul><li><p>比较相邻元素大小，若前一个比后一个大则交换位置。</p></li><li><p>从第一对相邻元素到结尾的最后一对相邻元素，对每一对相邻元素做上一步骤的比较工作，并将最大的元素放在后面。</p></li><li><p>将循环缩短，除去最后一个数，再重复第二步骤操作。</p></li><li><p>持续做步骤三操作，将每次循环缩短一位。</p></li></ul><p>实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test_list = [10,23,4522,55,13,5123,5,1321235.33,42.123]</span><br><span class="line"></span><br><span class="line">for i in range(len(test_list)-1):</span><br><span class="line">    # 每次得到最大值后循环缩短，因为最大值已经在最后</span><br><span class="line">    for j in range(len(test_list)-i-1):</span><br><span class="line">        # 如果相邻元素的第一个元素比第二元素大则:</span><br><span class="line">        if(test_list[j]&gt;test_list[j+1]):</span><br><span class="line">            test_list[j],test_list[j+1]=test_list[j+1],test_list[j]</span><br><span class="line">print(&quot;排序后:&quot;,test_list)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">排序后: [5, 10, 13, 23, 42.123, 55, 4522, 5123, 1321235.33]</span><br></pre></td></tr></table></figure><h1 id="Pyton-break用法详解"><a href="#Pyton-break用法详解" class="headerlink" title="Pyton break用法详解"></a>Pyton break用法详解</h1><p>在我们使用循环时，当条件满足那么循环体内的代码将会一路执行，直到循环体结束为止，如果我们想在执行循环体时直接终止循环或跳出本次循环，则可以使用<code>coontinue</code>或<code>break</code> 语句。</p><p><strong>break用于完全结束一个循环，杀死循环。</strong> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">for i in range(0,100000):</span><br><span class="line">    print(&quot;i的值为:&quot;,i)</span><br><span class="line">    sum += i</span><br><span class="line">    if sum == 5050:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">i的值为: 0</span><br><span class="line">i的值为: 1</span><br><span class="line">i的值为: 2</span><br><span class="line">i的值为: 3</span><br><span class="line">i的值为: 4</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">i的值为: 94</span><br><span class="line">i的值为: 95</span><br><span class="line">i的值为: 96</span><br><span class="line">i的值为: 97</span><br><span class="line">i的值为: 98</span><br><span class="line">i的值为: 99</span><br><span class="line">i的值为: 100</span><br></pre></td></tr></table></figure><p>可以看到，当sum值为5050时，循环将会被杀死，不再执行。</p><p>如果循环体外带上了else块，那么如果循环体内执行了break语句，则else语句块内的代码不会被执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1,4):</span><br><span class="line">    print(i)</span><br><span class="line">    if i &gt; 2:</span><br><span class="line">        break</span><br><span class="line">else:</span><br><span class="line">    print(&quot;else&quot;)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p>可以看到，当for循环体内执行了break语句后，else内的代码也不会执行。</p><p><strong>break语句只能结束当前执行的循环，而不能结束被嵌套循环的外层循环。</strong></p><h1 id="Python-continue用法"><a href="#Python-continue用法" class="headerlink" title="Python continue用法"></a>Python continue用法</h1><p>continue与break类似，但不同点在于continue只能跳出本次循环，并不能终止循环。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1,5):</span><br><span class="line">    if i == 2:</span><br><span class="line">        continue</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p>可以看到，当循环内部执行continue之后，下面的代码将不会被执行。</p><h1 id="如何避免Python出现死循环"><a href="#如何避免Python出现死循环" class="headerlink" title="如何避免Python出现死循环"></a>如何避免Python出现死循环</h1><p>为了避免Python程序出现死循环，所以<strong>必须确保循环结构中至少有能让循环条件为False或让break语句得以执行的语句。</strong> </p><h1 id="Python推导式详解"><a href="#Python推导式详解" class="headerlink" title="Python推导式详解"></a>Python推导式详解</h1><p>Python推导式，是Python独有的一种特性。使用推导式可以快速生成列表、元素、字典以及集合类型的数据。</p><p>列表推导式利用range区间、元组、列表、字典和集合等数据类型、快速生成一个满足指定需求的列表。</p><p>语法格式:</p><p><code>[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]]</code> </p><p><strong>if条件表达式为非必须的。</strong></p><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>例子:</p><p>求0-10的平方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_list = [x * x for x in range(11)]</span><br><span class="line">print(test_list)</span><br></pre></td></tr></table></figure><p>输出结果:<code>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></p><p>例子2:</p><p>求0-10的平方，并且满足可以整除2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_list = [x * x for x in range(11) if x % 2 == 0]</span><br><span class="line">print(test_list)</span><br></pre></td></tr></table></figure><p>输出结果:</p><p><code>[0, 4, 16, 36, 64, 100]</code> </p><p>上面的列表推导式都只有一个循环，但实际上它可以使用多个循环。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_list = [(x,y)for x in range(5) for y in range(4)]</span><br><span class="line">print(test_list)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1)</span><br><span class="line">, (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3), (4, 0), (4, 1), (4, 2), (4, 3</span><br><span class="line">)]</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p>其实Python的列表推导式可以使用循环语句重写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_list2 = []</span><br><span class="line">for x in range(5):</span><br><span class="line">    for y in range(4):</span><br><span class="line">        test_list2.append((x,y))</span><br><span class="line">print(test_list2)</span><br></pre></td></tr></table></figure><p>输出结果同上</p><p>当然，也支持多层循环嵌套的推导式。</p><h2 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h2><p>元组推导式同列表推导式一样，可以使用range区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p><p>语法格式:</p><p><code>(表达式 for 迭代变量 in 可迭代对象 [if条件表达式])</code> </p><p><strong>if条件表达式为可选</strong> </p><p>首先将元组推导式与列表推导式做一个对比。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_list = [x for x in range(10)]</span><br><span class="line">print(test_list)</span><br><span class="line">test_tuple = (x for x in range(10))</span><br><span class="line">print(test_tuple)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x106f3d450&gt;</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p>可以看到，除了元组推导式是使用<code>()</code> 圆括号而列表推导式是使用<code>[]</code> 方括号之外，还有就是元组推导式生成的结果并不是一个元组，而是一个<code>生成器对象</code> 。</p><p>我们可以通过<code>tuple()</code> 函数将生成器对象转换为元组或使用循环遍历生成器对象，获取各元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x =  (x for x in range(10))</span><br><span class="line">for ele in x:</span><br><span class="line">\    print(ele,end=&quot; &quot;)</span><br><span class="line">print(tuple(x))</span><br></pre></td></tr></table></figure><p>输出结果:</p><p><code>0 1 2 3 4 5 6 7 8 9 ()</code> </p><p><strong>注意:当我们遍历了生成器对象后，原生成器对象将不复存在，这就是为什么我们遍历了生成器对象后再将原生成器对象转换却得到空元组的原因</strong> </p><p>我们还可以使用<code>__next__()</code> 方法遍历，但很不方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x =  (x for x in range(10))</span><br><span class="line">print(x.__next__())</span><br><span class="line">print(x.__next__())</span><br><span class="line">print(x.__next__())</span><br><span class="line">print(x.__next__())</span><br><span class="line">print(x.__next__())</span><br><span class="line">print(x.__next__())</span><br><span class="line">print(x.__next__())</span><br><span class="line">print(x.__next__())</span><br><span class="line">print(x.__next__())</span><br><span class="line">print(x.__next__())</span><br><span class="line">print(tuple(x))</span><br><span class="line">print(x.__next__())</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 13, in &lt;module&gt;</span><br><span class="line">    print(x.__next__())</span><br><span class="line">StopIteration</span><br><span class="line"></span><br><span class="line">[Process exited 1]</span><br></pre></td></tr></table></figure><p>可以看到被遍历后的生成器将会被清空，并且需要注意的是<strong><strong>next</strong>方法需要不能越界</strong> </p><h2 id="Python-字典推导式"><a href="#Python-字典推导式" class="headerlink" title="Python 字典推导式"></a>Python 字典推导式</h2><p>同前两个推导式一样，都可以接住多种数据类型生成符合需求的字典。</p><p>语法格式:</p><p><code>{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}</code> </p><p>例子:</p><p>将列表内元素作为键，其元素长度为值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_list = [&apos;Hello&apos;,&quot;World&quot;]</span><br><span class="line">test_map = &#123;key:len(key) for key in test_list&#125;</span><br><span class="line">print(test_map)</span><br></pre></td></tr></table></figure><p>输出结果:</p><p><code>{&#39;Hello&#39;: 5, &#39;World&#39;: 5}</code> </p><p>例子2:</p><p>调换键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_list = [&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;]</span><br><span class="line">test_dict = dict.fromkeys(test_list,100)</span><br><span class="line">print(test_dict)</span><br><span class="line">test_dict2 = &#123;v:x for x,v in test_dict.items()&#125;</span><br><span class="line">print(test_dict2)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;语文&apos;: 100, &apos;数学&apos;: 100, &apos;英语&apos;: 100&#125;</span><br><span class="line">&#123;100: &apos;英语&apos;&#125;</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h2 id="Python集合推导式"><a href="#Python集合推导式" class="headerlink" title="Python集合推导式"></a>Python集合推导式</h2><p>同上，可以使用常用数据类型快速生成符合需求的集合。</p><p>语法格式:</p><p><code>{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}</code> </p><p><strong>注意：集合推导式的语法格式与字典推导式的语法格式相同，为了区分它们，同时看表达式的形式，如果是以键值对(key:value)的形式，那么就是字典，否则反之</strong> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newset = &#123;i**2 for i in range(3)&#125;</span><br><span class="line">print(newset)</span><br><span class="line">print(type(newset))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;0, 1, 4&#125;</span><br><span class="line">&lt;class &apos;set&apos;&gt;</span><br></pre></td></tr></table></figure><h1 id="Python-zip函数及用法"><a href="#Python-zip函数及用法" class="headerlink" title="Python zip函数及用法"></a>Python zip函数及用法</h1><p><code>zip()</code> 函数可以将多个列表转化一个zip对象(可迭代对象)。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = list(range(1,10))</span><br><span class="line">list2 = list(range(-10,0))</span><br><span class="line">print([x for x in zip(list1,list2)])</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[(1, -10), (2, -9), (3, -8), (4, -7), (5, -6), (6, -5), (7, -4), (8, -3), (9, -</span><br><span class="line">2)]</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h1 id="Python-reversed函数及用法"><a href="#Python-reversed函数及用法" class="headerlink" title="Python reversed函数及用法"></a>Python reversed函数及用法</h1><p>reversed()函数用于将各种序列进行<strong>逆序排序</strong> ，但不会影响序列本身。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;HelloWorld&quot;</span><br><span class="line">print([x for x in reversed(string)])</span><br></pre></td></tr></table></figure><p>输出结果:</p><p><code>[&#39;d&#39;, &#39;l&#39;, &#39;r&#39;, &#39;o&#39;, &#39;W&#39;, &#39;o&#39;, &#39;l&#39;, &#39;l&#39;, &#39;e&#39;, &#39;H&#39;]</code> </p><h1 id="Python-sorted函数及用法"><a href="#Python-sorted函数及用法" class="headerlink" title="Python sorted函数及用法"></a>Python sorted函数及用法</h1><p>sorted函数用于将各种序列进行排序。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;123456789&quot;</span><br><span class="line">re_string = [x for x in reversed(string)]</span><br><span class="line">print(re_string)</span><br><span class="line">sort_string = sorted(re_string)</span><br><span class="line">print(sort_string)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&apos;9&apos;, &apos;8&apos;, &apos;7&apos;, &apos;6&apos;, &apos;5&apos;, &apos;4&apos;, &apos;3&apos;, &apos;2&apos;, &apos;1&apos;]</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h1 id="Python项目实战之猜数字游戏"><a href="#Python项目实战之猜数字游戏" class="headerlink" title="Python项目实战之猜数字游戏"></a>Python项目实战之猜数字游戏</h1><p>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 随机数模块</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">print(&quot;&#123;0:=^20s&#125;&#123;1:s&#125;&#123;0:=^20s&#125;\n&quot;.format(&quot;==========&quot;,&quot;欢迎游玩猜数字游戏&quot;))</span><br><span class="line"></span><br><span class="line"># 随机数(1-20之间)</span><br><span class="line">randomNum = random.randint(1,20)</span><br><span class="line"></span><br><span class="line"># 只给用户5次机会</span><br><span class="line"></span><br><span class="line">for count in range(1,6):</span><br><span class="line">    print(&quot;\n算上这次，你还有&#123;:d&#125;次机会!\n&quot;.format(5-count))</span><br><span class="line">    num = int(input(&quot;请输入猜测的数(范围1~20):&quot;))</span><br><span class="line">    if num&gt;randomNum:</span><br><span class="line">        print(&quot;\n系统&gt;&gt; 大了点!!!&quot;)</span><br><span class="line">    elif num &lt; randomNum:</span><br><span class="line">        print(&quot;\n系统&gt;&gt; 小了点!!!&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;\n系统&gt;&gt; 恭喜你猜中了数字!!!&quot;)</span><br><span class="line">        break</span><br><span class="line">else:</span><br><span class="line">    print(&quot;\n系统&gt;&gt; 很遗憾，你没有猜到正确答案，答案为:&#123;:d&#125;&quot;.format(randomNum))</span><br></pre></td></tr></table></figure><p>猜中运行实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">====================欢迎游玩猜数字游戏====================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">算上这次，你还有4次机会!</span><br><span class="line"></span><br><span class="line">请输入猜测的数(范围1~20):10</span><br><span class="line"></span><br><span class="line">系统&gt;&gt; 小了点!!!</span><br><span class="line"></span><br><span class="line">算上这次，你还有3次机会!</span><br><span class="line"></span><br><span class="line">请输入猜测的数(范围1~20):15</span><br><span class="line"></span><br><span class="line">系统&gt;&gt; 大了点!!!</span><br><span class="line"></span><br><span class="line">算上这次，你还有2次机会!</span><br><span class="line"></span><br><span class="line">请输入猜测的数(范围1~20):14</span><br><span class="line"></span><br><span class="line">系统&gt;&gt; 大了点!!!</span><br><span class="line"></span><br><span class="line">算上这次，你还有1次机会!</span><br><span class="line"></span><br><span class="line">请输入猜测的数(范围1~20):13</span><br><span class="line"></span><br><span class="line">系统&gt;&gt; 恭喜你猜中了数字!!!</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p>猜错运行实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">====================欢迎游玩猜数字游戏====================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">算上这次，你还有4次机会!</span><br><span class="line"></span><br><span class="line">请输入猜测的数(范围1~20):1</span><br><span class="line"></span><br><span class="line">系统&gt;&gt; 小了点!!!</span><br><span class="line"></span><br><span class="line">算上这次，你还有3次机会!</span><br><span class="line"></span><br><span class="line">请输入猜测的数(范围1~20):1</span><br><span class="line"></span><br><span class="line">系统&gt;&gt; 小了点!!!</span><br><span class="line"></span><br><span class="line">算上这次，你还有2次机会!</span><br><span class="line"></span><br><span class="line">请输入猜测的数(范围1~20):1</span><br><span class="line"></span><br><span class="line">系统&gt;&gt; 小了点!!!</span><br><span class="line"></span><br><span class="line">算上这次，你还有1次机会!</span><br><span class="line"></span><br><span class="line">请输入猜测的数(范围1~20):1</span><br><span class="line"></span><br><span class="line">系统&gt;&gt; 小了点!!!</span><br><span class="line"></span><br><span class="line">算上这次，你还有0次机会!</span><br><span class="line"></span><br><span class="line">请输入猜测的数(范围1~20):1</span><br><span class="line"></span><br><span class="line">系统&gt;&gt; 小了点!!!</span><br><span class="line"></span><br><span class="line">系统&gt;&gt; 很遗憾，你没有猜到正确答案，答案为:3</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h1 id="Python项目实战-绕圈圈面试题"><a href="#Python项目实战-绕圈圈面试题" class="headerlink" title="Python项目实战: 绕圈圈面试题"></a>Python项目实战: 绕圈圈面试题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">SIZE = 7</span><br><span class="line"></span><br><span class="line">array = [[0] * SIZE]</span><br><span class="line"></span><br><span class="line"># 创建一个长度SIZE * SIZE的二维列表</span><br><span class="line">for i in range(SIZE - 1):</span><br><span class="line">    array += [[0] * SIZE]</span><br><span class="line"></span><br><span class="line"># 绕圈的方向(0:下 1:右 2：左 3:上)</span><br><span class="line">orient = 0</span><br><span class="line"></span><br><span class="line"># l 控制行索引 c控制列索引</span><br><span class="line">l = 0</span><br><span class="line">c = 0</span><br><span class="line"></span><br><span class="line">for i in range(1,SIZE * SIZE + 1):</span><br><span class="line">    array[l][c] = i</span><br><span class="line"></span><br><span class="line">    # 如果位于1号转弯线上</span><br><span class="line">    if l+c == SIZE - 1:</span><br><span class="line">        # l &gt; c，位于左下角</span><br><span class="line">        if l &gt; c:</span><br><span class="line">            orient = 1</span><br><span class="line">        else :</span><br><span class="line">            orient = 2</span><br><span class="line">    elif (c == l) and (c &gt;= SIZE / 2):</span><br><span class="line">        orient = 3</span><br><span class="line">    elif (l == c - 1) and (c &lt;= SIZE / 2):</span><br><span class="line">        orient = 0</span><br><span class="line">    if orient == 0:</span><br><span class="line">        l += 1</span><br><span class="line">    elif orient == 1:</span><br><span class="line">        c += 1</span><br><span class="line">    elif orient == 2:</span><br><span class="line">        c -= 1</span><br><span class="line">    elif orient == 3:</span><br><span class="line">        l -= 1</span><br><span class="line">for i in range(SIZE):</span><br><span class="line">    for j in range(SIZE):</span><br><span class="line">        print(&quot;%02d&quot; % array[i][j],end = &quot;&quot;)</span><br><span class="line">    print(&quot;&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python系列第六章笔记，查看Python系列所有文章，请点击&lt;a href=&quot;http://c.biancheng.net/python/str_method/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;💿&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://evanmeek.github.io/categories/Python/"/>
    
    
      <category term="Python系列" scheme="https://evanmeek.github.io/tags/Python%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>读《笨方法学习VimScript》所学</title>
    <link href="https://evanmeek.github.io/2019/09/27/%E8%AF%BB%E3%80%8A%E7%AC%A8%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0VimScript%E3%80%8B%E6%89%80%E5%AD%A6/"/>
    <id>https://evanmeek.github.io/2019/09/27/读《笨方法学习VimScript》所学/</id>
    <published>2019-09-27T10:26:16.000Z</published>
    <updated>2020-01-22T04:44:27.765Z</updated>
    
    <content type="html"><![CDATA[<p>身为一名每天使用Vim超过5小时的人来说，十分有必要学习一下VimScript，正好看到这本书作为入门很合适。这篇文章则是记录我读完此册子所学。</p><a id="more"></a><h1 id="为什么选择这本书"><a href="#为什么选择这本书" class="headerlink" title="为什么选择这本书?"></a>为什么选择这本书?</h1><p>&emsp;首先，我是一个重度Vim用户，目前记笔记，写代码等操作都是在Vim中实现的，为了让这个强大的古老神器能在我手上发挥巨大威力，所以我决定看书学习Vim。而这本书的前言说的就很好，第一句则是<code>程序猿们很喜欢实现自己的idea</code>，虽然我现在只是一名学生，但在我日常生活中经常想把自己使用Vim时的好点子加入我的<code>vimrc</code> 中。再就是这本书的<code>每章都只讲述一个主题，虽然内容简短但是信息丰富</code>，这样我很喜欢，没有过多啰嗦的地方，有些地方这本书更推荐看Vim自带的文档，这样也让读者有一个自我理解与学习的过程，就像书中所说<code>现实世界中事情的进展并不是遇到问题后可以很快速轻松的解决</code>。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>所提到的都是这本书是面向谁的，以及读完这本书能获得些什么，并且给了一些学习时的忠告，最后提醒了要多利用<code>:help</code>命令.</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>这本书主要讲VimScript所以，在学习VimScript之前，得了解Vim的基本使用，例如<code>buffer,window,normal mode,insert mode,text mode</code>。</p><p>最好是具有编程经验。</p><p>本书基于Vim-7.3版本撰写的，所以读者需要确保系统安装了&gt;=7.3版本的Vim。</p><h2 id="创建Vimrc文件"><a href="#创建Vimrc文件" class="headerlink" title="创建Vimrc文件"></a>创建Vimrc文件</h2><p>这一节没有提到<code>Vimrc</code> 是什么，我这里提一下，是<code>Vimrc</code>一个文件，文件内的可以写vim的命令，而写在<code>Vimrc</code> 中的命令都被称为Ex命令，Ex命令不是这一小节的讨论范围。</p><p>主要说到在Linux或Mac OS X中，这个文件位于<code>home</code>目录下，并且是以<code>.vimrc</code>命名的，而在Windows下则是位于<code>home</code>文件夹下，并以<code>_vimrc</code>命名。</p><p>以上三个系统，都可以在Vim中通过执行<code>:echo $MYVIMRC</code>得知此文件的位置等信息。</p><p><strong>注意:若你没有找到此文件，请自行创建</strong> </p><h1 id="打印信息"><a href="#打印信息" class="headerlink" title="打印信息"></a>打印信息</h1><p>主要提到Vim中打印命令和注释的使用与作用。</p><p>Vim中的打印命令有:<code>echo</code> 和<code>echom</code> ，其区别在于:</p><ul><li><p>echo 仅仅输出回显表达式结果。</p><blockquote><p>回显表达式</p></blockquote><p><code>echo {expr1}</code> 其中{expr1}就是回显表达式</p></li><li><p>echom 输出回显表达式结果，并且将其存储在<code>message-history</code> 内</p><blockquote><p>message-history</p></blockquote><p><code>message-history</code> 是消息历史，可以通过命令查看<code>:messages</code> </p></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>VimScript可以通过<code>&quot;</code> 字符添加注释，就像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot; 将&lt;space&gt;映射为za</span><br><span class="line">nnoremap &lt;space&gt; za</span><br></pre></td></tr></table></figure><h1 id="设置选项"><a href="#设置选项" class="headerlink" title="设置选项"></a>设置选项</h1><p>Vim中有两种选型: 布尔选项(<code>on</code> 或<code>off</code>)以及键值选项。</p><h2 id="布尔选项"><a href="#布尔选项" class="headerlink" title="布尔选项"></a>布尔选项</h2><p>类似于开关，例如想让Vim中显示行号，可以执行:<code>:set number</code>，这就代表开启，如果想要关闭，则可以使用:<code>:set nonumber</code> 代表关闭状态，如果不想纠结当前状态，只想切换可以执行:<code>set number!</code>，如果想知道当前状态的值，可以执行:<code>set number?</code>，这样可以看到选项的值。</p><h2 id="键值选项"><a href="#键值选项" class="headerlink" title="键值选项"></a>键值选项</h2><p>有些选项，比不是像布尔选项只有两种状态，它们可能会有一个不固定的值，例如改变行号宽度的选项<code>numberwidth</code> ，如果我们想查看<code>numberwidth</code> 的值，可以执行<code>set numberwidth?</code>。</p><h2 id="一次性设置多个选项"><a href="#一次性设置多个选项" class="headerlink" title="一次性设置多个选项"></a>一次性设置多个选项</h2><p>前面我们一直在使用<code>:set</code>命令设置单个选项的值，不过<code>:set</code>命令还允许一次设置多个选项的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set numberwidth=2</span><br><span class="line">:set nonumber</span><br></pre></td></tr></table></figure><p>可以写成:<code>set numberwidth=2 nonumber</code> </p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>‘number’的帮助文档:</strong> 在每行前显示行号。</p><p><strong>relativenumber的帮助文档:</strong> 在每行前显示相对于光标所在行的行号。布尔型选项</p><blockquote><p>建议开启这个选项，它可以让你在上下移动光标时不需要动脑子去算。</p></blockquote><p><strong>numberwidth的帮助文档:</strong> 键值选项，该选项可以设置行号的列数，Vim中默认为4，也就是说当行号超过9999则会自动扩容。</p><p><strong>wrap的帮助文档:</strong> 布尔选项，该选项的作用是自动换行，默认打开。</p><p><strong>shiftround的帮助文档:</strong> 布尔选项，表示没看太懂，文档内是说将缩进取整为<code>shiftwidth</code> 的倍数。这个是命令是应用于<code>&gt; 和 &lt;</code> 命令的</p><p><strong>matchtime的帮助文档:</strong> 键值型选项，默认值为5，作用是设置配对括号的时间。</p><h1 id="基本映射"><a href="#基本映射" class="headerlink" title="基本映射"></a>基本映射</h1><p>从这一章节开始，逐渐变得有趣起来。</p><p>映射是数学中一个有趣的概念，而在VimScript中，键盘的映射也是非常重要且能让Vim随你心意的一个重要概念，因为你可以通过键盘映射告诉Vim: <code>当我按下某组键位时，则执行某些命令</code>。</p><p>最简单的键盘映射是<code>map</code>命令，<code>map</code>命令还可以使用特殊字符，<strong><code>map</code>命令不可以映射注释</strong> </p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>映射按键<code>_</code>，让当前行上移一行。</p><p><code>:map _ ddkp</code> </p><h1 id="模式映射"><a href="#模式映射" class="headerlink" title="模式映射"></a>模式映射</h1><p>我们知道Vim中有很多种模式，常见的有:<code>normal,visual,insert</code> 而上一章节所学的<code>map</code> 命令只能应用在<code>normal</code> 模式下。</p><p>不过不用担心，VimScript提供了应用在不同模式下的映射，它们是:<code>nmap,vmap,imap</code> 分别对应了三种常见的模式。</p><p><strong>注意:在插入模式映射下，Vim只会按你所想去做，所以如果要执行normal模式下的命令，别忘了使用<code>&lt;Esc&gt;</code> 退出插入模式再使用.</strong> </p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><p>在insert模式下，可通过按<code>&lt;C-u&gt;</code> 将当前光标所在的单词转换成大写格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:imap &lt;C-u&gt; &lt;esc&gt;vgU</span><br></pre></td></tr></table></figure><p>在normal模式下，按<code>C-u</code>将当前光标的单词转换成大写格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:nmap &lt;C-u&gt; vwgU</span><br></pre></td></tr></table></figure><h1 id="精确映射"><a href="#精确映射" class="headerlink" title="精确映射"></a>精确映射</h1><p>书上说本章内容会比较难理解，其实很简单..</p><p>前面我们学了<code>map</code>以及三种模式对应的映射命令，但他们有一个问题，就是如果当前映射的键再次被映射了，那么当我们使用其快捷键时，就会执行原先映射的键，这就是递归。</p><p>想要避免递归映射，我们可以使用另一组映射命令，可以使得映射的键不会进行递归。</p><p>例如<code>nmap</code> 的非递归映射命令是:<code>nnoremap</code> 其中的<code>nore</code> 应该就是<code>not recursion</code>的意思，其他两种模式映射命令也是如此。</p><p><strong>注意:我们应当在任何时候都使用非递归映射，以免递归映射带来的不必要麻烦</strong> </p><h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><p><strong>unmap的帮助文档:</strong> unmap是一个系列命令，其作用是在映射命令作用的模式中删除映射，同系列的其他命令还有<code>nunmap vunmap xunmap sunmap ounmap iunmap lunmap cunmap</code> 等。</p><h1 id="Leaders"><a href="#Leaders" class="headerlink" title="Leaders"></a>Leaders</h1><p>Leaders是Vim中让用户自定义的特殊键位，其作用主要是作为映射键位的前缀键，这样可防止在映射过多快捷键后覆盖的问题。</p><p>想要设置leader键，执行命令:<code>:let mapleader = &quot;选择你想要的&quot;</code>，默认的Leader键为<code>\</code></p><h2 id="Local-Leader"><a href="#Local-Leader" class="headerlink" title="Local Leader"></a>Local Leader</h2><p>前面所提到的Leader更偏向于全局键位映射，如果我们需要对不同文件类型设置不同的快捷键，则可以使用<code>Local Leader</code> 。</p><p>想要设置<code>Local Leader</code> 的键位，可以执行:<code>:let maplocalleader = &quot;&lt;space&gt;&quot;</code> 你可以把<space>替换成你想要的。</space></p><p><strong>本章本小节只是粗略的提了下LocalLeader的作用，后面的章节将会更加详细的介绍。</strong></p><h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><p><strong>mapleader的帮助文档:</strong> 其实也没什么好说的，上面都写完了，这里说一点:<code>mapleader</code> 的值仅在定义映射时被使用，就算后面改变’mapleader’也不会影响已经定义过的映射。</p><p><strong>maplocalleader的帮助文档:</strong> 主要就说一两句忠告:在全局插件里应该使用<code>&lt;Leader&gt;</code> 而在一个根据文件类型有不同操作的插件里应该使用<code>&lt;LocalLeader&gt;</code> ，还有就是<code>mapleader</code> 和<code>maplocalleader</code> 的值是可以相同的。</p><h1 id="编辑你的Vimrc文件"><a href="#编辑你的Vimrc文件" class="headerlink" title="编辑你的Vimrc文件"></a>编辑你的Vimrc文件</h1><p>这一章算一个小技巧，书中是这么说的：当你在<code>疯狂编码时</code> 突然想加点什么到Vimrc中，但是你又必须立刻编辑vimrc以防忘记，并且又不想退出当前文件，以防打断思路，那么本小节将会实现这个小技巧。</p><h2 id="编辑映射"><a href="#编辑映射" class="headerlink" title="编辑映射"></a>编辑映射</h2><p>我们可以在新建一个分屏，然后那个分屏中编辑<code>vimrc</code>，通过几个简单的键位，即可实现。</p><p><code>:nnoremap &lt;Leader&gt;er :vsplit $MYVIMRC&lt;cr&gt;</code> </p><p>这个命令使用快捷键<code>Leader+e+r</code> 实现新建一个<code>纵向分屏</code> 并且在纵向分屏中打开<code>$MYVIM</code> ，注意最后的<code>&lt;cr&gt;</code> 代表回车，你们可以试下去掉会<code>&lt;cr&gt;</code>发生什么。</p><h2 id="重读映射配置"><a href="#重读映射配置" class="headerlink" title="重读映射配置"></a>重读映射配置</h2><p>当我们添加完即刻所想的idea后，我们还需要重载配置文件，但还是需要再次拼写那长长的命令，所以我们直接通过精确键盘映射完成重读映射，在多次使用后，重读一次配置文件的时间不超过<code>0.2秒</code> </p><p><code>:nnoremap &lt;Leader&gt;sr :source $MYVIMRC&lt;CR&gt;</code> </p><h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h2><p>说让我添加一些没意义的映射…那好吧，我想要快速执行外部命令，并将外部命令的输出插入到当前文本中。</p><p>我要执行的外部程序是:<code>figlet</code> ，这是一个可以将字符转化为字符画的一个小程序，那么我可以这样映射。</p><p><code>:nnoremap &lt;Leader&gt;fl :r !figlet</code> </p><p>这样当我按下<code>&lt;Leader&gt;+f+l</code> 这个键盘映射后将会自动帮我输入我映射的值，然后等到我输入一些内容，按下回车后就会将figlet的执行结果插入到当前文本中。</p><p><strong>myvimrc的帮助文档:</strong> 文档中说，<code>$MYVIMRC</code> 是一个环境变量，这个环境变量指向的是<code>vimrc</code> 文件，这个文件用于VIM启动时的初始化。并且这个环境变量如果没有被设置或使用VIMINIT则会从5个地方开始查找，分别是<code>1. 环境变量$VIMINIT 2.用户vimrc文件 3.环境变量$EXINIT 4.用户exrc文件 5. 默认的vimrc文件(位于$VIMRUNTIME/defaults.vim)</code> </p><h1 id="Abbreviations"><a href="#Abbreviations" class="headerlink" title="Abbreviations"></a>Abbreviations</h1><p><code>Abbreviations</code>是Vim中一个灵活且强大的特性，其主要用于<code>insert replace command</code> 模式</p><p>书里说了，只讲<code>insert</code> 模式下的<code>abbreviations</code>，简单的说<code>abbreviations</code> 就是一个缩写替换，可以自定义一些缩写，当你在<code>insert</code> 模式下键入这些缩写就会被替换成事先定义好的值。</p><p><code>insert</code> 模式的<code>abbreviations</code> 命令是:<code>iabbrev</code> 例如:<code>:ibbrev name8 EvanMeek</code> ，执行这条命令当我们在插入模式下键入<code>name8</code> 并按下空格，Vim的<code>abbreviations</code> 特性就会将其替换为我们定义好的<code>EvanMeek</code> 。</p><h2 id="Keyword-Characters"><a href="#Keyword-Characters" class="headerlink" title="Keyword Characters"></a>Keyword Characters</h2><p><code>Keyword Characters</code>是<code>abbreviations</code> 的一个概念，Vim中有一个<code>keyword范围列表</code> 想要查看这个返回列表可以执行命令:<code>:set iskeyword?</code> ，你将会看类似<code>iskeyword=@,48-57,_,192-255</code> 的结果，这里简单介绍一下，这是一个格式，这个格式包含了如下几种:</p><ul><li><p>48-57 其实是ASCII值在48-57之间的字符，也就是数字(0-9)</p></li><li><p>192-255 是ASCII值，代表了一些特殊的ASCII字符</p></li><li><p>@ 代表除了小写字母ASCII字母以外的字母</p></li><li><p><code>_</code> 以及下划线</p></li></ul><p>为什么说<code>Keyword Characters</code>是<code>Abbreviations</code> 的概念，因为: 当在插入模式下键入缩写后的后一个字符不包含在<code>iskeyword</code> 列表中则会将定义好的全拼替换掉缩写，例如我们敲<space>就不在<code>iskeyword</code> 列表中，所以可以替换。</space></p><p>下面举个<code>abbreviations</code> 特性的常用例子吧:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:iabbrev em7 email:the_lty_mail@foxmail.com</span><br></pre></td></tr></table></figure><p>重载配置文件后，当我们在插入模式下键入em7然后再键入一个非<code>iskeyword</code> 列表中的字符，将会替换为<code>email:the_lty_mail@foxmail.com</code>。</p><h2 id="为什么不用Mappings"><a href="#为什么不用Mappings" class="headerlink" title="为什么不用Mappings?"></a>为什么不用Mappings?</h2><p>其实书上的例子已经很好的解释这个问题了。</p><p>首先用mappings做一个替换:<code>:inoremap lol ILoveLOL</code>，然后你进入<code>insert</code> 模式，键入<code>你玩不玩lol?</code> ，此时<code>lol</code> 将会被替换为<code>ILoveLOL</code> ，让我们用<code>abbreviations</code> 特性再做相同的操作。</p><p>执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:iunmap lol</span><br><span class="line">:iabbrev lol ILoveLOL</span><br></pre></td></tr></table></figure><p>现在再试试，你就懂了。</p><h2 id="练习-6"><a href="#练习-6" class="headerlink" title="练习"></a>练习</h2><p>为我常用的字符串添加<code>abbreviations</code> 特性与配置中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:iabbrev info email:the_lty_mail@foxmail.com    name:EvanMeek    WebSize:https://evanmeek.github.io</span><br></pre></td></tr></table></figure><h1 id="更多的Mappings"><a href="#更多的Mappings" class="headerlink" title="更多的Mappings"></a>更多的Mappings</h1><p>前面用到了很多多字符的mappings但是我们一直没有提到mappings的连续性。</p><p>首先运行如下命令:<code>:nonoremap jk dd</code> </p><p>当我们处于 normal模式时，快速键入<code>jk</code>  Vim则会执行我们映射的 <code>dd</code> 命令，当前行被删除了。</p><p>现在再试试按<code>jk</code>，但是在按下<code>j</code> 后等待一会儿，再按下<code>k</code> ，我们会发现，Vim不会执行我们所映射的那个命令。这是因为，当我们设置的多字符<code>mappings</code>在键入时，如果没有快速连贯的输入，那么Vim就不会识别。</p><h2 id="一个更为复杂的Mapping"><a href="#一个更为复杂的Mapping" class="headerlink" title="一个更为复杂的Mapping"></a>一个更为复杂的Mapping</h2><p>书中是在normal模式下将单词用<code>&quot;&quot;</code>包住。</p><p>运行命令:<code>nonoremap &lt;LEADER&gt;&quot; viw&lt;ESC&gt;a&quot;&lt;ESC&gt;hbi&quot;&lt;ESC&gt;lel</code> </p><p>现在解释一下:</p><ul><li><p><code>viw</code> 高亮选中单词</p></li><li><p><code>&lt;ESC&gt;</code> 退出visual模式，此时光标会在单词的最后一个字符上</p></li><li><p><code>a</code> 移动光标至当前位置后并进入<code>insert</code> 模式</p></li><li><p><code>&quot;</code> 插入一个<code>&quot;</code> </p></li><li><p><code>&lt;ESC&gt;</code> 退出insert模式，进入normal模式</p></li><li><p><code>h</code> 光标左移</p></li><li><p><code>b</code> 移动光标至单词头部</p></li><li><p><code>i</code> 进入insert模式</p></li><li><p><code>&quot;</code> 键入一个<code>&quot;</code> </p></li><li><p><code>&lt;ESC&gt;</code> 返回到normal模式</p></li><li><p><code>l</code> 光标右移，置于单词头部</p></li><li><p><code>e</code> 移动光标至单词尾部</p></li><li><p><code>l</code> 光标右移，置于第一个添加的引号上</p></li></ul><p>需要注意的是:这里是使用<code>nonoremap</code> 映射的，而非<code>nmap</code> 映射，所以尽管映射的字符已经被映射，Vim也只会讲其中的字符按默认功能执行。</p><h2 id="练习-7"><a href="#练习-7" class="headerlink" title="练习"></a>练习</h2><p>创建一个mappings，使用单引号而不是双引号。</p><p><code>:nonoremap &lt;LEADER&gt;&#39; viw&lt;ESC&gt;a&#39;&lt;ESC&gt;hbi&#39;&lt;ESC&gt;lel</code> </p><h1 id="本地缓冲区的选项和映射"><a href="#本地缓冲区的选项和映射" class="headerlink" title="本地缓冲区的选项和映射"></a>本地缓冲区的选项和映射</h1><p>如题所示，本章会讲到本地缓冲区，我们将会对本地缓冲区与全局缓冲区做对比。</p><p>为了演示，请打开两个文件，例如<code>file1</code> 和<code>file2</code>，然后输入一些字符。</p><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>首先，我们打开 <code>file1</code> ，然后执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:nnoremap &lt;LEADER&gt;d dd</span><br><span class="line">:nnoremap &lt;BUFFER&gt; &lt;LEADER&gt;x dd</span><br></pre></td></tr></table></figure><p>现在我们再打开<code>file2</code> ，然后使用刚刚映射的快捷键，你会发现第一个映射的快捷键可以使用，但是第二个则不行，现在我们再打开<code>file1</code> ，却发现两个快捷键都可以被使用。</p><p>好了，现在解释一下这是为什么。首先，我们看到两个映射不同的地方除了映射键以外，第二个映射还多了个<code>&lt;buffer&gt;</code> ，这代表了我们当前映射的快捷键只有在当前<strong>缓冲区</strong> 起作用，而当我们切换到另外一个缓冲器，那么自然映射不起作用了。</p><h2 id="本地Leader"><a href="#本地Leader" class="headerlink" title="本地Leader"></a>本地Leader</h2><p>本地Leader的作用是: 更精确的定义映射。</p><p>有时我们在使用一些对特殊缓冲区起作用的插件时，为了防止与全局Leader映射起冲突，所以就需要使用本地Leader，也就是<code>&lt;localleader&gt;</code> 。</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>前面几个章节我们都是使用<code>set</code> 命令进行设置VIM的，但是为了让我们的设置更加精准，在不同特殊缓冲区具有不同的设置时，我们就应该使用本地设置<code>setlocal</code> 命令进行设置，下面来看几个例子:</p><p>仍然是操作<code>file1</code> 和<code>file2</code> ，首先，我们打开<code>file1</code> 键入命令:<code>:setlocl wrap</code> 然后在打开<code>file2</code> 键入命令:<code>:setlocal nowrap</code> ，然后为两个文件键入长长的一段字符。</p><p>你会发现<code>file1</code> 是具有自动折行的，而<code>file2</code> 却不具备。</p><p><strong>注意:不是所有命令都可以设置setlocl的，如果需要查看命令是否可以设置为<code>setlock</code> 那么可以通过命令执行:Help命令查看命令的帮助文档</strong> </p><h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>这一小节其实不需要做什么演示，一句话就可以概括:<code>本地缓冲区命令要比全局缓冲区优先级高，如果本地缓冲区命令与全局缓冲去起了冲突，那么Vim将会忽略全局缓冲区的命令</code> </p><h2 id="练习-8"><a href="#练习-8" class="headerlink" title="练习"></a>练习</h2><p>阅读<code>:help local-options</code> </p><blockquote><p>写完了两章，结果被Nvim的交换文件给重置了，心态崩了</p></blockquote><h1 id="自动命令"><a href="#自动命令" class="headerlink" title="自动命令"></a>自动命令</h1><p>自动命令与映射一样重要。</p><p>自动命令可以让Vim自动执行某些命令，这些命令会在某些事件触发时执行。</p><p>下面看一个例子:</p><p><code>:autocmd BufNewFile * :write</code> </p><p>输入这条命令，然后使用<code>:edit</code> 命令新建一个缓冲区，你会发现会缓冲区会被自动写入进文件了。</p><p>下面我们就来解释一下。</p><h2 id="自动命令结构"><a href="#自动命令结构" class="headerlink" title="自动命令结构"></a>自动命令结构</h2><p>先讲一下自动命令结构，你就可以很清晰的了解自动命令为什么能做到监听事件了。</p><p><code>:autocmd BufNewFile * :write</code> </p><ul><li><p>BufNewFile 代表要监听的“事件”</p></li><li><ul><li>代表事件过滤的“模式（pattern）”</li></ul></li><li><p>:write 代表要执行的命令。</p></li></ul><p>这条命令的实际上做的事是:</p><ol><li><p>当Vim监听到<code>BufNewFile</code> 这个事件后,</p></li><li><p>对所有类型的文件，因为过滤模式是<code>*</code> ,</p></li><li><p>执行<code>:write</code> 命令。</p></li></ol><p>另一个栗子:</p><p><code>:autocmd BufNewFile *.txt :write</code> </p><p>这个例子是将事件过滤模式改为了<code>*.txt</code> ，代表只有新建缓冲区的文件类型为<code>txt</code> 才会触发这个自动命令。</p><h2 id="多个事件"><a href="#多个事件" class="headerlink" title="多个事件"></a>多个事件</h2><p>一个自动命令可以绑定多个事件，多个事件之间由逗号分隔开。</p><p>例如:</p><p><code>:autocmd BufWritePre,BufRead *.html :normal gg=G</code> </p><p>这个自动命令将会在文件类型为<code>html</code> 的缓冲区写入文件时或者读入文件类型为<code>html</code> 类型的文件至缓冲区时进行文本缩进处理。</p><h2 id="FileType事件"><a href="#FileType事件" class="headerlink" title="FileType事件"></a>FileType事件</h2><p><code>FileType</code>可以让Vim在设置一个缓冲区的<code>filetype</code> 时触发。</p><p>见名知意，<code>filetype</code> 也就是文件类型的意思。</p><p>例如我们要对JavaScript与Python映射快速添加注释的快捷键，但由于两门编程语言的注释语法不同，所以我们就可以根据<code>FileType</code>  的值设置不同的文件，定义不同的映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:autocmd FileType javascript nnoremap &lt;buffer&gt; &lt;localleader&gt;c I//&lt;ESC&gt;</span><br><span class="line">:autocmd FileType python nnoremap &lt;buffer&gt; &lt;localleader&gt;c I#&lt;ESC&gt;</span><br></pre></td></tr></table></figure><h1 id="本地缓冲区缩写"><a href="#本地缓冲区缩写" class="headerlink" title="本地缓冲区缩写"></a>本地缓冲区缩写</h1><p>本章很简单，只是将缩写添加一个范围限制。</p><p>首先，我们执行命令:<code>:iabbrev &lt;buffer&gt; --- Hello</code> </p><p>再进入插入模式，键入<code>Hello --- World</code> </p><p>我们发现，<code>---</code> 被替换为了<code>Hello</code> ，这没什么新鲜的，但是当我们打开另一个缓冲区，将会发现这个缩写不起作用了，因为这个缩写是<code>local iabbrev</code> </p><h1 id="自动命令组"><a href="#自动命令组" class="headerlink" title="自动命令组"></a>自动命令组</h1><p>前面几章，我们学习了自动命令，但其实他在某些场景下仍然有些问题。</p><p>例如，先执行命令:<code>:autocmd BufWrite * :echom &quot;Writing buffer&quot;</code> </p><p>然后使用<code>:write</code> 命令将当前缓冲区写入文件，然后执行<code>:messages</code> 命令查看消息日志。你当然会看见<code>Writing buffer</code> 在消息列表中。</p><p>然后重复上面的操作，我们将会看到<code>Writing buffer</code> 在消息列表出现了两次，如果我们再执行上面的自动命令<code>:autocmd BufWrite * :echom &quot;Writing buffer&quot;</code> ，然后再重复刚刚的操作，你将会看到<code>Writing buffer</code> 出现了4次.</p><p>这样是有问题的，因为自动命令被重复设置了，因为Vim不知道你是想替换前面设置的自动命令。</p><h2 id="这会有什么问题"><a href="#这会有什么问题" class="headerlink" title="这会有什么问题?"></a>这会有什么问题?</h2><p>直接说吧，这样会影响Vim的启动速度，因为你的命令通常都是写在<code>~/.vimrc</code> 下，但是每次启动<code>Vim</code> 时，都会加载<code>vimrc</code> ，而这些重复的自动命令将会大大降低Vim的启动速度。</p><p>你可以执行下面的命令，模拟延迟情况。 </p><p><code>:autocmd BufWrite * :sleep 200m</code> </p><p>如果还不够，你可以多执行几次。</p><p><strong>键入:</strong> <code>:autocmd!</code> 以取消所有的自动命令。</p><h2 id="把自动命令放到组中-Grouping-Autocommands"><a href="#把自动命令放到组中-Grouping-Autocommands" class="headerlink" title="把自动命令放到组中(Grouping Autocommands)"></a>把自动命令放到组中(Grouping Autocommands)</h2><p>上面的问题，可以通过将自动命令放入一个组内解决。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">augroup testGroup</span><br><span class="line">  autocmd BUfWrite * :echom &quot;Write ONE&quot;</span><br><span class="line">  autocmd BUfWrite * :echom &quot;Write TWO&quot;</span><br><span class="line">augroup END</span><br></pre></td></tr></table></figure><p>中间的两行缩进可以省略。</p><p>现在试试将缓冲区写入文件，然后查看消息列表。然后再执行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">augroup testGroup</span><br><span class="line">  autocmd BUfWrite * :echom &quot;Write THREE&quot;</span><br><span class="line">augroup END</span><br></pre></td></tr></table></figure><p>现在再将缓冲区写入文件，然后查看消息列表，于是，操蛋的事就发生了。。。</p><h2 id="清楚自动命令组"><a href="#清楚自动命令组" class="headerlink" title="清楚自动命令组"></a>清楚自动命令组</h2><p>你以为定义相同的自动命令组将会自动替换，但其实不是。。。</p><p>为了解决这个问题，所以你最好这么做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:augroup testGroup</span><br><span class="line">:autocmd!</span><br><span class="line">:autocmd BUfWrite * :echom &quot;Write FOUR&quot;</span><br><span class="line">:augroup END</span><br></pre></td></tr></table></figure><p>请注意,autocmd!，这将会把当前组内的自动命令都先清空，然后再定义新的自动命令。</p><p>你现在可以试试还会不会有:<code>Write ONE TWO ...</code> 等信息</p><h1 id="Operator-Pending映射"><a href="#Operator-Pending映射" class="headerlink" title="Operator-Pending映射"></a>Operator-Pending映射</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;身为一名每天使用Vim超过5小时的人来说，十分有必要学习一下VimScript，正好看到这本书作为入门很合适。这篇文章则是记录我读完此册子所学。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Vim" scheme="https://evanmeek.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>功能强大-基于GPU加速-Kitty终端</title>
    <link href="https://evanmeek.github.io/2019/09/26/%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7-%E5%9F%BA%E4%BA%8EGPU%E5%8A%A0%E9%80%9F-Kitty%E7%BB%88%E7%AB%AF/"/>
    <id>https://evanmeek.github.io/2019/09/26/功能强大-基于GPU加速-Kitty终端/</id>
    <published>2019-09-26T15:49:08.000Z</published>
    <updated>2020-01-22T04:44:27.751Z</updated>
    
    <content type="html"><![CDATA[<p>由于实在忍受不了iTerm2的卡顿，所以我尝试使用一款速度更快的终端——Kitty</p><a id="more"></a><h1 id="Kitt终端简介"><a href="#Kitt终端简介" class="headerlink" title="Kitt终端简介"></a>Kitt终端简介</h1><p>从官方介绍内，Kitty具有以下特性:</p><ul><li><p>使用GPU进行渲染，以降低系统负载和更加平滑的滚动效果。使用多线程渲染使得输入延迟最低。</p></li><li><p>现代终端功能: 图像、Unicode、真彩色、OpenTye连体字、鼠标、聚焦跟随</p></li><li><p>对多个终端窗口进行不同的窗口布局操作</p></li><li><p>可通过脚本或Shell进行控制</p></li><li><p>使用<code>Kittens</code>框架，可以让一些小型程序用于扩展Kitty</p></li><li><p>允许在任意程序中使用回滚历史的功能</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于实在忍受不了iTerm2的卡顿，所以我尝试使用一款速度更快的终端——Kitty&lt;/p&gt;
    
    </summary>
    
      <category term="折腾日记" scheme="https://evanmeek.github.io/categories/%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="软件折腾" scheme="https://evanmeek.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>趣学Haskell-01</title>
    <link href="https://evanmeek.github.io/2019/09/26/%E8%B6%A3%E5%AD%A6Haskell-01/"/>
    <id>https://evanmeek.github.io/2019/09/26/趣学Haskell-01/</id>
    <published>2019-09-26T15:46:32.000Z</published>
    <updated>2020-01-22T04:44:27.768Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[Python-05]Python字符串常用方法详解</title>
    <link href="https://evanmeek.github.io/2019/09/23/Python-05-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://evanmeek.github.io/2019/09/23/Python-05-Python字符串常用方法详解/</id>
    <published>2019-09-23T11:40:09.000Z</published>
    <updated>2020-01-22T04:44:27.745Z</updated>
    
    <content type="html"><![CDATA[<p>Python系列第五章笔记，查看Python系列所有文章，请点击<a href="http://c.biancheng.net/python/str_method/" target="_blank" rel="noopener">💿</a></p><a id="more"></a><h1 id="Python字符串拼接-包含字符串拼接数字"><a href="#Python字符串拼接-包含字符串拼接数字" class="headerlink" title="Python字符串拼接(包含字符串拼接数字)"></a>Python字符串拼接(包含字符串拼接数字)</h1><p>先说一个Python中书写字符串的一种特殊方式，如果我们将两个字符串紧挨着写，那么Python则会自动拼接它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;Hello&quot;&apos;,World&apos;</span><br><span class="line">print(str1)</span><br></pre></td></tr></table></figure><p>输出结果:<code>Hello,World</code> </p><p><strong>Python字符串拼接数字</strong> </p><p>某些场景下，我们需要将字符串与其他数据类型进行拼接，例如数字，但Python是不支持直接将数字与字符串拼接的，所以我们得先将数字转换成字符串，再进行拼接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;This number is:&quot;</span><br><span class="line">number = 1.1001</span><br><span class="line"># 使用str()方法将数值类型的变量转化成字符串</span><br><span class="line">print(str1+str(number))</span><br><span class="line"># 使用repr()方法将数值类型的变量转化成字符串</span><br><span class="line">print(str1+repr(number))</span><br><span class="line"># 直接将字符串类型与数值类型进行拼接</span><br><span class="line">print(str1+number)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">This number is:1.1001</span><br><span class="line">This number is:1.1001</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">  │ print(str1+number)</span><br><span class="line">TypeError: can only concatenate str (not &quot;float&quot;) to str</span><br></pre></td></tr></table></figure><p>可以看到，我们必须先将数值类型的变量转换成字符串类型才能进行拼接，否则将会引发<code>TypeError</code>的错误。</p><p><strong>str()与repr()的区别</strong> </p><p>str()与repr()都可以将数值转换成字符串，但其中<strong>str是Python内置的类型，和int、float一样</strong> ，然而repr()则只是一个函数。</p><p>repr()方法还可以以Python表达式的形式来表示值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;This number is:&quot;</span><br><span class="line">print(str1)</span><br><span class="line">print(repr(str1))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This number is:</span><br><span class="line">&apos;This number is:&apos;</span><br></pre></td></tr></table></figure><h1 id="Python截取字符串-字符串切片-方法详解"><a href="#Python截取字符串-字符串切片-方法详解" class="headerlink" title="Python截取字符串(字符串切片)方法详解"></a>Python截取字符串(字符串切片)方法详解</h1><p>Python的字符串实际上是由多个字符组成的，并且允许通过索引访问字符串的某个字符，其语法格式为:</p><p><code>str[index]</code> </p><p>str代表要获取的字符串，index代表字符串的某个下标。</p><p>Python中字符串的第一个字符默认从0开始访问，依次推进则是0,1,2,n…，并且Python还允许使用负数作为索引下标，负数从-1开始，依次推进。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;HelloWorld&quot;</span><br><span class="line"># 获取&apos;H&apos;</span><br><span class="line">print(str1[0])</span><br><span class="line"># 获取&apos;o&apos;</span><br><span class="line">print(str1[-6])</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H</span><br><span class="line">o</span><br></pre></td></tr></table></figure><p>除了通过索引单次获取单个字符外，Python还可以使用中括号对字符串以范围的方式获取，被获取的字符串称为”子串”，其语法格式为:</p><p><code>string[start:end:step]</code> </p><ul><li>string代表要截取的字符串</li><li>start代表要截取子串的开始位置</li><li>end代表要截取子串的结束位置(不包括该字符)</li><li>step代表从start开始，每step个距离获取一个字符。默认为1，可忽略该值。</li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;HelloWorld&quot;</span><br><span class="line"># 截取&apos;Hello&apos;</span><br><span class="line">print(str1[0:6])</span><br><span class="line"># 截取&apos;Hold&apos;</span><br><span class="line">print(str1[0:len(str1):3])</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HelloW</span><br><span class="line">Hlod</span><br></pre></td></tr></table></figure><p>Python还支持使用<code>in</code>运算符判断是否包含某个子串.</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=&quot;HelloWorld&quot;</span><br><span class="line">print(&apos;Hello&apos; in str1)</span><br><span class="line">print(&quot;World&quot; in str1)</span><br><span class="line">print(&quot;Test&quot; in str1)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h1 id="Python-len-函数详解-获取字符串长度或字节数"><a href="#Python-len-函数详解-获取字符串长度或字节数" class="headerlink" title="Python len()函数详解:获取字符串长度或字节数"></a>Python len()函数详解:获取字符串长度或字节数</h1><p>len()函数用于获取字符串的长度，或字符串占用的字节。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1=&quot;HelloWorld&quot;</span><br><span class="line">print(len(str1))</span><br></pre></td></tr></table></figure><p>输出结果:<code>10</code> </p><p>如果想知道字符串所占用的字节数，可以先将字符串编码后，再获取。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1=&quot;你好世界&quot;</span><br><span class="line">print(len(str1))</span><br><span class="line">print(len(str1.encode()))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p><code>encode()</code>方法可以将字符串转换成不同编码格式的字符。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1=&quot;你好世界&quot;</span><br><span class="line">print(len(str1.encode()))</span><br><span class="line"># 将字符串转换成gbk编码格式</span><br><span class="line">print(len(str1.encode(&apos;gbk&apos;)))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h1 id="Python-split-方法详解-分割字符串"><a href="#Python-split-方法详解-分割字符串" class="headerlink" title="Python split()方法详解: 分割字符串"></a>Python split()方法详解: 分割字符串</h1><p>split()方法可以实现将一个字符串按照指定的分隔符分成多个子串，这些子串会被保存至列表中，其语法格式为:</p><p><code>string.split(sep,maxsplit)</code> </p><ul><li><p>string代表要分割的字符串</p></li><li><p>sep代表指定的分隔符，默认为None，也就是任何空字符，例如空格，\n，\t等</p></li><li><p>maxsplit代表最大分割次数，如果不指定或者指定为-1，则表示分割次数无限制。</p></li></ul><p><strong>如果不指定sep，那么maxsplit也不能指定</strong> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;192.168.0.0.1&quot;</span><br><span class="line"># 指定分隔符为&apos;.&apos;，最大分割数为3次</span><br><span class="line">list1 = str1.split(&apos;.&apos;,3)</span><br><span class="line">print(list1)</span><br><span class="line"># 指定分割符为&apos;0.&apos;，最大分割数为-1</span><br><span class="line">list1 = str1.split(&apos;0.&apos;,-1)</span><br><span class="line">print(list1)</span><br><span class="line"># 不指定split()参数</span><br><span class="line">list1 = str1.split()</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;192&apos;, &apos;168&apos;, &apos;0&apos;, &apos;0.1&apos;]</span><br><span class="line">[&apos;192.168.&apos;, &apos;&apos;, &apos;1&apos;]</span><br><span class="line">[&apos;192.168.0.0.1&apos;]</span><br></pre></td></tr></table></figure><h1 id="Python-join-方法-合并字符串"><a href="#Python-join-方法-合并字符串" class="headerlink" title="Python join()方法: 合并字符串"></a>Python join()方法: 合并字符串</h1><p>join()方法算是split()方法的逆方法，它可以将列表(或元素)中多个字符串元素采用固定的连接负连接在一起，其语法格式为:</p><p><code>newstr = str.join(iterable)</code> </p><ul><li><p>newstr代表合并后产生的新字符串.</p></li><li><p>str代表连接符</p></li><li><p>iterable代表合并操作的源字符串数据。</p></li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path = [&apos;usr&apos;,&apos;bin&apos;,&apos;python3.7&apos;]</span><br><span class="line">str1 = &apos;/&apos;.join(path)</span><br><span class="line">print(str1)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/python3.7</span><br></pre></td></tr></table></figure><h1 id="Python-count-方法，统计字符串出现的次数"><a href="#Python-count-方法，统计字符串出现的次数" class="headerlink" title="Python count()方法，统计字符串出现的次数"></a>Python count()方法，统计字符串出现的次数</h1><p>count()方法用于统计字符串在另一个字符串出现的次数，若不存在则返回0，否则返回统计的次数，其语法格式如下:</p><p><code>string.count(sub[,start[,end]])</code> </p><ul><li><p>string代表字符串源</p></li><li><p>sub代表要检索的字符串</p></li><li><p>start代表检索字符串的起始位置，若不指定则默认为0开始</p></li><li><p>end指定检索的终止位置，若不指定则默认为字符串长度</p></li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;叽里呱啦，嘻嘻哈哈，高高兴兴&quot;</span><br><span class="line">print(str1.count(&apos;嘻嘻哈哈&apos;,0,len(str1)))</span><br></pre></td></tr></table></figure><h1 id="Python-find-方法：检测字符串中是否包含某个子串"><a href="#Python-find-方法：检测字符串中是否包含某个子串" class="headerlink" title="Python find()方法：检测字符串中是否包含某个子串"></a>Python find()方法：检测字符串中是否包含某个子串</h1><p>find()方法用于检索字符串中是否包含目标字符串，若包含则返回第一次出现该字符串的索引，否则返回-1。其语法格式为:</p><p><code>string.find(sub,start,end)</code> </p><ul><li><p>string要检索的字符串源</p></li><li><p>sub要检索的子串</p></li><li><p>start检索的起始位置</p></li><li><p>end检索的终止位置</p></li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;叽里呱啦，嘻嘻哈哈，高高兴兴&quot;</span><br><span class="line">print(str1.find(&quot;嘻嘻哈哈&quot;))</span><br><span class="line">print(str1.find(&quot;嘻嘻哈哈&quot;,6,len(str1)))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p><strong>Python还提供了rfind()方法，与find()方法不同的是，其实从字符串的右侧开始检索</strong></p><h1 id="Python-index-方法-检测字符串中是否包含某个字符串"><a href="#Python-index-方法-检测字符串中是否包含某个字符串" class="headerlink" title="Python index()方法: 检测字符串中是否包含某个字符串"></a>Python index()方法: 检测字符串中是否包含某个字符串</h1><p>index()方法与find()方法类似，唯一不同的是，index()方法检索子串若没找到，则会抛出异常。</p><p>同理，Python也提供了个rindex()方法，作用于rfind()方法类似。</p><h1 id="Python字符串对齐方法ljust-、rjust-和center-详解"><a href="#Python字符串对齐方法ljust-、rjust-和center-详解" class="headerlink" title="Python字符串对齐方法ljust()、rjust()和center()详解"></a>Python字符串对齐方法ljust()、rjust()和center()详解</h1><p>Python 的<code>str</code>类提供了3种可以用来进行文本对齐的方法，分别是ljust()，rjust()，center()</p><h2 id="Python-ljust-方法"><a href="#Python-ljust-方法" class="headerlink" title="Python ljust()方法"></a>Python ljust()方法</h2><p>ljust()是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。语法格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.ljust(width,fillchar)</span><br></pre></td></tr></table></figure><ul><li>string 表示被填充的字符串</li><li>width 表示包括string长度在内，字符串要占的总长度</li><li>fillchar 表示填充时占位的字符，默认为空格</li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string = &apos;HelloWorld&apos;</span><br><span class="line">string2 = &quot;你好世界&quot;</span><br><span class="line">print(string.ljust(15,&apos;*&apos;),string2)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld***** 你好世界</span><br></pre></td></tr></table></figure><h2 id="Python-rjust-方法"><a href="#Python-rjust-方法" class="headerlink" title="Python rjust()方法"></a>Python rjust()方法</h2><p>rjust()方法与ljust()方法类似，唯一不同的是rjust()方法是向字符串左侧填充字符以右对齐的目的。语法格式:</p><p><code>str.rjust(width,fillchar)</code> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;HelloWorld&quot;</span><br><span class="line">print(string.rjust(15,&apos;*&apos;))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*****HelloWorld</span><br></pre></td></tr></table></figure><h2 id="Python-center-方法"><a href="#Python-center-方法" class="headerlink" title="Python center()方法"></a>Python center()方法</h2><p>center()方法与rjust()、ljust()方法类似，其作用是在字符串两边填充字符以进行居中对齐。语法格式:</p><p><code>str.center(width,fillchar)</code> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;HelloWorld&quot;</span><br><span class="line">print(string.center(20,&apos;*&apos;))</span><br></pre></td></tr></table></figure><p>输出结果:</p><p><code>*****HelloWorld*****</code> </p><h1 id="Python-startswith-和endswith-方法"><a href="#Python-startswith-和endswith-方法" class="headerlink" title="Python startswith()和endswith()方法"></a>Python startswith()和endswith()方法</h1><p>startswith()方法与endswith()方法都是用来检索指定字符串是否为字符串源的开头或结尾。</p><h2 id="startswith-方法"><a href="#startswith-方法" class="headerlink" title="startswith()方法"></a>startswith()方法</h2><p>startswith()方法用于检索指定字符串是否为字符串源的开头。如果是返回True，否则反之。语法格式:</p><p><code>str.startswith(sub,start,end)</code> </p><ul><li><p>str: 字符串源</p></li><li><p>sub: 指定的字符串（子串)</p></li><li><p>start: 指定开始检索的索引位置，可选参数，默认为开头。</p></li><li><p>end: 指定结束检索的索引位置，可选参数，默认为字符串源结尾。</p></li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;HelloWorld&quot;</span><br><span class="line">print(string.startswith(&quot;He&quot;,2))</span><br><span class="line">print(string.startswith(&quot;Wo&quot;,5))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h2 id="endswith-方法"><a href="#endswith-方法" class="headerlink" title="endswith()方法"></a>endswith()方法</h2><p>endswith()方法用于检索字符串是否以指定字符串结尾</p><p>语法格式:</p><p><code>str.endswith(sub,start,end)</code> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;HelloWorld&quot;</span><br><span class="line">print(string.endswith(&apos;ld&apos;))</span><br><span class="line">print(string.endswith(&apos;rl&apos;,0,len(string)-1))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h1 id="Pyhton大小写转换-3种-函数及用法"><a href="#Pyhton大小写转换-3种-函数及用法" class="headerlink" title="Pyhton大小写转换(3种)函数及用法"></a>Pyhton大小写转换(3种)函数及用法</h1><p>Python提供了三种函数，方便用于转换字符串大小写，分别是title(),lower(),upper().</p><h2 id="title-方法"><a href="#title-方法" class="headerlink" title="title()方法"></a>title()方法</h2><p>title()方法用于将字符串的字符转换为大写，其他字符转换为小写，并返回。</p><p><strong>若不需要进行转换，则会直接返回</strong> </p><p>语法格式:</p><p><code>str.title()</code> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;HelloWorld&quot;</span><br><span class="line">print(string.title())</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Helloworld</span><br></pre></td></tr></table></figure><h2 id="lower-方法"><a href="#lower-方法" class="headerlink" title="lower()方法"></a>lower()方法</h2><p>lower()方法用于将字符串中大写的字符转换为小写字符，并返回。</p><p>语法格式:</p><p><code>str.lower()</code> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;HelloWorld&quot;</span><br><span class="line">print(string.lower())</span><br></pre></td></tr></table></figure><p>输出结果:<code>helloworld</code> </p><h2 id="upper-方法"><a href="#upper-方法" class="headerlink" title="upper()方法"></a>upper()方法</h2><p>upper()方法用于将字符串中小写的字符转换为大写字符，并返回。</p><p>语法格式:</p><p><code>str.upper()</code> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;HelloWorld&quot;</span><br><span class="line">print(string.upper())</span><br></pre></td></tr></table></figure><p>输出结果:</p><p><code>HELLOWORLD</code> </p><h1 id="Python去除字符串中空格"><a href="#Python去除字符串中空格" class="headerlink" title="Python去除字符串中空格"></a>Python去除字符串中空格</h1><p>Python提供了三种方法，用于去除字符串中的特殊符号或指定字符，例如<strong>换行符(\n)，回车符(\r)，制表符(\t)</strong>，它们分别是strip(),ltrip(),rtrip().</p><h2 id="strip-方法"><a href="#strip-方法" class="headerlink" title="strip()方法"></a>strip()方法</h2><p>strip()用于去除字符串前后(左右侧)的特殊符号或指定字符。</p><p>语法格式:</p><p><code>str.strip(char)</code> </p><ul><li><p>str: 字符串源</p></li><li><p>char: 指定删除的字符，可选参数，默认为空格、换行符、回车符、制表符</p></li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;\r   排山倒海\t\n\r&quot;</span><br><span class="line">print(repr(string))</span><br><span class="line">print(repr(string.strip()))</span><br><span class="line">print(repr(string.strip(&apos;\r&apos;)))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;\r   排山倒海\t\n\r&apos;</span><br><span class="line">&apos;排山倒海&apos;</span><br><span class="line">&apos;   排山倒海\t\n&apos;</span><br></pre></td></tr></table></figure><h2 id="lstrip-方法"><a href="#lstrip-方法" class="headerlink" title="lstrip()方法"></a>lstrip()方法</h2><p>lstrip方法用于去除字符串前(左侧)的特殊符号或指定字符。</p><p>语法格式:</p><p><code>str.lstrip(char)</code> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;\t\n\r排山倒海&quot;</span><br><span class="line">print(repr(string))</span><br><span class="line">print(repr(string.lstrip()))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;\t\n\r排山倒海&apos;</span><br><span class="line">&apos;排山倒海&apos;</span><br></pre></td></tr></table></figure><h2 id="rstrip-方法"><a href="#rstrip-方法" class="headerlink" title="rstrip()方法"></a>rstrip()方法</h2><p>rstrip()方法与lstrip()方法以及strip()方法很类似，只不过其作用是去除字符串后(右侧)的特殊符号或指定字符。</p><p>语法格式:</p><p><code>str.rstrip(char)</code> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;排山倒海\t\n\r&quot;</span><br><span class="line">print(repr(string))</span><br><span class="line">print(repr(string.rstrip()))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;排山倒海\t\n\r&apos;</span><br><span class="line">&apos;排山倒海&apos;</span><br></pre></td></tr></table></figure><h1 id="Python-format-方法格式化输出方法详解"><a href="#Python-format-方法格式化输出方法详解" class="headerlink" title="Python format()方法格式化输出方法详解"></a>Python format()方法格式化输出方法详解</h1><p>语法格式:</p><p><code>str.format(args)</code> </p><ul><li><p>str: 字符串源</p></li><li><p>args: 参数列表，使用逗号进行分割</p></li></ul><p>format()方法的重点在于搞清楚str显示样式的格式。在差UN感觉爱你显示样式模板时，需要使用<code>{}</code>和<code>:</code>来指定占位符，其完整的语法格式为:</p><p><code>{[index][:[[fill] align] [sign] [#] [width] [.precision] [type]]}</code> </p><p><strong>注意,语法格式中的<code>[]</code>括起来的都是可选参数</strong> </p><p>参数含义如下:</p><ul><li><p>index : 指定后面设置的格式要作用到args中第n个数据，数据的索引值从0开始，默认值为args中数据的先后顺序自动分配排列。</p></li><li><p>fill : 指定空白处填充的字符。注意，当填充字符为逗号<code>,</code>切作用于整数或浮点数时，该整数(或浮点数)会以逗号分隔的形式输出，例如(1000会输出1,000)。</p></li><li><p>align : 指定数据的对齐方式</p></li></ul><p>align 参数及含义</p><table><thead><tr><th>align</th><th>含义</th></tr></thead><tbody><tr><td>&lt;</td><td>数据左对齐</td></tr><tr><td>&gt;</td><td>数据右对齐</td></tr><tr><td>=</td><td>数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对 数据类型有效</td></tr><tr><td>^</td><td>数据居中，此选项续和width参数一起使用</td></tr></tbody></table><ul><li>sign : 指定有无符号数</li></ul><table><thead><tr><th>sign</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>正数加正号，负数加负号</td></tr><tr><td>-</td><td>正数不加正好，负数加负号</td></tr><tr><td>空格</td><td>正数前加空格，负数前加负号</td></tr><tr><td>#</td><td>对于二、八、十六进制数，使用此参数，会显示对应的前缀</td></tr></tbody></table><ul><li><p>width : 指定输出数据时所占的宽度。</p></li><li><p>.precision : 指定保留的小数位数。</p></li><li><p>type : 指定输出数据的具体类型</p></li></ul><table><thead><tr><th>type类型值</th><th>含义</th></tr></thead><tbody><tr><td>s</td><td>对字符串类型格式化</td></tr><tr><td>d</td><td>十进制整数</td></tr><tr><td>c</td><td>将十进制整数自动转换成对应的 Unicode字符</td></tr><tr><td>e或者E</td><td>转换成科计数法后，再格式化输出</td></tr><tr><td>g或G</td><td>自动在e和f中切换</td></tr><tr><td>b</td><td>将十进制数自动转换成二进制表示，再格式化</td></tr><tr><td>o</td><td>将十进制数自动转换成八进制表示，再格式化</td></tr><tr><td>x或X</td><td>将十进制数自动转换成十六进制表示，再格式化</td></tr><tr><td>f或F</td><td>转换为浮点数(默认小数点后保留6位),再格式化输出</td></tr><tr><td>%</td><td>显示百分比(默认显示小数点后6位)</td></tr></tbody></table><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;姓名:&#123;:&gt;5s&#125;\n工资:&#123;:&gt;10.2F&#125;\n&quot;</span><br><span class="line">print(string.format(&quot;张三&quot;,1001.223))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">姓名:   张三</span><br><span class="line">工资:   1001.22</span><br></pre></td></tr></table></figure><p>例子2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 货币形式显示</span><br><span class="line">print(&quot;$:&#123;:,d&#125;&quot;.format(1000009922399))</span><br><span class="line"></span><br><span class="line"># 科学计数法显示</span><br><span class="line">print(&quot;科学计数法:&#123;:e&#125;&quot;.format(1000.123))</span><br><span class="line"></span><br><span class="line"># 十六进制显示</span><br><span class="line">print(&quot;1016的十六进制:&#123;:x&#125;&quot;.format(1016))</span><br><span class="line"></span><br><span class="line"># 百分比形式显示</span><br><span class="line">print(&quot;百分比显示:&#123;:.0%&#125;&quot;.format(0.99))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$:1,000,009,922,399</span><br><span class="line">科学计数法:1.000123e+03</span><br><span class="line">1016的十六进制:3f8</span><br><span class="line">百分比显示:99%</span><br></pre></td></tr></table></figure><h1 id="Python-encode-和decode-方法-字符串编码转换"><a href="#Python-encode-和decode-方法-字符串编码转换" class="headerlink" title="Python encode()和decode()方法: 字符串编码转换"></a>Python encode()和decode()方法: 字符串编码转换</h1><p>前言: 世界最早的字符编码时ASCII编码，它最多表示256个符号，每个符号占用1个字节，随着技术的发展，多国的文字都需要进行编码，所以出现了很多种编码格式，例如UTF-8也就是最通用的编码格式，Python3.x默认也是使用UTF-8编码格式。</p><p>Python中有两种常用的字符串类型: <code>str</code>与<code>bytes</code>类型，<code>str</code>用来表示Unicode字符,<code>bytes</code>用来表示二进制数据。</p><p>所以我们就需要使用<code>encode()</code>和<code>decode()</code>方法进行转换。</p><h2 id="Phthon-encode-方法"><a href="#Phthon-encode-方法" class="headerlink" title="Phthon encode()方法"></a>Phthon encode()方法</h2><p>encode()方法是str提供的功法，其作用是将str类型转换成bytes类型，这个操作也被称为编码。</p><p>语法格式如下:</p><p><code>str.encode([encode=&quot;utf-8&quot;],[errors=&quot;strict&quot;])</code> </p><ul><li><p>encoding : 指定在编码时采用的字符编码，默认采用utf-8。当只有这个参数时，可以省略<code>=</code>直接写<code>str.encode(&quot;UTF-8&quot;)</code></p></li><li><p>errors : 指定错误处理方式，默认为strict，其可选项有:</p></li></ul><table><thead><tr><th>errors</th><th>含义</th></tr></thead><tbody><tr><td>strict</td><td>遇到非法字符就抛出异常</td></tr><tr><td>ignore</td><td>忽略非法字符</td></tr><tr><td>replace</td><td>用<code>?</code>替代非法字符</td></tr><tr><td>xmlcharrefreplace</td><td>使用xml的字符引用</td></tr></tbody></table><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;HelloWorld&quot;</span><br><span class="line">print(string.encode())</span><br></pre></td></tr></table></figure><p>输出结果:</p><p><code>b&#39;HelloWorld&#39;</code> </p><h2 id="Python-decode-方法"><a href="#Python-decode-方法" class="headerlink" title="Python decode()方法"></a>Python decode()方法</h2><p>decode()可以将bytes类型的二进制数据转换成str类型，这个过程被称为解码</p><p>语法格式:</p><p><code>bytes.decode([encoding=&quot;utf-8&quot;],[errors=&quot;strict&quot;])</code> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;HelloWorld&quot;</span><br><span class="line">print(string.encode())</span><br><span class="line">print(bytes.decode(string.encode()))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b&apos;HelloWorld&apos;</span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure><p><strong>注意:解码时必须使用与编码时相同的编码格式，否则将会抛出异常</strong> </p><h1 id="Python-dir-和help-帮助函数"><a href="#Python-dir-和help-帮助函数" class="headerlink" title="Python dir()和help()帮助函数"></a>Python dir()和help()帮助函数</h1><p>Python提供了两个函数，用于帮助程序员查询文档，掌握这两个函数则可以查看所有函数(方法)的用法及功能.</p><p><strong>dir()</strong> 列出指定类或模块包含的全部内容，包括函数、方法、类、变量etc.</p><p><strong>help()</strong> 查看某个函数或方法的帮助文档。</p><p>例子:</p><p>查看字符串能调用的全部内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(dir(str))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;_</span><br><span class="line">_eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__getnewargs</span><br><span class="line">__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;</span><br><span class="line">, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;,</span><br><span class="line">&apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;</span><br><span class="line">, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;, &apos;center&apos;, &apos;count&apos;, &apos;e</span><br><span class="line">ncode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;format_map&apos;, &apos;index&apos;, &apos;isal</span><br><span class="line">num&apos;, &apos;isalpha&apos;, &apos;isascii&apos;, &apos;isdecimal&apos;, &apos;isdigit&apos;, &apos;isidentifier&apos;, &apos;islower&apos;, &apos;</span><br><span class="line">isnumeric&apos;, &apos;isprintable&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;, &apos;join&apos;, &apos;ljust&apos;, &apos;lo</span><br><span class="line">wer&apos;, &apos;lstrip&apos;, &apos;maketrans&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;rjust&apos;,</span><br><span class="line"> &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;,</span><br><span class="line"> &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;]</span><br></pre></td></tr></table></figure><p><strong>注意:其中以<code>_</code>结尾的方法为私有方法，不希望被外界直接调用。</strong> </p><p><strong>help()</strong> </p><p>想要查看某个方法或函数的帮助文档，就使用help()函数</p><p><code>print(help(str.format))</code> </p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">format(...)</span><br><span class="line">    S.format(*args, **kwargs) -&gt; str</span><br><span class="line"></span><br><span class="line">    Return a formatted version of S, using substitutions from args and kwargs.</span><br><span class="line">    The substitutions are identified by braces (&apos;&#123;&apos; and &apos;&#125;&apos;).</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python系列第五章笔记，查看Python系列所有文章，请点击&lt;a href=&quot;http://c.biancheng.net/python/str_method/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;💿&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://evanmeek.github.io/categories/Python/"/>
    
    
      <category term="Python系列" scheme="https://evanmeek.github.io/tags/Python%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>自我反省</title>
    <link href="https://evanmeek.github.io/2019/09/23/%E8%87%AA%E6%88%91%E5%8F%8D%E7%9C%81/"/>
    <id>https://evanmeek.github.io/2019/09/23/自我反省/</id>
    <published>2019-09-23T11:02:17.000Z</published>
    <updated>2020-01-22T04:44:27.765Z</updated>
    
    <content type="html"><![CDATA[<p>自我反省，回想一下开学以来自己都做了些什么?</p><a id="more"></a><p>&emsp;&emsp;还在暑假时，我就十分期待开学，因为暑假一个人有些无聊。不是说hack不够快乐，而是我更想偶尔跟朋友一起娱乐。现在开学也有20天了，我却发现我开学时的计划已经被我忘得干干净净了。所以我得总结一下，自开学以来，李天宇都干了些什么?</p><p>&emsp;&emsp;由于在上学期竞选了社团技术部的部长，所以我不得不处于刚开学就忙得不可开交的状态。说实话，我并不擅长管理，而社团部门部长这一任职对我来说压力挺大的，我得每天留意微信，遗漏掉任何一条消息，都可能失去大量的信息。正是因为我每天微信消息很多，所以我越来越讨厌那些发长语音的人(除了我女朋友)，如果长语音能清晰地表达出意思还好，但往往很多人都是在嗯…啊…昂…徘徊，花费近1min的时间去听那个信息量两三句话的语音，简直让我每次听完都想立刻瞬间移动到对方面前，大喊几声:”你到底想说什么?你发语音能不能别发那么长段的!”，不过得益于网络的发展，我并不需要瞬间移动过去，我偶尔会把这两句话通过微信以网络传输的方式发送至对方。事情往往没有想得那么简单，因为我发完那两句话之后，对方可能又是一个长语音过来，解释他刚刚说的。讲了这一个小例子，读者们可能意识到，我是想表达:因为很多人是这么做的，所以我在使用微信时是十分低效的。每次想到这里，我就回想起在irc内通过邮件列表互相交流的时光是多么的美好。</p><p>&emsp;&emsp;我几乎每天都会在图书馆待上一阵子，正如此时，我就在图书馆敲打着蝶式键盘写着这一句。每天在图书馆的时间，我都用来学习Python了，因为我在暑假时在B站发现一位up主，他使用Vim完成日常的写代码、写文章、记笔记的事情，并且在看过他演示后，我便被他所提到的Vim彻底吸引了，因为实在太高效了。那时我每天就研究关于Linux某些软件的配置，例如:<code>i3wm</code>,<code>ranger</code>,<code>neovim</code>，其中我渐渐觉得Python几乎出现在我所接触到的软件的任何地方，可能是由于其第三方库丰富以及语法简单、优雅，程序可移植性高的缘故，由Python开发的开源软件，大多数都可以很轻松的使用Python扩展你想要添加的新功能。其中<code>ranger</code>我就想着为其提供一些新功能，所以我便开始学习Python，图书馆的日子基本都是学习Python这门语言了。</p><p>&emsp;&emsp;前面介绍了我生活的一些七七八八的东西，搞的我脑子很乱，我发现我还是不怎么会写作，下次得好好看下如何写作了，这篇文章暂时先写到这里，等我什么时候(咕咕咕) 有新想法了再继续吧!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自我反省，回想一下开学以来自己都做了些什么?&lt;/p&gt;
    
    </summary>
    
      <category term="个人感想" scheme="https://evanmeek.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="个人感想" scheme="https://evanmeek.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>[Python-04]Python列表、元组、字典和集合</title>
    <link href="https://evanmeek.github.io/2019/09/08/Python-04-Python%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"/>
    <id>https://evanmeek.github.io/2019/09/08/Python-04-Python列表、元组、字典和集合/</id>
    <published>2019-09-08T07:00:28.000Z</published>
    <updated>2020-01-22T04:44:27.741Z</updated>
    
    <content type="html"><![CDATA[<p>Python系列第四章笔记，查看Python系列所有文章，请点击<a href="http://c.biancheng.net/python/list_tuple_dict/" target="_blank" rel="noopener">💿</a></p><a id="more"></a><h1 id="什么是序列，Python序列详解（包括序列类型和常用操作）"><a href="#什么是序列，Python序列详解（包括序列类型和常用操作）" class="headerlink" title="什么是序列，Python序列详解（包括序列类型和常用操作）"></a>什么是序列，Python序列详解（包括序列类型和常用操作）</h1><p>序列：一块可存放多个且连续的内存空间，并且这些值有顺序，可通过索引进行访问。</p><p>常见的序列有: 字符串、列表、元组、集合和字典。</p><p>这些常见的序列，除了集合和字典不支持索引、切片、相加和相乘的操作，其余的都可以。</p><h2 id="序列索引"><a href="#序列索引" class="headerlink" title="序列索引"></a>序列索引</h2><p>索引就是一个序列中每个元素的编号。第一个元素的索引是0，也就是说想要访问某个序列的第一个元素，那么它的索引就是0，而想要访问最后一个元素，那么它的索引就是序列长度-1</p><p>索引还分为正索引值和负索引值，它们的区别仅仅在于访问方式不同。</p><p><strong>注意:</strong></p><ul><li><p>正索引值的起始位置是0，结束位置是序列长度-1</p></li><li><p>负索引值的起始位置是-1,结束位置是-(序列长度-1)</p></li></ul><p>例子:</p><p><strong>根据索引访问序列元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;Hello World&quot;</span><br><span class="line">print(&quot;str 的第一个字符是:%s，最后一个字符是:%s&quot; % (str[0],str[len(str)-1]))</span><br></pre></td></tr></table></figure><p>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str 的第一个字符是:H，最后一个字符是:d</span><br></pre></td></tr></table></figure></p><h2 id="序列切片"><a href="#序列切片" class="headerlink" title="序列切片"></a>序列切片</h2><p>刚刚我们通过索引值进行访问序列元素，那么序列切片也是可以做到的，它可以访问某个范围内的元素。</p><p>语法格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sname[start:end:step]</span><br></pre></td></tr></table></figure><ul><li><p>sname:序列名称</p></li><li><p>start:切片开始的索引位置（包括该位置），此参数可不指定，默认为0。</p></li><li><p>end:切片结束的索引位置(不包括该位置)，此参数可不指定，默认为序列的长度。</p></li><li><p>step:切片的范围，也就是每次取元素时，要隔多少个位置，此参数可不指定，可以直接忽略最后一个冒号</p></li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;Hello World&quot;</span><br><span class="line"># 获取整个字符串</span><br><span class="line">print(str[:])</span><br><span class="line"># 从索引4开始，一直到最后一个，没隔2个字符取一次。</span><br><span class="line">print(str[4::2])</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">oWrd</span><br></pre></td></tr></table></figure><h2 id="序列相加"><a href="#序列相加" class="headerlink" title="序列相加"></a>序列相加</h2><p>序列可以使用<code>+</code>运算符，进行相加操作，他会将两个序列进行连接，但不会去除重复的元素。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1=&quot;hello&quot;</span><br><span class="line">str2=&quot;world&quot;</span><br><span class="line">print(str1+str2)</span><br></pre></td></tr></table></figure><p>输出结果:<code>helloworld</code></p><h2 id="序列相乘"><a href="#序列相乘" class="headerlink" title="序列相乘"></a>序列相乘</h2><p>使用<code>*</code>运算符，可以将序列的元素进行重复。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;hello\t&quot;</span><br><span class="line">print(str1*3)</span><br></pre></td></tr></table></figure><p>输出结果:<code>hello    hello    hello</code></p><p><strong>tips:可以使用序列相乘，创建指定长度空列表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_list = [None]*5</span><br></pre></td></tr></table></figure><h2 id="检查元素是否包含在序列中"><a href="#检查元素是否包含在序列中" class="headerlink" title="检查元素是否包含在序列中"></a>检查元素是否包含在序列中</h2><p>使用<code>in</code>关键字可以检查序列中的元素是否存在。 </p><p>语法格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value in sequence</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1=&quot;Hello&quot;</span><br><span class="line">print(&apos;o&apos; in str1)</span><br></pre></td></tr></table></figure><p>输出结果: <code>True</code></p><p><strong>tips:使用<code>not in</code>关键字可以检查是否不存在</strong></p><h2 id="和序列相关的内置函数"><a href="#和序列相关的内置函数" class="headerlink" title="和序列相关的内置函数"></a>和序列相关的内置函数</h2><p>Python提供了几个用于操作序列的内置函数，可以很方便的操作序列。</p><p><img src="/2019/09/08/Python-04-Python列表、元组、字典和集合/Python序列内置函数.png" alt="Python序列内置函数"></p><h1 id="Python-list列表详解"><a href="#Python-list列表详解" class="headerlink" title="Python list列表详解"></a>Python list列表详解</h1><p>Python提供了一种数据结构————<code>list</code>(列表)</p><p><strong>列表可以存储多个不同数据类型的元素。</strong></p><h2 id="Python创建列表"><a href="#Python创建列表" class="headerlink" title="Python创建列表"></a>Python创建列表</h2><p>创建列表分为两种方式</p><p>使用<code>=</code>运算符创建列表</p><p>语法格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname = [element1,element2...elementn]</span><br></pre></td></tr></table></figure><p>listname: 列表的名称</p><p>element1: 列表的元素</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个列表</span><br><span class="line">test_list1 =[&quot;one&quot;,1,True,1.0]</span><br><span class="line">print(test_list1)</span><br><span class="line"># 创建一个空列表</span><br><span class="line">empty_list = []</span><br><span class="line">print(empty_list)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;one&apos;, 1, True, 1.0]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p><strong>使用list()函数创建列表</strong></p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1=&quot;HelloWorld&quot;</span><br><span class="line">test_list = list(str1)</span><br><span class="line">print(test_list)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;W&apos;, &apos;o&apos;, &apos;r&apos;, &apos;l&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure><h2 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h2><p>两种方式：通过索引访问和通过切片访问。</p><h2 id="删除列表"><a href="#删除列表" class="headerlink" title="删除列表"></a>删除列表</h2><p>不常用，因为Python具有垃圾回收机制，有些不需要再使用的列表将会自动回收。</p><p>使用<code>del</code>关键字进行删除</p><p>语法格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del listname</span><br></pre></td></tr></table></figure><p><strong>注意:删除后的列表不能再次使用</strong></p><h1 id="Python-list列表添加元素的3种方法"><a href="#Python-list列表添加元素的3种方法" class="headerlink" title="Python list列表添加元素的3种方法"></a>Python list列表添加元素的3种方法</h1><h2 id="Python-append-方法添加元素"><a href="#Python-append-方法添加元素" class="headerlink" title="Python append()方法添加元素"></a>Python append()方法添加元素</h2><p><code>append()</code>方法在列表的末尾追加元素。</p><p>语法格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname.append(obj)</span><br></pre></td></tr></table></figure><p>listname代表要添加元素的列表;obj代表要添加到列表末尾的数据。</p><p>obj可以是单个元素，也可以是其他序列。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 追加单个元素</span><br><span class="line">list1 = [0,1,2,3]</span><br><span class="line">print(list1)</span><br><span class="line">list1.append(4)</span><br><span class="line">print(list1)</span><br><span class="line"># 追加一个列表</span><br><span class="line">list2 = [5,6,7,8]</span><br><span class="line">print(list2)</span><br><span class="line">list1.append(list2)</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure><p>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3]</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">[5, 6, 7, 8]</span><br><span class="line">[0, 1, 2, 3, 4, [5, 6, 7, 8]]</span><br></pre></td></tr></table></figure></p><p><strong>注意:使用append()函数时，如果是传递的单个数据，将会直接追加到列表后，但是如果传入的是个列表（序列），那么则会追加一个列表形式的元素。</strong></p><p>想要访问刚刚追加的列表元素的其中一个可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [0,1,2]</span><br><span class="line">list2 = [3,4,5]</span><br><span class="line">list1.append(list2)</span><br><span class="line">print(list1[3][2])</span><br></pre></td></tr></table></figure><p>输出结果:<code>5</code></p><h2 id="Python-extend-方法添加元素"><a href="#Python-extend-方法添加元素" class="headerlink" title="Python extend()方法添加元素"></a>Python extend()方法添加元素</h2><p>刚刚我们使用<code>append()</code>函数追加了个列表元素，但是并没有像添加单个字符一样作为一个整体添加，而我们只需要使用<code>extend()</code>方法就可以将列表以整体的方式添加进去。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1 = [0,1,2,3]</span><br><span class="line">print(list1)</span><br><span class="line">list2 = [5,6,7,8]</span><br><span class="line">print(list2)</span><br><span class="line">list1.extend(list2)</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3]</span><br><span class="line">[5, 6, 7, 8]</span><br><span class="line">[0, 1, 2, 3, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><h2 id="Python-insert-方法插入元素"><a href="#Python-insert-方法插入元素" class="headerlink" title="Python insert()方法插入元素"></a>Python insert()方法插入元素</h2><p>需要指定插入列表元素的位置时，可以使用insert()方法。</p><p>语法格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname.insert(index,obj)</span><br></pre></td></tr></table></figure><p>index: 将obj插入到listname列表的索引</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test_list1 = list(range(1,11))</span><br><span class="line">print(test_list1)</span><br><span class="line"></span><br><span class="line">print(len(test_list1))</span><br><span class="line">test_list1.insert(len(test_list1),11)</span><br><span class="line">print(test_list1)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">10</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span><br></pre></td></tr></table></figure><h2 id="Pyhton-list列表删除元素-3种方法"><a href="#Pyhton-list列表删除元素-3种方法" class="headerlink" title="Pyhton list列表删除元素(3种方法)"></a>Pyhton list列表删除元素(3种方法)</h2><blockquote><p>del删除</p></blockquote><p><strong>del语句在Python中可以删除变量、列表的元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_list = list(range(1, 11))</span><br><span class="line">print(test_list)</span><br><span class="line">del test_list[1::2]</span><br><span class="line">print(test_list)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure><blockquote><p>根据元素值进行删除</p></blockquote><p>可以使用remove()方法来删除列表元素。</p><p>删除第一个被查找到的元素。</p><p><strong>注意:remove()方法不是根据索引来删除元素的，而是查找元素本身，再进行删除，所以如果找不到元素，则会报错</strong></p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_list = [&apos;test&apos;, 30, &apos;test2&apos;, 10, 30]</span><br><span class="line">test_list.remove(&apos;test&apos;)</span><br><span class="line">test_list.remove(30)</span><br><span class="line">print(test_list)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;test2&apos;, 10, 30]</span><br></pre></td></tr></table></figure><blockquote><p>删除列表所有元素</p></blockquote><p>使用clear()方法可以删除列表的所有元素。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_list = [&apos;test&apos;, 30, &apos;test2&apos;, 10, 30]</span><br><span class="line">test_list.clear()</span><br><span class="line">print(test_list)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure><h1 id="Python-list列表修改元素"><a href="#Python-list列表修改元素" class="headerlink" title="Python list列表修改元素"></a>Python list列表修改元素</h1><p>修改列表元素，可以通过列表索引获取元素进行赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testlist = list(range(1,10))</span><br><span class="line">print(testlist)</span><br><span class="line">testlist[len(testlist)-1] = 100</span><br><span class="line">print(testlist)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 100]</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><p>使用slice语法对列表部分进行赋值。</p><p>slice语法，不要求新赋值的元素个数与原来的元素个数相等。也就是说使用slice剩余法既可以为列表增加元素，也可以为列表删除元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b_list = list(range(1,5))</span><br><span class="line">print(b_list)</span><br><span class="line"></span><br><span class="line">b_list[1:3] = [&apos;a&apos;,&apos;b&apos;]</span><br><span class="line">print(b_list)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4]</span><br><span class="line">[1, &apos;a&apos;, &apos;b&apos;, 4]</span><br></pre></td></tr></table></figure><h1 id="Pyhthon-list常用方法-count、index、pop、reverse和sort-快速攻略"><a href="#Pyhthon-list常用方法-count、index、pop、reverse和sort-快速攻略" class="headerlink" title="Pyhthon list常用方法(count、index、pop、reverse和sort)快速攻略"></a>Pyhthon list常用方法(count、index、pop、reverse和sort)快速攻略</h1><p>Pyhton为list提供了一些常用的方法。</p><p>我们使用dir(list)方法可以看到列表包含的所有方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(dir(list))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6 _&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;,</span><br><span class="line">5 &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setat</span><br><span class="line">4 tr__&apos;, &apos;__setitem__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;c</span><br><span class="line">3 lear&apos;, &apos;copy&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;</span><br><span class="line">2 , &apos;sort&apos;]</span><br></pre></td></tr></table></figure><p><strong>注意，方法名包含双下划线的不推荐使用</strong> </p><h2 id="count-方法"><a href="#count-方法" class="headerlink" title="count()方法"></a>count()方法</h2><p>count()方法用于统计列表中某个元素出现的次数</p><p>语法格式</p><p><code>listname.count(obj)</code> </p><p>listname:列表名称</p><p>obj:表示判断是否存在的元素</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_list = [2]*5</span><br><span class="line">print(a_list)</span><br><span class="line">print(&quot;2出现%d次&quot; % a_list.count(2))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2, 2, 2, 2, 2]</span><br><span class="line">2出现5次</span><br></pre></td></tr></table></figure><h2 id="index-用法"><a href="#index-用法" class="headerlink" title="index()用法"></a>index()用法</h2><p>index()方法用于定位某元素在列表的索引位置，如果该元素没有出现，则会引发ValueError错误。 </p><p>语法格式:</p><p><code>listname.index(obj,start,end)</code></p><p>index()方法可以传入start,end参数，用于指定在列表的某范围内搜索元素</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_list = list(range(1,10))</span><br><span class="line">print(test_list)</span><br><span class="line">print(test_list.index(9))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="pop用法"><a href="#pop用法" class="headerlink" title="pop用法"></a>pop用法</h2><p>pop()方法会溢出列表中指定索引处的元素，如果没有传入参数，则会移除列表中最后一个元素。</p><p>语法格式:</p><p><code>listname.pop(index)</code> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test_list = list(range(1,10))</span><br><span class="line">print(test_list)</span><br><span class="line"># 默认移除最后一个元素</span><br><span class="line">test_list.pop()</span><br><span class="line">print(test_list)</span><br><span class="line"># 移除第一次元素</span><br><span class="line">print(test_list.pop(0))</span><br><span class="line">print(test_list)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class="line">1</span><br><span class="line">[2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><h2 id="reverse-方法"><a href="#reverse-方法" class="headerlink" title="reverse()方法"></a>reverse()方法</h2><p>reverse()方法会将列表中所有元素反向存放。</p><p>语法格式;</p><p><code>listname.reverse()</code></p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_list = list(range(1,11))</span><br><span class="line">print(test_list)</span><br><span class="line">test_list.reverse()</span><br><span class="line">print(test_list)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure><h2 id="sort-用法"><a href="#sort-用法" class="headerlink" title="sort()用法"></a>sort()用法</h2><p>sort()方法用于对列表元素进行排序。</p><p>语法格式:</p><p><code>listname.sort(key=None,reserse=Fale)</code></p><ul><li><p>key参数用于指定从每个元素中提取一个用于比较的键。</p></li><li><p>reverse参数用于设置是否需要逆序，默认为False也就是从小打到排序，否则反之。</p></li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a_list = [123,213,1,325,1,51,213,5132,4156]</span><br><span class="line">print(a_list)</span><br><span class="line"># 对列表进行排序</span><br><span class="line">a_list.sort()</span><br><span class="line">print(a_list)</span><br><span class="line"># 逆序排序</span><br><span class="line">a_list.sort(reverse=True)</span><br><span class="line">print(a_list)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[123, 213, 1, 325, 1, 51, 213, 5132, 4156]</span><br><span class="line">[1, 1, 51, 123, 213, 213, 325, 4156, 5132]</span><br><span class="line">[5132, 4156, 325, 213, 213, 123, 51, 1, 1]</span><br></pre></td></tr></table></figure><h1 id="Python-range-快速初始化数字列表"><a href="#Python-range-快速初始化数字列表" class="headerlink" title="Python range()快速初始化数字列表"></a>Python range()快速初始化数字列表</h1><p>Python的range()函数能够生成一系列的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for value in range(1,5):</span><br><span class="line">  print(value)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>range()方法是指定从第一个值开始，生成连续的数字，直到指定的第二值为止(不包括第二个值)</p><p>range()方法可以指定步长，也就是说，每次连续增加时所增加的数值。</p><h1 id="Python-tuple元组详解"><a href="#Python-tuple元组详解" class="headerlink" title="Python tuple元组详解"></a>Python tuple元组详解</h1><p>与列表类似，元组也可以存储任何Python的数据类型，但元组是不可变的，一旦赋值则不可修改。</p><p>Python中，使用<code>()</code>小括号包住的一列数据，被称为元组，而各数据之间又由<code>,</code>逗号隔开。</p><p>元组的数据类型是:<code>tuple</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_tuple = tuple(range(1,11))</span><br><span class="line">print(type(test_tuple))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;tuple&apos;&gt;</span><br><span class="line"></span><br><span class="line">[Process exited 0]</span><br></pre></td></tr></table></figure><h2 id="Python创建元组"><a href="#Python创建元组" class="headerlink" title="Python创建元组"></a>Python创建元组</h2><h3 id="运算符直接创建元组"><a href="#运算符直接创建元组" class="headerlink" title="= 运算符直接创建元组"></a>= 运算符直接创建元组</h3><p>可以使用赋值运算符<code>=</code>将一个元组赋值给变量。</p><p>语法格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuplename = (element1,element2...elementn)</span><br></pre></td></tr></table></figure><p>其中tuplename表示要创建的元组名,element代表元素。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num_tuple = tuple(range(1,11))</span><br><span class="line">str_tuple = (&quot;Just A Test&quot;,)</span><br><span class="line">object_tuple = (&quot;a&quot;,1,2.22,num_tuple,list(range(1,5)))</span><br><span class="line"></span><br><span class="line">print(num_tuple)</span><br><span class="line">print(str_tuple)</span><br><span class="line">print(object_tuple)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br><span class="line">Just A Test</span><br><span class="line">(&apos;a&apos;, 1, 2.22, (1, 2, 3, 4, 5, 6, 7, 8, 9, 10), [1, 2, 3, 4])</span><br></pre></td></tr></table></figure><p><strong>注意</strong> :创建元组时，如果元组内只有一个元素，那么必须要在元素后加上一个逗号，否则Python解释器将会一位是字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_str = (&quot;Just a Test&quot;)</span><br><span class="line">str_tuple = (&quot;Jest a Test&quot;,)</span><br><span class="line">print(type(test_str))</span><br><span class="line">print(type(str_tuple))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">&lt;class &apos;tuple&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="使用tuple-函数创建元组"><a href="#使用tuple-函数创建元组" class="headerlink" title="使用tuple()函数创建元组"></a>使用tuple()函数创建元组</h3><p>Python提供了tuple()函数创建元组，我们可以将一些常见的对象，转化成元组。</p><p>语法格式:</p><p><code>tuple(iterable: Iterable[_T_co]=...)</code></p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_list = list(range(1,21,2))</span><br><span class="line">test_tuple = tuple(test_list)</span><br><span class="line"></span><br><span class="line">print(type(test_list))</span><br><span class="line">print(type(test_tuple))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;list&apos;&gt;</span><br><span class="line">&lt;class &apos;tuple&apos;&gt;</span><br></pre></td></tr></table></figure><h2 id="Python访问元组元素"><a href="#Python访问元组元素" class="headerlink" title="Python访问元组元素"></a>Python访问元组元素</h2><p>可以通过元素的下标获取或通过切片操作获取。</p><h2 id="Python修改元组元素"><a href="#Python修改元组元素" class="headerlink" title="Python修改元组元素"></a>Python修改元组元素</h2><p>虽然前面提到元组是不可变序列，但还是可以通过一些手段进行修改元组内的数据。</p><h3 id="重新赋值"><a href="#重新赋值" class="headerlink" title="重新赋值"></a>重新赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_tuple = tuple(range(1,6))</span><br><span class="line">print(test_tuple)</span><br><span class="line">test_tuple = tuple(range(1,20))</span><br><span class="line">print(test_tuple)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1, 2, 3, 4, 5)</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)</span><br></pre></td></tr></table></figure><h3 id="连接多个元组"><a href="#连接多个元组" class="headerlink" title="连接多个元组"></a>连接多个元组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_tuple = tuple(range(1,6))</span><br><span class="line">print(test_tuple)</span><br><span class="line">test_tuple2 = tuple(range(6,11))</span><br><span class="line">test_tuple += test_tuple2</span><br><span class="line">print(test_tuple)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1, 2, 3, 4, 5)</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br></pre></td></tr></table></figure><h2 id="Python删除元组"><a href="#Python删除元组" class="headerlink" title="Python删除元组"></a>Python删除元组</h2><p>若创建的元组不再使用可以使用<code>del</code>语句将其删除。</p><h1 id="Python元组和列表的区别"><a href="#Python元组和列表的区别" class="headerlink" title="Python元组和列表的区别"></a>Python元组和列表的区别</h1><p>本节讨论元组和列表的区别:</p><table><thead><tr><th>区别</th><th>元组</th><th>列表</th></tr></thead><tbody><tr><td>元素是否允许任意修改</td><td>❌</td><td>⭕</td></tr><tr><td>是否能作为map的key</td><td>⭕</td><td>❌</td></tr><tr><td>内存占用小</td><td>⭕</td><td>❌</td></tr></tbody></table><h1 id="Python列表和元组的底层实现"><a href="#Python列表和元组的底层实现" class="headerlink" title="Python列表和元组的底层实现"></a>Python列表和元组的底层实现</h1><p>这里就不记录笔记了，总的来说就是列表是一个长度可变且连续的内存空间，当列表的元素满了后，将会申请更多的内存空间，再将原本的内存空间拷贝过去。而元组则是一个空间带下固定且连续的内存空间。Python对元组进行了优化，例如为了避免系统老是释放和申请内存空间这一繁琐且耗时的操作，所以每次释放元组时其实是将其放入一个缓存中，如果下次还需要申请相同数据的元组，则可以直接从缓存中拿到。</p><p>具体介绍看这里<a href="http://c.biancheng.net/view/5360.html" target="_blank" rel="noopener">💿Python列表和元组的底层实现</a> </p><h1 id="Python-dict字典"><a href="#Python-dict字典" class="headerlink" title="Python dict字典"></a>Python dict字典</h1><p>dict字典属于可变序列，但是无序的序列，其内容是键值对的形式保存的。</p><p>键值对也可以称为映射，所以字典的值与键是互相对应的关系。</p><p>Python字典特征</p><table><thead><tr><th>特征</th><th>解释</th></tr></thead><tbody><tr><td>通过键读取元素</td><td>通过字典中的键来获取指定项，而不是通过索引获取</td></tr><tr><td>字典是任意数据类型的无序集合</td><td>和列表、元组不同，索引值可以通过数字获取对应的元素，而字典中的元素是无序的。</td></tr><tr><td>字典是可变的，并且可以任意嵌套</td><td>字典可以在原处增长或缩短，并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其他字典</td></tr><tr><td>字典中的键必须是唯一的</td><td>字典中不允许出现相同的键，否则只会保留最后一个键值对</td></tr><tr><td>字典中的键必须是不可变的</td><td>字典中的值是不可变的，所以只能使用数字、或元组、字符串等，不能使用可变，例如可变序列：列表</td></tr></tbody></table><p><strong>Python中字典的数据类型为<code>dict</code></strong> </p><h2 id="Python创建字典"><a href="#Python创建字典" class="headerlink" title="Python创建字典"></a>Python创建字典</h2><h3 id="花括号语法创建字典"><a href="#花括号语法创建字典" class="headerlink" title="花括号语法创建字典"></a>花括号语法创建字典</h3><p>字典中每个元素都包含两个部分，分别是键和值。因此在创建字典元素时，需要在键和值之间以冒号<code>:</code>分隔，相邻元素之间使用逗号分隔，所有元素放下大括号<code>{}</code>间。</p><p>语法格式:</p><p><code>dictname = {&#39;key1&#39;:&#39;value&#39;,&quot;key2&quot;:&quot;value&quot;}</code></p><p>其中<code>dictname</code> 代表字典名，<code>key:value</code> 表示各个元素的键值对。</p><p>使用花括号创建字典例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_dict = &#123;&quot;语文&quot;:80,&quot;数学&quot;:12&#125;</span><br><span class="line">print(test_dict)</span><br></pre></td></tr></table></figure><p>输出结果</p><p><code>{&#39;语文&#39;: 80, &#39;数学&#39;: 12}</code></p><h3 id="通过fromkey-方法创建字典"><a href="#通过fromkey-方法创建字典" class="headerlink" title="通过fromkey()方法创建字典"></a>通过fromkey()方法创建字典</h3><p>Python中使用dict字典类型提供的fromkeys()方法创建所有键值为空的字典。</p><p>语法格式</p><p><code>dictname=dict.fromkeys(list,value=None)</code> </p><p>list参数表示字典中键的列表，value参数默认为None，表示所有键对应的值。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">knowledge = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class="line">scores = dict.fromkeys(knowledge,100)</span><br><span class="line">print(scores)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;语文&apos;: 100, &apos;英语&apos;: 100, &apos;数学&apos;: 100&#125;</span><br></pre></td></tr></table></figure><h3 id="通过dict-映射函数创建字典"><a href="#通过dict-映射函数创建字典" class="headerlink" title="通过dict()映射函数创建字典"></a>通过dict()映射函数创建字典</h3><p>dict()函数常用创建字典方法</p><p><img src="/2019/09/08/Python-04-Python列表、元组、字典和集合/dict(" alt="dict()函数创建字典">函数创建字典.png)</p><h2 id="Pyton访问字典"><a href="#Pyton访问字典" class="headerlink" title="Pyton访问字典"></a>Pyton访问字典</h2><p>dict()通过元素的键进行访问值，不能像列表或元组通过下标或切片的形式来访问。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class="line">test_dict = dict(test_dict)</span><br><span class="line">print(type(test_dict))</span><br><span class="line">print(test_dict[&apos;姓名&apos;])</span><br><span class="line">print(test_dict.get(&quot;性别&quot;))</span><br></pre></td></tr></table></figure><h2 id="Python删除字典"><a href="#Python删除字典" class="headerlink" title="Python删除字典"></a>Python删除字典</h2><p>如需手动删除，可以使用del语句。</p><h1 id="Pythton-dict字典基本操作-包括添加、修改、删除键值对"><a href="#Pythton-dict字典基本操作-包括添加、修改、删除键值对" class="headerlink" title="Pythton dict字典基本操作(包括添加、修改、删除键值对)"></a>Pythton dict字典基本操作(包括添加、修改、删除键值对)</h1><p>本小节对字典实现常见的操作:</p><ul><li><p>向字典中添加新的键值对</p></li><li><p>修改字典中的键值对</p></li><li><p>从字典中删除指定的键值对</p></li><li><p>判断字典中是否存在指定的键值对</p></li></ul><h2 id="Python字典添加键值对"><a href="#Python字典添加键值对" class="headerlink" title="Python字典添加键值对"></a>Python字典添加键值对</h2><p>为字典中添加新的键值对只需要为不存在的<code>key</code>赋值。</p><p>语法格式:</p><p><code>dict[key]= value</code> </p><p><code>dict</code>表示字典名称,<code>key</code>代表新建键值对的键,<code>value</code>代表新建键值对的值</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class="line">test_dict = dict(test_dict)</span><br><span class="line">test_dict[&apos;班级&apos;] = 502</span><br><span class="line">print(test_dict.get(&quot;班级&quot;))</span><br></pre></td></tr></table></figure><p>输出结果:</p><p><code>502</code> </p><h2 id="Python字典修改键值对"><a href="#Python字典修改键值对" class="headerlink" title="Python字典修改键值对"></a>Python字典修改键值对</h2><p>这里的修改是指:修改键值对的值。</p><p><strong>Python中如果新添加的键值对的键存在，那么则会覆盖原本的键值对的值</strong> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class="line">test_dict = dict(test_dict)</span><br><span class="line">test_dict[&apos;班级&apos;] = 502</span><br><span class="line">print(test_dict.get(&quot;班级&quot;))</span><br><span class="line">test_dict[&apos;班级&apos;] = 999</span><br><span class="line">print(test_dict.get(&quot;班级&quot;))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">502</span><br><span class="line">999</span><br></pre></td></tr></table></figure><h2 id="Python字典删除键值对"><a href="#Python字典删除键值对" class="headerlink" title="Python字典删除键值对"></a>Python字典删除键值对</h2><p>如果要删除字典中的键值对，则可以使用<code>del</code>语句，指定要删除的键值对的键。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class="line">test_dict = dict(test_dict)</span><br><span class="line">test_dict[&apos;班级&apos;] = 502</span><br><span class="line">print(test_dict.get(&quot;班级&quot;))</span><br><span class="line">del test_dict[&apos;班级&apos;]</span><br><span class="line">print(test_dict.get(&quot;班级&quot;))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">502</span><br><span class="line">None</span><br></pre></td></tr></table></figure><h2 id="判断字典中是否存在指定键值对"><a href="#判断字典中是否存在指定键值对" class="headerlink" title="判断字典中是否存在指定键值对"></a>判断字典中是否存在指定键值对</h2><p>如果需要判断字典是否存在指定键值对的键，可以使用<code>in</code>或<code>not in</code>运算符。</p><p><strong>注意:这里的<code>in</code>或<code>not in</code>运算符都是基于<code>key</code>来判断字典中某个键值对是否存在的.</strong> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])</span><br><span class="line">test_dict = dict(test_dict)</span><br><span class="line">del test_dict[&apos;姓名&apos;]</span><br><span class="line">print(test_dict.get(&quot;姓名&quot;))</span><br><span class="line">print(&apos;姓名&apos; in test_dict)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">None</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h1 id="Python-dict字典方法完全攻略-全"><a href="#Python-dict字典方法完全攻略-全" class="headerlink" title="Python dict字典方法完全攻略(全)"></a>Python dict字典方法完全攻略(全)</h1><p>想查看<code>dict</code>该类包包含哪些方法，可以使用<code>dir()</code>方法进行查看。</p><h2 id="Python-keys-values-和items-方法"><a href="#Python-keys-values-和items-方法" class="headerlink" title="Python keys(),values()和items()方法"></a>Python keys(),values()和items()方法</h2><p>这三个方法可以获取字典中特定的数据.</p><p><code>keys()</code>方法用于返回字典中的所有键;</p><p><code>values()</code>用于返回字典中所有键对应的值;</p><p><code>items()</code>用于返回字典中所有的键值对;</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class="line">test_dict = dict.fromkeys(test_dict,100)</span><br><span class="line">print(test_dict.keys())</span><br><span class="line">print(test_dict.values())</span><br><span class="line">print(test_dict.items())</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict_keys([&apos;英语&apos;, &apos;语文&apos;, &apos;数学&apos;])</span><br><span class="line">dict_values([100, 100, 100])</span><br><span class="line">dict_items([(&apos;英语&apos;, 100), (&apos;语文&apos;, 100), (&apos;数学&apos;, 100)])</span><br></pre></td></tr></table></figure><p><strong>注意:<code>Python2.x</code>中，上面提到的方法的返回值是列表类型。但在<code>Python3.x</code>中，以上方法返回的类型不是序列类型。</strong> </p><h2 id="Python-copy-方法"><a href="#Python-copy-方法" class="headerlink" title="Python copy()方法"></a>Python copy()方法</h2><p><code>copy()</code>方法用于返回一个具有相同键值对的新字典:</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class="line">test_dict = dict.fromkeys(test_dict,100)</span><br><span class="line">test_dict2 = test_dict.copy()</span><br><span class="line">print(test_dict,&quot;\n&quot;,test_dict2)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;数学&apos;: 100&#125;</span><br><span class="line">&#123;&apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;数学&apos;: 100&#125;</span><br></pre></td></tr></table></figure><p><strong>注意Python的copy()方法涉及到<code>深拷贝</code>与<code>浅拷贝</code>的关系，当字典A拷贝键值对给字典B后，那么拷贝的数据(字典B内)将会在字典A对键值对进行修改时发生变化，而字典A添加新的键值对，字典B不收影响。</strong> </p><h2 id="Python-update-方法"><a href="#Python-update-方法" class="headerlink" title="Python update()方法"></a>Python update()方法</h2><p>updae()方法可以使用一个字典所包含的键值对来更新已有的字典。</p><p>如果被更新的字典中已存在对应的键值对，那么原键值对值将会被覆盖，否则将会被添加。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class="line">test_dict = dict.fromkeys(test_dict,100)</span><br><span class="line">test_dict2 = test_dict.copy()</span><br><span class="line">print(type(test_dict))</span><br><span class="line">test_dict[&apos;语文&apos;]=100</span><br><span class="line">test_dict2[&apos;物理&apos;]=200</span><br><span class="line">test_dict2.update(test_dict)</span><br><span class="line">print(test_dict,&quot;\n&quot;,test_dict2)</span><br><span class="line">print(test_dict,&quot;\n&quot;,test_dict2)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;dict&apos;&gt;</span><br><span class="line">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100&#125;</span><br><span class="line">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 200&#125;</span><br><span class="line">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100&#125;</span><br><span class="line">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 200&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-pop方法"><a href="#Python-pop方法" class="headerlink" title="Python pop方法"></a>Python pop方法</h2><p>pop()方法可以获取指定key的value，并删除。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class="line">test_dict = dict.fromkeys(test_dict,100)</span><br><span class="line">print(test_dict.pop(&apos;语文&apos;))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-popitem-方法"><a href="#Python-popitem-方法" class="headerlink" title="Python popitem()方法"></a>Python popitem()方法</h2><p>popitem()方法用于弹出字典中最后一个键值对(这里的最后一个其实是随机的，因为字典是无序序列，所以并不能说的某个键值对的位置取向).</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class="line">test_dict = dict.fromkeys(test_dict,100)</span><br><span class="line">print(test_dict.popitem())</span><br><span class="line">print(test_dict)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&apos;数学&apos;, 100)</span><br><span class="line">&#123;&apos;英语&apos;: 100, &apos;语文&apos;: 100&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-setdefault-方法"><a href="#Python-setdefault-方法" class="headerlink" title="Python setdefault()方法"></a>Python setdefault()方法</h2><p>setdefault()方法用于根据key来获取value，但有两种场景，第一种是，如果获取的键值对的key存在字典中，则会直接获取改键值对的value，不存在则会为该key先将value设置为默认的value，然后再返回该key对应的value。</p><p><strong>特点:setdefault方法总能返回指定key对应的value;</strong></p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;</span><br><span class="line">test_dict = dict.fromkeys(test_dict,100)</span><br><span class="line"># 要设置的键值对的key不存在.</span><br><span class="line">test_dict.setdefault(&apos;物理&apos;,120)</span><br><span class="line">print(test_dict)</span><br><span class="line"># 要设置的键值对的key存在.</span><br><span class="line">test_dict.setdefault(&apos;语文&apos;,200)</span><br><span class="line">print(test_dict)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;数学&apos;: 100, &apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 120&#125;</span><br><span class="line">&#123;&apos;数学&apos;: 100, &apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 120&#125;</span><br></pre></td></tr></table></figure><h1 id="Python使用字典格式化字符串"><a href="#Python使用字典格式化字符串" class="headerlink" title="Python使用字典格式化字符串"></a>Python使用字典格式化字符串</h1><p>我们知道，在格式化字符串时，如果格式化字符串模板中包含多个变量时，则后面月必须按顺序加上相同个数的变量，如果变量过多，则会十分麻烦，Python提供了用字典格式化字符串的方式来解决。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student = &apos;姓名:%(name)s\t班级:%(class)d\t综合成绩:%(score)f&apos;</span><br><span class="line">student_info = &#123;&apos;name&apos;:&apos;LTy&apos;,&apos;class&apos;:604,&apos;score&apos;:99.5&#125;</span><br><span class="line">print(student % student_info)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">姓名:LTy        班级:604        综合成绩:99.500000</span><br></pre></td></tr></table></figure><h1 id="Python-set集合详解"><a href="#Python-set集合详解" class="headerlink" title="Python set集合详解"></a>Python set集合详解</h1><p>set集合的特点:</p><ul><li><p>数据唯一性(必须保证集合中每种数据元素是唯一的)</p></li><li><p>数据不可变(只允许存储不可变的数据类型，例如列表、字典、集合则是不允许存储在集合中的)</p></li><li><p>集合是无序的，所以每次输出元素时，排序顺序可能都不同。</p></li></ul><h2 id="Python创建set集合"><a href="#Python创建set集合" class="headerlink" title="Python创建set集合"></a>Python创建set集合</h2><p>有两种创建<code>set</code>集合的方法，分别是使用{}创建和使用set()函数将列表、元组等数据类型转化为集合。</p><h3 id="使用-创建"><a href="#使用-创建" class="headerlink" title="使用{}创建"></a>使用{}创建</h3><p>语法格式:</p><p><code>setname = {element1,element2...elementn}</code></p><p>setname代表集合的名称。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_set = &#123;1,2,3,4&#125;</span><br><span class="line">print(test_set)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><h3 id="使用set-函数创建集合"><a href="#使用set-函数创建集合" class="headerlink" title="使用set()函数创建集合"></a>使用set()函数创建集合</h3><p>set()函数为Python的内置函数，其可以将字符串、列表、元组以及range对象等可迭代的对象转换成集合。</p><p>语法格式:</p><p><code>setname = set(iteration)</code> </p><p>iteration就表示可迭代的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set1 = set(&quot;I Love China&quot;)</span><br><span class="line">set2 = set(list(range(1,6)))</span><br><span class="line">set3 = set(tuple(range(1,6)))</span><br><span class="line">set4 = set(range(1,6))</span><br><span class="line">print(set1)</span><br><span class="line">print(set2)</span><br><span class="line">print(set3)</span><br><span class="line">print(set4)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 从输出结果看，字符串被打乱了</span><br><span class="line">&#123;&apos;a&apos;, &apos;L&apos;, &apos;h&apos;, &apos; &apos;, &apos;C&apos;, &apos;e&apos;, &apos;n&apos;, &apos;i&apos;, &apos;I&apos;, &apos;v&apos;, &apos;o&apos;&#125;</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:如果想要创建空集合，必须使用<code>set()</code>函数实现，因为如果只给一对<code>{}</code>，Python解释器会将其视为一个空字典。</strong></p><h2 id="Python访问set集合元素"><a href="#Python访问set集合元素" class="headerlink" title="Python访问set集合元素"></a>Python访问set集合元素</h2><p>由于<code>set</code>集合是无序的，所以无法通过下标索引进行访问，但是我们可通过遍历<code>set</code>集合访问元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = set(&quot;I Love China&quot;)</span><br><span class="line"></span><br><span class="line">for ele in set1:</span><br><span class="line">    print(ele,end=&apos;&apos;)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oCenaL Ihvi</span><br></pre></td></tr></table></figure><h2 id="Python删除set集合"><a href="#Python删除set集合" class="headerlink" title="Python删除set集合"></a>Python删除set集合</h2><p>想要手动删除<code>set</code>集合可以使用<code>del()</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = set(&quot;I Love China&quot;)</span><br><span class="line">print(set1)</span><br><span class="line">del(set1)</span><br><span class="line">print(set1)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;a&apos;, &apos;i&apos;, &apos;e&apos;, &apos; &apos;, &apos;L&apos;, &apos;C&apos;, &apos;o&apos;, &apos;h&apos;, &apos;I&apos;, &apos;n&apos;, &apos;v&apos;&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">  │ print(set1)</span><br><span class="line">NameError: name &apos;set1&apos; is not defined</span><br></pre></td></tr></table></figure><h1 id="Python-set集合基本操作-添加、删除、交集、并集、差集"><a href="#Python-set集合基本操作-添加、删除、交集、并集、差集" class="headerlink" title="Python set集合基本操作(添加、删除、交集、并集、差集)"></a>Python set集合基本操作(添加、删除、交集、并集、差集)</h1><p><code>set</code>集合最常用的场景是添加、删除元素以及在多个集合之间做交集、并集、差集等运算。 </p><h2 id="向set集合中添加元素"><a href="#向set集合中添加元素" class="headerlink" title="向set集合中添加元素"></a>向set集合中添加元素</h2><p>Python为<code>set</code>集合提供了<code>add()</code>方法，其可以向<code>set</code>集合添加元素。</p><p>语法格式:</p><p><code>setname.add(element)</code> </p><p>setname表示要添加元素的集合，element代表添加的元素。</p><p><strong>注意:element不可为可变数据类型</strong> </p><h2 id="从set集合中删除元素"><a href="#从set集合中删除元素" class="headerlink" title="从set集合中删除元素"></a>从set集合中删除元素</h2><p>想要从集合中删除某个元素可以使用<code>remove()</code>方法</p><p>语法格式:</p><p><code>setname.remove(element)</code> </p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;1,2,3,4&#125;</span><br><span class="line">print(set1)</span><br><span class="line">set1.remove(1)</span><br><span class="line">print(set1)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">&#123;2, 3, 4&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:如果要删除的元素已经被删除，再次删除则会引发<code>KeyError</code>错误</strong></p><p>如果想要在删除失败时不抛出异常，我们可以使用<code>discard()</code>方法。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;1,2,3,4&#125;</span><br><span class="line">print(set1)</span><br><span class="line">set1.remove(1)</span><br><span class="line">print(set1)</span><br><span class="line">set1.discard(1)</span><br><span class="line">print(set1)</span><br><span class="line">set1.remove(1)</span><br><span class="line">print(set1)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">&#123;2, 3, 4&#125;</span><br><span class="line">&#123;2, 3, 4&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">  │ set1.remove(1)</span><br><span class="line">KeyError: 1</span><br></pre></td></tr></table></figure><p><code>discard()</code>方法与<code>remove()</code>方法的唯一区别在于:<strong>删除失败时是否抛出异常</strong> o</p><h2 id="Python-set集合做交集、并集、差集运算"><a href="#Python-set集合做交集、并集、差集运算" class="headerlink" title="Python set集合做交集、并集、差集运算"></a>Python set集合做交集、并集、差集运算</h2><p><code>set</code>集合最常用的操作也就是进行交集、并集、差集以及对称差集运算了，首先看这张图:</p><p><img src="/2019/09/08/Python-04-Python列表、元组、字典和集合/Python集合示意图.png" alt="集合示意图"> </p><p>图中有两个集合，分别是:</p><ul><li><p><code>set1={1,2,3}</code></p></li><li><p><code>set2={3,4,5}</code></p></li></ul><p>下面的表格展示了不同的运算，得到的不同的结果。</p><p><img src="/2019/09/08/Python-04-Python列表、元组、字典和集合/Python集合运算.png" alt="集合运算图"> </p><h1 id="Python-set集合方法详解-全"><a href="#Python-set集合方法详解-全" class="headerlink" title="Python set集合方法详解(全)"></a>Python set集合方法详解(全)</h1><p>如果想要看<code>set</code>集合所有的方法，可以使用<code>dir(set)</code>进行查看。</p><p>Python set方法</p><table><thead><tr><th>方法名</th><th>语法格式</th><th>功能</th></tr></thead><tbody><tr><td>add()</td><td>set1.add()</td><td>向set1集合中添加非可变元素</td></tr><tr><td>clear()</td><td>set1.clear()</td><td>清空set1集合中所有的元素</td></tr><tr><td>copy()</td><td>set2=set1.copy()</td><td>拷贝set1集合中的元素给set2</td></tr><tr><td>difference()</td><td>set3=set1.difference(set2)</td><td>将set1中有而set2中没有的元素给set3</td></tr><tr><td>difference_update()</td><td>set1.difference_update(set2)</td><td>从set1中删除与set2相同的元素</td></tr><tr><td>discard()</td><td>set1.discard(element)</td><td>删除set1中的element元素</td></tr><tr><td>intersection()</td><td>set3=set1.intersection(set2)</td><td>取set1和set2的交集赋值给set3</td></tr><tr><td>intersection_update()</td><td>set1.intersection_update(set2)</td><td>取set1和set2的交集并且将值赋值给set1(更新set1的值为set1与set2的交集)</td></tr><tr><td>isdisjoint()</td><td>set1.isdisjoint(set2)</td><td>判断set1和set2是否没有交集，有交集返回False;没有则返回True</td></tr><tr><td>issubset()</td><td>set1.issubset(set2)</td><td>判断set1是否是set2的子集</td></tr><tr><td>issuperset()</td><td>set1.issuperset(set2)</td><td>判断set2是否是set1的子集</td></tr><tr><td>pop()</td><td>a = set1.pop()</td><td>取出set1中一个元素并赋值给a</td></tr><tr><td>remove()</td><td>set1.remove(element)</td><td>移除set1中的element元素</td></tr><tr><td>symmetric_difference()</td><td>set3=set1.symmetric_difference(set2)</td><td>取set1和set2中互不相同的元素给set3</td></tr><tr><td>symmetric_difference_update()</td><td>set1.symmetric_difference_update(set2)</td><td>取set1和set2中互不相同的元素并更新set1的值</td></tr><tr><td>union()</td><td>set3=set1.union(set2)</td><td>取set1和set2的并集，赋值给set3</td></tr><tr><td>update()</td><td>set1.update(element)</td><td>添加列表或集合中的元素到set1</td></tr></tbody></table><h1 id="Python-frozenset-set集合的不可变版本"><a href="#Python-frozenset-set集合的不可变版本" class="headerlink" title="Python frozenset(set集合的不可变版本)"></a>Python frozenset(set集合的不可变版本)</h1><p>前面我们所学习的<code>set</code>集合是可变的，而frozenset则是<code>set</code>集合的不可变版本，它不具备<code>set</code>集合的所有能改变集合本身的方法。</p><p>frozenset的主要使用场景:</p><ul><li><p>当集合元素不需要改变的时候，使用frozenset替代set将会更加安全。</p></li><li><p>当某些API需要不可变对象作为参数时，必须用到frozenset替代set。</p></li></ul><h1 id="深入底层了解Python字典和集合、一眼看穿他们的本质"><a href="#深入底层了解Python字典和集合、一眼看穿他们的本质" class="headerlink" title="深入底层了解Python字典和集合、一眼看穿他们的本质"></a>深入底层了解Python字典和集合、一眼看穿他们的本质</h1><p>本小节涉及到未知的知识，推荐去原文看**<a href="http://c.biancheng.net/view/5302.html" target="_blank" rel="noopener">查看原文</a> </p><h1 id="Python深拷贝和浅拷贝详解"><a href="#Python深拷贝和浅拷贝详解" class="headerlink" title="Python深拷贝和浅拷贝详解"></a>Python深拷贝和浅拷贝详解</h1><p>本小节涉及到未知的知识，推荐去原文看<a href="http://c.biancheng.net/view/5358.html" target="_blank" rel="noopener">查看原文</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python系列第四章笔记，查看Python系列所有文章，请点击&lt;a href=&quot;http://c.biancheng.net/python/list_tuple_dict/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;💿&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://evanmeek.github.io/categories/Python/"/>
    
    
      <category term="Python系列" scheme="https://evanmeek.github.io/tags/Python%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>[Python-03]Python变量类型和运算符</title>
    <link href="https://evanmeek.github.io/2019/08/31/Python-03-Python%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://evanmeek.github.io/2019/08/31/Python-03-Python变量类型和运算符/</id>
    <published>2019-08-31T07:03:13.000Z</published>
    <updated>2020-01-22T04:44:27.738Z</updated>
    
    <content type="html"><![CDATA[<p>Python系列第三章笔记，查看Python系列所有文章，请点击<a href="https://evanmeek.github.io/Python/">💿</a><br><a id="more"></a></p><p><strong>本章重点:Python变量数据类型、运算符。</strong></p><p>Python是弱类型语言。</p><p>弱类型含义:</p><ul><li><p>所有变量无需声明即可使用。</p></li><li><p>变量的数据类型随时可变。</p></li></ul><h1 id="Python变量及其使用"><a href="#Python变量及其使用" class="headerlink" title="Python变量及其使用"></a>Python变量及其使用</h1><p>变量:</p><ul><li><p>数据可发生无数次变化。</p></li><li><p>数据类型可发生变化。</p></li></ul><p>常量: 一旦保存数据，则不可修改。</p><p>赋值运算符: <code>=</code></p><p><strong>type()作用:</strong>查看变量的数据类型</p><h1 id="Python数值类型（整型、浮点型和复数）及其用法"><a href="#Python数值类型（整型、浮点型和复数）及其用法" class="headerlink" title="Python数值类型（整型、浮点型和复数）及其用法"></a>Python数值类型（整型、浮点型和复数）及其用法</h1><p>Python中的数值类型都是不可变的。</p><p>有些人可能会问，不是不可变么，为什么我定义的int类型变量的值仍然可以变化，那是因为底层实现将新的值存放到新的一块内存中，然后将修改变量指针的指向。</p><blockquote><p>Python整型</p></blockquote><p>整型是用来表示没有小数部分的数，整数包括：正整数、0、负整数</p><p>Python整型的四种表示形式：</p><ul><li><p>十进制(0-9)</p></li><li><p>二进制(0-1)</p></li><li><p>八进制(0-7)</p></li><li><p>十六进制(0-9-A-F/a-f)</p></li></ul><blockquote><p>Python浮点型</p></blockquote><p>浮点型是用来保存带小数的数值，浮点数包括:十进制形式、科学计数形式。</p><p>十进制形式的写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float_dex = 1.100111</span><br></pre></td></tr></table></figure><p>科学计数形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float2 = 2e3</span><br></pre></td></tr></table></figure><blockquote><p>Python复数</p></blockquote><p>我跳过了本节，如果读者想看，可以点击进行访问<a href="http://c.biancheng.net/view/2173.html" target="_blank" rel="noopener">💿Python复数</a></p><h1 id="Python字符串详解-包含长字符串和原始字符串"><a href="#Python字符串详解-包含长字符串和原始字符串" class="headerlink" title="Python字符串详解(包含长字符串和原始字符串)"></a>Python字符串详解(包含长字符串和原始字符串)</h1><p>Python字符串必须使用引号括起来，可以是单引号也可以是双引号，但必须成对。</p><p>如果字符串内仍然包含引号，可以使用以下两种方法解决:</p><p><strong>用另一种成对的引号包括起来</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;I&apos;m EvanMeek.&quot;</span><br><span class="line"></span><br><span class="line">str2 = &apos;Evan:&quot;Hello World.&quot;&apos;</span><br></pre></td></tr></table></figure><p><strong>用转义字符进行转义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1 = &apos;I\&apos;m EvanMeek&apos;</span><br></pre></td></tr></table></figure><p>转义字符还可以用来转义换行符，应用场景通常是:</p><p><strong>字符串过长，转义换行符，使其不换行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;mac mac macmac mac macmac mac mac \</span><br><span class="line">mac mac macmac mac mac&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>Python长字符串</p></blockquote><p>长字符串常用场景是:</p><p><strong>定义大段文本内容为字符串时</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = &apos;&apos;&apos; &quot;Fuck you ! Bitch!&quot;,said he.</span><br><span class="line">&quot;Mother fuck!&quot;,said she.</span><br></pre></td></tr></table></figure><blockquote><p>Python原始字符串</p></blockquote><p>在Windows下,路径是使用反斜杠作为路径区分的，如果需要将反斜杠转义，那必须再加一个反斜杠，这样非常麻烦，就可以使用下面的案例来解决:</p><p><strong>转义反斜杠写路径</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path = &apos;C:\\User\\Admin\\Desktop&apos;</span><br></pre></td></tr></table></figure><p><strong>使用原始字符串写反斜杠</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path = r&apos;C:\User\Admin\Desktop&apos;</span><br></pre></td></tr></table></figure><p>注意: 原始字符串中的引号同样需要使用<code>\</code>进行转义</p><h1 id="Python-bytes类型及用法"><a href="#Python-bytes类型及用法" class="headerlink" title="Python bytes类型及用法"></a>Python bytes类型及用法</h1><p>bytes类型代表了字节串。</p><p>字节串与字符串不同的是:</p><ul><li><p>字节串是以字节为单位进行操作</p></li><li><p>字节串可直接用于网络通信数据互联</p></li></ul><p>字节串是由多个字节组成的，每个字节由8个bit位组成。</p><p>字节串保存的数据都是二进制格式的数据。</p><p>字节串可以转换成字符串，而字符串也能恢复成字节串。</p><blockquote><p>字节串转换为字符串</p></blockquote><p><strong>创建字节串</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个空的bytes</span><br><span class="line">b1 = bytes()</span><br><span class="line"># 创建一个空的bytes值</span><br><span class="line">b2 = b&apos;&apos;</span><br><span class="line"># 创建一个非空的字节串</span><br><span class="line">b3 = b&apos;hello&apos;</span><br></pre></td></tr></table></figure><p><strong>字符串转换为字节串</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用encode方法将字符串以utf-8字符集转换为字节串</span><br><span class="line">b4 = &quot;I love Python&quot;.encode(&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line"># 创建bytes对象时将字符串的字符集指定为&apos;utf-8&apos;，自动转换为字节串</span><br><span class="line">b5 = bytes(&apos;I love Python&apos;, encoding=&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>字节串转换为字符串</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用字节串对象的方法decode，指定字符集转化字节串</span><br><span class="line">str1 = b&apos;I love Python&apos;.decode(&apos;utf-8&apos;)</span><br></pre></td></tr></table></figure><h1 id="Python-bool布尔类型"><a href="#Python-bool布尔类型" class="headerlink" title="Python bool布尔类型"></a>Python bool布尔类型</h1><p>bool变量只有两个值分别是: True,False。它们都是Python的关键字。</p><p>True代表真</p><p>False代表假</p><p>例如表达式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 &gt; 5</span><br></pre></td></tr></table></figure><p>结果是False</p><p>Python中所有对象都可以进行真假值的测试。</p><h1 id="Python-len-函数详解：获取字符串长度或字节数"><a href="#Python-len-函数详解：获取字符串长度或字节数" class="headerlink" title="Python len()函数详解：获取字符串长度或字节数"></a>Python len()函数详解：获取字符串长度或字节数</h1><p>len()函数是Python内置函数，用于获取字符串或字节串的长度（数量）。</p><p>例子:</p><p><strong>统计字符串的长度</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(len(&quot;Hello World&quot;))</span><br></pre></td></tr></table></figure><p>输出结果: 11</p><p><strong>统计字节串的长度</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(len(&quot;你好世界&quot;.encode()))</span><br></pre></td></tr></table></figure><p>输出结果: 12</p><p>不同的语言所占的字节数不同，并且不同的编码格式所占的字节数也不同。</p><p>例如，汉字使用utf-8编码格式，占用3个字节，中文标点符号使用GBK编码格式占用2个字节。</p><h1 id="Python-input-函数：获取用户输入的字符串"><a href="#Python-input-函数：获取用户输入的字符串" class="headerlink" title="Python input()函数：获取用户输入的字符串"></a>Python input()函数：获取用户输入的字符串</h1><p>input()是Python的内置函数，其作用是输出一段信息然后请求用户输入，并且将获取的值传入接收的对象。</p><p>input()函数将会把用户输入的任何字符都作为字符串读入。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = input(&quot;Please input something:&quot;)</span><br><span class="line">print(type(a))</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please input something &gt; 19</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><p><strong>注意: Python2.x中，要求input()函数读入的内容必须是符合Python语法表达式的。</strong></p><p>例如: 输入字符串时，必须带双引号，否则将会报错。</p><h1 id="Python-print-函数的高级用法"><a href="#Python-print-函数的高级用法" class="headerlink" title="Python print()函数的高级用法"></a>Python print()函数的高级用法</h1><blockquote><p>输出多个参数</p></blockquote><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;EvanMeek&quot;</span><br><span class="line">age = 18</span><br><span class="line">print(&quot;我叫:&quot;, name, &quot;age&quot;, 18)</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我叫: EvanMeek age 18</span><br></pre></td></tr></table></figure><blockquote><p>指定输出多个参数时的分隔符(默认的分割符为空格)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;EvanMeek&quot;</span><br><span class="line">age = 18</span><br><span class="line">print(&quot;我叫:&quot;, name, &quot;age&quot;, 18)</span><br><span class="line">print(&quot;我叫:&quot;, name, &quot;age&quot;, 18, sep=&apos;|&apos;)</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我叫: EvanMeek age 18</span><br><span class="line">我叫:|EvanMeek|age|18</span><br></pre></td></tr></table></figure><blockquote><p>指定结束符(默认结束符为换行符\n)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(10,&apos;\t&apos;,end=&quot;&quot;)</span><br><span class="line">print(11,&apos;\t&apos;,end=&quot;&quot;)</span><br><span class="line">print(12,&apos;\t&apos;,end=&quot;&quot;)</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 11 12</span><br></pre></td></tr></table></figure><blockquote><p>指定输出目标(默认输出为标准输出)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(&quot;test.txt&quot;, &quot;w&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;Just Test&apos;, file = f)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>结果: 将 ‘Just Test’ 写入到 tes.txt文件内</p><h1 id="Python格式化字符串-格式化输出"><a href="#Python格式化字符串-格式化输出" class="headerlink" title="Python格式化字符串(格式化输出)"></a>Python格式化字符串(格式化输出)</h1><p>Python中的格式化字符串可以对各种类型的数据进行格式化输出。</p><p>例子:</p><p><strong>格式化输出整型数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">number = 100</span><br><span class="line">print(&quot;Number is:%s&quot; % number)</span><br></pre></td></tr></table></figure><p>格式化分为三个部分，分别是被包括在双引号内的占位符(<code>%s</code>)、以及中间部分的 格式化分隔符(<code>%</code>)与对应占位符的变量或表达式(<code>number</code>)</p><p><code>%s</code>被称为占位符,又可以说是转换说明符(Conversion Specifier)</p><table><thead><tr><th>转换说明符</th><th>说明</th></tr></thead><tbody><tr><td>%d,%i</td><td>转换为带符号的十进制形式的整数</td></tr><tr><td>%o</td><td>转换为带符号的八进制形式的整数</td></tr><tr><td>%x,%X</td><td>转换为带符号的十六进制形式额整数</td></tr><tr><td>%e</td><td>转换为科学计数法标识的浮点数(e小写)</td></tr><tr><td>%E</td><td>转换为科学计数法标识的浮点数(E大写)</td></tr><tr><td>%f,%F</td><td>转换为十进制形式的浮点数</td></tr><tr><td>%g</td><td>智能选择使用%f或%e格式</td></tr><tr><td>%G</td><td>智能选择使用%F或%E格式</td></tr><tr><td>%c</td><td>格式化字符及其ASCII码</td></tr><tr><td>%r</td><td>使用repr()将变量或表达式转换成字符串</td></tr><tr><td>%s</td><td>使用str()将变量或表达式转换为字符串</td></tr></tbody></table><p>Python允许aaaaqaz123在占位符前添加一个标志用来指定对齐：</p><ul><li><p><code>-</code>(减号) :指定左对齐</p></li><li><p><code>+</code>(加号) : 表示数值总要带着符号.</p></li><li><p><code>0</code>,表示不补充空格，而是补充0。</p></li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;%06d&quot; % num2)</span><br><span class="line"></span><br><span class="line">print(&quot;%+06d&quot; % num2)</span><br><span class="line"></span><br><span class="line">print(&quot;%-6d&quot; % num2)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">000030</span><br><span class="line">+00030</span><br><span class="line">30</span><br></pre></td></tr></table></figure><p>精度值：用于指定小数点后的数字位数，如果是字符串时指定转换后字符串的最大字符数</p><h1 id="Python转义字符及用法"><a href="#Python转义字符及用法" class="headerlink" title="Python转义字符及用法"></a>Python转义字符及用法</h1><p>转义字符是指在指定字符前添加反斜杠<code>\</code>，对特殊的字符进行转义。</p><p>表格请点击此链接查看👉<a href="http://c.biancheng.net/view/2176.html" target="_blank" rel="noopener">💿Python常用/支持的转义字符</a></p><h1 id="Python类型转换，Python数据类型转换函数大全"><a href="#Python类型转换，Python数据类型转换函数大全" class="headerlink" title="Python类型转换，Python数据类型转换函数大全"></a>Python类型转换，Python数据类型转换函数大全</h1><p>Python身为弱类型编程语言，不需要为变量声明数据类型，但在某些场景下，仍然需要进行类型转换，而Python内置了很多常用数据类型的转换函数，请看下表。</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>int(x)</td><td>将x转换成整数类型</td></tr><tr><td>float(x)</td><td>将x转换成浮点数类型</td></tr><tr><td>complex(real,[,imag])</td><td>创建一个复数</td></tr><tr><td>str(x)</td><td>将x转换成字符串</td></tr><tr><td>repr(x)</td><td>将x转换成表达式字符串</td></tr><tr><td>eval(str)</td><td>计算在字符串中的有效Python表达式，并返回一个对象</td></tr><tr><td>chr(x)</td><td>将整数x转换成一个字符</td></tr><tr><td>ord(x)</td><td>将字符x转化成它对应的整数值</td></tr><tr><td>hex(x)</td><td>将一个整数x转换成一个十六进制的字符串</td></tr><tr><td>oct(x)</td><td>将一个整数x转换成一个八进制的字符串</td></tr></tbody></table><p>使用类型转换函数时，被转换的数据必须是有意义的，例如，在使用int()函数时无法将一个费阿拉伯数字的字符串进行转换。</p><h1 id="Python算术运算符及用法详解"><a href="#Python算术运算符及用法详解" class="headerlink" title="Python算术运算符及用法详解"></a>Python算术运算符及用法详解</h1><p>算术运算符用于处理四则运算的符号，在数字的处理中应用得最多。</p><p><img src="/2019/08/31/Python-03-Python变量类型和运算符/Python常用算术运算符.png" alt="Python常用算术运算符"></p><blockquote><p>加法运算符</p></blockquote><p>算术运算例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 20</span><br><span class="line">print(&quot;%d&quot; % (a+b))</span><br></pre></td></tr></table></figure><p>输出:<code>30</code></p><p>字符串拼接例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello = &quot;Hello&quot;</span><br><span class="line">world = &quot;World&quot;</span><br><span class="line">print(&quot;%s&quot; % hello+world)</span><br></pre></td></tr></table></figure><p>输出:<code>HelloWorld</code></p><blockquote><ul><li>减法运算符</li></ul></blockquote><p>减法算术例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a = 10</span><br><span class="line">b = 5</span><br><span class="line">print(&quot;%d&quot; % (10-5))</span><br></pre></td></tr></table></figure><p>输出:<code>5</code></p><p>求负算术例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">a = -a</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出: <code>-10</code></p><blockquote><p>*乘法运算符</p></blockquote><p>乘法算术例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a =10.5</span><br><span class="line">print(a*a)</span><br></pre></td></tr></table></figure><p>输出:<code>110.25</code></p><p>字符串连接例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=&quot;test &quot;</span><br><span class="line">print(str*3)</span><br></pre></td></tr></table></figure><p>输出:<code>test test test</code></p><blockquote><p>/和//除法运算符</p></blockquote><p>普通除法算术例子(除不尽产生小数):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 3</span><br><span class="line">print(a/b)</span><br></pre></td></tr></table></figure><p>输出:<code>3.3333333333333335</code></p><p>整除除法算术例子(除不尽舍去小数):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 3</span><br><span class="line">print(a//b)</span><br></pre></td></tr></table></figure><p>输出:<code>3</code></p><p><strong>注意:Python中不可使用0作为除数，否则会引发<code>ZeroDivisionError</code>错误</strong></p><p><strong>注意:Python2.x中没有整除运算符</strong></p><p>Python2.x的的求整除的规则是:</p><ul><li><p>当两个操作数都是整数时，<code>/</code>作为整除运算符</p></li><li><p>当两个操作数其中一个是浮点数时，<code>/</code>作为非整除运算符</p></li></ul><blockquote><p>%求余运算符</p></blockquote><ul><li><p>Python不需要求余的两个操作数是整数</p></li><li><p>Python不允许求余运算的第二个操作数为0</p></li></ul><p>求余运算例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;10 % 3 = &quot;,(10%3))</span><br><span class="line">print(&quot;10.5 % 3.5 = &quot;,(10.5%3.5))</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 % 3 =  1</span><br><span class="line">10.5 % 3.5 =  0.0</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>若求余运算第二个操作符为负数，那么结果也一定是负数。</li></ul><blockquote><p>**乘方运算符</p></blockquote><p>乘方+开方运算例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;5 的 2 次方：&apos;, 5 ** 2) # 25</span><br><span class="line">print(&apos;4 的 3 次方：&apos;, 4 ** 3) # 64</span><br><span class="line">print(&apos;4 的开平方：&apos;, 4 ** 0.5) # 2.0</span><br><span class="line">print(&apos;27 的开 3 次方：&apos;,27 **(1 / 3 )) # 3.0</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 的 2 次方： 25</span><br><span class="line">4 的 3 次方： 64</span><br><span class="line">4 的开平方： 2.0</span><br><span class="line">27 的开 3 次方： 3.0</span><br></pre></td></tr></table></figure><h1 id="Python赋值运算符（入门必读）"><a href="#Python赋值运算符（入门必读）" class="headerlink" title="Python赋值运算符（入门必读）"></a>Python赋值运算符（入门必读）</h1><p>赋值运算符常用于将运算符右侧的值赋值给左侧的容器。</p><blockquote><p>基本赋值运算符</p></blockquote><p>将赋值运算符右侧的表达式赋值给左侧的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = a</span><br><span class="line">c = a+b</span><br><span class="line">print(a,b,c)</span><br></pre></td></tr></table></figure><p>输出:<code>10 10 20</code></p><blockquote><p>扩展后的赋值运算符</p></blockquote><p><code>=</code>赋值运算符与其他运算符结合后，将成为功能更强大的赋值运算符。</p><p><img src="/2019/08/31/Python-03-Python变量类型和运算符/Python常用赋值运算符.png" alt="Python常用赋值运算符"></p><h1 id="Python位运算符详解"><a href="#Python位运算符详解" class="headerlink" title="Python位运算符详解"></a>Python位运算符详解</h1><p><code>初学者可暂时跳过本章</code></p><p>位运算符通常使用场景是：图形、图像处理、创建设备驱动等底层开发。</p><p>Python位运算符的操作对象为整数类型，它会把数字看做相应的二进制来进行计算。</p><p><img src="/2019/08/31/Python-03-Python变量类型和运算符/Python位运算符.png" alt="python位运算符"></p><blockquote><p>&amp;按位与运算符</p></blockquote><p>有两个操作数</p><p>运算符法则：按位将2个操作数对应的二进制进行一一对应，对应时，只有对应数位都为1时，则结果为0，否则为1。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 5</span><br><span class="line">print(bin(a), bin(b), a &amp; b)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0b1010 0b101 0</span><br></pre></td></tr></table></figure><blockquote><p>|按位或 运算符</p></blockquote><p><code>|</code>是其运算符，具有两个操作数。</p><p>运算符法则：按位将2个操作数对应的二进制进行一一对应，对应时，只有对应数位都为0时，则结果才为0，否则为1。</p><blockquote><p>^按位异或运算符</p></blockquote><p><code>^</code>是其运算符，具有两个操作数。</p><p>运算符法则：按位将两个操作数对应的二进制进行一一对应，对应时，若对应数位都为0或1，则结果为0，否则为1</p><blockquote><p>~按位取反运算符</p></blockquote><p><code>~</code>是其运算符，具有1个操作数</p><p>运算符法则：将其操作数的二进制进行取反，也就是：原本为0的取反为1，原本为1的取反为0.</p><p>其他：原码、反码、补码是什么</p><ul><li><p>原码: 将某数值转换为二进制数，若此数值为正数或0则代表可以是无符号的，那么最高位则不需要一个符号位，若为负数则需要一个符号位。</p></li><li><p>反码: 对原码按位取反，但符号位不变。</p></li><li><p>补码: 负数的补码是其反码+1，正数或0的补码与原码相同。</p></li></ul><blockquote><p>&lt;&lt;左移运算符</p></blockquote><p><code>&lt;&lt;</code>是其运算符，具有两个操作数</p><p>将操作数按补码形式进行整体向左移动。移动后，溢出的丢弃，空出的以0填补。</p><blockquote><p>>> 右移运算符</p></blockquote><p><code>&gt;&gt;</code>是其运算符，具有两个擦作数</p><p>将操作数按补码形式进行整体向右移动。移动后，溢出的丢弃，空出的以符号位填补。。</p><h1 id="Python比较运算符-关系运算符"><a href="#Python比较运算符-关系运算符" class="headerlink" title="Python比较运算符(关系运算符)"></a>Python比较运算符(关系运算符)</h1><p>比较运算符又称为关系运算符，其作用是对各种表达式，容器结果进行大小、真假等比较。如果比较结果为真，则返回True(真)否则返回False(假)。</p><p><img src="/2019/08/31/Python-03-Python变量类型和运算符/Python比较运算符.png" alt="Python比较运算符表"></p><blockquote><p>比较运算符 == 和 is区别</p></blockquote><p>== 比较的是值</p><p>is 比较的所引用对象的地址</p><h1 id="Python逻辑运算符及其用法"><a href="#Python逻辑运算符及其用法" class="headerlink" title="Python逻辑运算符及其用法"></a>Python逻辑运算符及其用法</h1><p>逻辑运算符也是对真假（布尔类型）进行运算符，其返回值也为bool。</p><p><img src="/2019/08/31/Python-03-Python变量类型和运算符/Python逻辑运算符及功能.png" alt="Python比较运算符表"></p><h1 id="Python三目运算符-三元运算符-用法详解"><a href="#Python三目运算符-三元运算符-用法详解" class="headerlink" title="Python三目运算符(三元运算符)用法详解"></a>Python三目运算符(三元运算符)用法详解</h1><p>Python利用if来实现三目运算符的功能。</p><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True_statements if expression else False_statements</span><br></pre></td></tr></table></figure><p>运算法则: 先对<code>expression</code>(表达式)求值，如果为True则执行<code>True_statements</code>否则执行<code>False_statements</code></p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 20</span><br><span class="line">print(&quot;a&gt;b&quot;) if a &gt; b else print(&quot;a&lt;b&quot;)</span><br></pre></td></tr></table></figure><p>结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&lt;b</span><br></pre></td></tr></table></figure></p><p>Python允许在三目运算符的<code>False_statements</code>或<code>True_statements</code>放置多条语句。</p><p>两种放置方式:</p><ul><li><p>以英文逗号隔开，将每条语句执行结果，组成元组。</p></li><li><p>以英文分号隔开，只返回一条语句的结果。 </p></li></ul><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 20</span><br><span class="line"></span><br><span class="line">print(&quot;a&gt;b&quot;) if a &gt; b else (print(&quot;a&lt;b&quot;) if a &lt; b else print(&quot;a=b&quot;))</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b</span><br></pre></td></tr></table></figure><h1 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h1><p>不同的运算符有一个优先级，在用于在表达式中进行区别执行顺序。</p><p><img src="/2019/08/31/Python-03-Python变量类型和运算符/Python运算符优先级.png" alt="Python比较运算符表"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python系列第三章笔记，查看Python系列所有文章，请点击&lt;a href=&quot;https://evanmeek.github.io/Python/&quot;&gt;💿&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://evanmeek.github.io/categories/Python/"/>
    
    
      <category term="Python系列" scheme="https://evanmeek.github.io/tags/Python%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>[Python-02]Python初探</title>
    <link href="https://evanmeek.github.io/2019/08/29/Python-02-Python%E5%88%9D%E6%8E%A2/"/>
    <id>https://evanmeek.github.io/2019/08/29/Python-02-Python初探/</id>
    <published>2019-08-29T03:52:56.000Z</published>
    <updated>2020-01-22T04:44:27.735Z</updated>
    
    <content type="html"><![CDATA[<p>Python系列第二章笔记，查看Python系列所有文章，请点击<a href="https://evanmeek.github.io/Python/">💿</a></p><a id="more"></a><h1 id="Mac安装Python环境"><a href="#Mac安装Python环境" class="headerlink" title="Mac安装Python环境"></a>Mac安装Python环境</h1><p>由于我目前的设备只有一台Mac Book，所以我就只记录Mac安装Python的过程。</p><p>最新的Mac OS X以及集成了Python 2，打开终端(Terminal)输入:<code>python</code>检查是否已安装</p><p><img src="/2019/08/29/Python-02-Python初探/python2运行.png" alt="Python2运行"></p><p>安装Python3可以在这个页面进行下载:<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">💿Python下载页面</a></p><h1 id="python不是内部或外部命令的解决方法"><a href="#python不是内部或外部命令的解决方法" class="headerlink" title="python不是内部或外部命令的解决方法"></a>python不是内部或外部命令的解决方法</h1><p>由于这个问题只有Windows才会出现，所以遇到问题的话，去看下原文吧<a href="http://c.biancheng.net/view/4171.html" target="_blank" rel="noopener">💿点我看原文解决方案</a></p><h1 id="第一个Python程序"><a href="#第一个Python程序" class="headerlink" title="第一个Python程序"></a>第一个Python程序</h1><p>打开终端，输入<code>python3</code>命令，进入交互式解释器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;hello,world!&quot;)</span><br></pre></td></tr></table></figure><p>即可输出包括在双引号之间的字符</p><p>注意点:</p><ul><li><p>小括号与双引号必须在英文半角状态下输入</p></li><li><p>print必须全部为小写</p></li></ul><blockquote><p>文本编辑器编写并执行Python程序</p></blockquote><p>可以使用Vim编辑器编写Python源代码，然后终端中执行</p><p>注意点:</p><ul><li>不要使用Word或Windows的记事本程序编写Python源码，因为这两款软件会为源代码添加隐藏符号，而这些符号不被Python所解释，程序将会报错。</li></ul><h1 id="Python交互式解释器及用法"><a href="#Python交互式解释器及用法" class="headerlink" title="Python交互式解释器及用法"></a>Python交互式解释器及用法</h1><p>交互式解释器是为了让开发者快速学习、则是Python的功能。</p><p>在终端内执行<code>python</code>命令即可打开</p><p><img src="/2019/08/29/Python-02-Python初探/python3运行.png" alt="python3运行"></p><p>其中<code>&gt;&gt;&gt;</code>提示符，我们写的命令都是能被python解释器所执行的Python命令，如果输入的内容没有定义，那么解释器将会报错。</p><h1 id="IDE-集成开发环境-是什么"><a href="#IDE-集成开发环境-是什么" class="headerlink" title="IDE(集成开发环境)是什么"></a>IDE(集成开发环境)是什么</h1><p><code>IDE(Intergreated Development Environment)</code>,用来辅助开发者开发的应用软件。</p><p>集成开发环境是一些列开发工具的组合套装，例如我们编写Python程序，不仅需要解释器，而且还需要一些辅助工具，例如:语言编辑器、自动构建工具、除错器。</p><h1 id="Python-IDE有哪些，哪款适合初学者？"><a href="#Python-IDE有哪些，哪款适合初学者？" class="headerlink" title="Python IDE有哪些，哪款适合初学者？"></a>Python IDE有哪些，哪款适合初学者？</h1><p>首先说明，合适自己的才是最好的。</p><blockquote><p>PyCharm</p></blockquote><p>由JetBrains公司开发的Python开发工具</p><p>优点:</p><ul><li><p>跨平台</p></li><li><p>支持语法高粱、项目代码管理、智能提示、自动完成、调试、单元测试、版本控制等</p></li><li><p>支持Django Web开发框架</p></li><li><p>社区版本免费</p></li></ul><p>缺点:</p><ul><li><p>软件较大，比较重</p></li><li><p>专业版，收费</p></li></ul><blockquote><p>Microsoft Visual Studio</p></blockquote><p>由微软开发用于进行C#和.NET等应用的开发工具，简称VS。</p><p>要让VS支持Python，需要安装<code>PTVS</code>插件。</p><p>优点:</p><ul><li><p>PTVS插件开源</p></li><li><p>支持编辑、浏览、智能感知、混合Python/C++调试、Django</p></li></ul><p>缺点:</p><ul><li><p>不跨平台，只支持Windows</p></li><li><p>软件较大，比较重</p></li><li><p>非学生收费</p></li></ul><h1 id="Python-IDLE使用方法详解"><a href="#Python-IDLE使用方法详解" class="headerlink" title="Python IDLE使用方法详解"></a>Python IDLE使用方法详解</h1><p>由于本人不使用IDLE作为我的Python开发工具，所以这里就不提了。</p><p>想了解的，看原文<a href="http://c.biancheng.net/view/4221.html" target="_blank" rel="noopener">💿点击查看原文</a></p><h1 id="Python注释-多行注释和单行注释"><a href="#Python注释-多行注释和单行注释" class="headerlink" title="Python注释(多行注释和单行注释)"></a>Python注释(多行注释和单行注释)</h1><p>注释是写给人看的，是用来用自然语言解释代码给开发者看的。</p><p>注释不被解释器所执行。</p><p>Python允许在任何地方差人注释和字符串，除了在标志符和字符串之间。</p><p>Python中有三种注释分别是:</p><blockquote><p>单行注释</p></blockquote><p>语法格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 注释内容</span><br></pre></td></tr></table></figure></p><p>单行注释所在位置可以是代码的上一行，可以是当前行的末尾。</p><blockquote><p>Python多行注释</p></blockquote><p>语法格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">注释内容</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>多行注释使用三个成对的<code>单引号</code>或三个成对的<code>双引号</code>作为多行注释块</p><p>通常用法: 为Python文件、模块、类或者函数等添加版权、功能描述等信息。</p><p>注意事项: 若多行注释作为语句的一部分(在语句中)将不会被认为是多行注释，而是Python字符串的标志。</p><blockquote><p>Python中文编码声明注释</p></blockquote><p>在Python2.x中，不支持在源码中直接写中文。所以如果需要加入中文，必须在行首加上以下注释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br></pre></td></tr></table></figure><p>Python3.x不需要</p><h1 id="Python缩进规则-包含快捷键"><a href="#Python缩进规则-包含快捷键" class="headerlink" title="Python缩进规则(包含快捷键)"></a>Python缩进规则(包含快捷键)</h1><p>Python采用代码缩进和冒号来区分代码块之间的层次</p><p>在Python中，类定义、函数定义、流程控制语句、异常处理语句等，行位的冒号代表代码块的开始，而同一个代码块内部代码的缩紧格式必须相同（不然Python不能知道当前代码块何时结束)，否则会出现SyntaxError</p><h1 id="Python编码规范"><a href="#Python编码规范" class="headerlink" title="Python编码规范"></a>Python编码规范</h1><p>这里所提到的规范都是PEP8所定义的。</p><p>需要严格遵守的代码编写规范:</p><ul><li>每个import语句只导入一个模块</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 推荐</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># 避免</span><br><span class="line">import os sys</span><br></pre></td></tr></table></figure><ul><li>不在行尾添加分号，一行只放一条语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 避免</span><br><span class="line">height = float(input(&quot;input height:&quot;)); weight=float(input(&quot;input weight&quot;));</span><br></pre></td></tr></table></figure><ul><li>单行不超过80个字符，如果超过可以使用小括号将多行内容隐式的连接。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 推荐</span><br><span class="line">text=(&quot;aaaaaaaaaaaaaaaaaaaaaaaa&quot;</span><br><span class="line">&quot;bbbbbbbbb&quot;)</span><br></pre></td></tr></table></figure><ul><li><p>适当使用空行，增加代码可读性</p></li><li><p>适当使用空格分隔运算符之间，函数之间，以及逗号两侧。</p></li></ul><p><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">💿PEP 8官方介绍</a></p><h1 id="Python标识符命名规范"><a href="#Python标识符命名规范" class="headerlink" title="Python标识符命名规范"></a>Python标识符命名规范</h1><p>Python标识符规范:</p><ul><li><p>由字母、下划线、数字组成，但首字符不能为数字。</p></li><li><p>不能与Python内置的关键字相同，例如我们前面提到的import就是Python关键字。</p></li><li><p>Python中，标识符的命名区分字母大小写。</p></li><li><p>Python的标识符前后具有下划线代表由特殊意义。</p></li></ul><p>推荐命名规范(不遵守此规范程序不会无法运行，但这基本是行业标准):</p><ul><li><p>标识模块名时，尽量短小，由下划线分割标识符单词。</p></li><li><p>标识包名时，尽量短小，由英文句号作为分割。</p></li><li><p>标识类名时，单词首字母大写。</p></li><li><p>函数名、类属性，方法名，使用小写，多个单词之间使用下划线</p></li></ul><h1 id="编码规范的重要性"><a href="#编码规范的重要性" class="headerlink" title="编码规范的重要性"></a>编码规范的重要性</h1><p>编码的规范是为了提高开发效率。</p><p>我们编码时需要遵守准则: 阅读者 &gt; 编程者 &gt; 机器</p><h1 id="Python关键字-保留字"><a href="#Python关键字-保留字" class="headerlink" title="Python关键字(保留字)"></a>Python关键字(保留字)</h1><p>Python关键字是Python内置的单词，其被赋予特殊的意义。</p><p>所有的关键字表如下:</p><table><thead><tr><th>关键字表</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>and</td><td>as</td><td>assert</td><td>break</td><td>class</td><td>continue</td></tr><tr><td>def</td><td>del</td><td>elif</td><td>else</td><td>except</td><td>finally</td></tr><tr><td>for</td><td>from</td><td>False</td><td>globl</td><td>if</td><td>import</td></tr><tr><td>in</td><td>is</td><td>lambda</td><td>nonlocal</td><td>not</td><td>None</td></tr><tr><td>or</td><td>pass</td><td>raise</td><td>return</td><td>try</td><td>True</td></tr><tr><td>while</td><td>with</td><td>yield</td></tr></tbody></table><h1 id="Python内置函数"><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h1><p>Python具有内置函数，可由开发者直接调用。</p><p>有关内置函数的用法和解释可由访问[💿Python内置函数]进行查看.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python系列第二章笔记，查看Python系列所有文章，请点击&lt;a href=&quot;https://evanmeek.github.io/Python/&quot;&gt;💿&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://evanmeek.github.io/categories/Python/"/>
    
    
      <category term="Python系列" scheme="https://evanmeek.github.io/tags/Python%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>[Python-01]Python教程基础</title>
    <link href="https://evanmeek.github.io/2019/08/29/Python-01-Python%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://evanmeek.github.io/2019/08/29/Python-01-Python教程基础/</id>
    <published>2019-08-28T16:25:46.000Z</published>
    <updated>2020-01-22T04:44:27.731Z</updated>
    
    <content type="html"><![CDATA[<p>Python系列第一章笔记，查看Python系列所有文章,请点击 <a href="https://evanmeek.github.io/Python/">💿</a><br><a id="more"></a></p><h1 id="编程语言是什么"><a href="#编程语言是什么" class="headerlink" title="编程语言是什么"></a>编程语言是什么</h1><p>编程语言中的每个结构，都有固定的使用格式（称之为<code>语法</code>)以及精确的含义（称之为<code>语义</code>）。</p><p>编程语言也分等级，例如C、C++、Java、Ruby等可以称为高级语言，而计算机<code>硬件</code>只能理解一种非常低级的编程语言，<code>机器语言</code>。</p><h1 id="解释型语言和编译型语言（两者区别）"><a href="#解释型语言和编译型语言（两者区别）" class="headerlink" title="解释型语言和编译型语言（两者区别）"></a>解释型语言和编译型语言（两者区别）</h1><blockquote><p>编译型语言</p></blockquote><p>编译型语言是指使用专门的编译器，对特定的操作系统（平台）将源代码一次性“翻译”为可被该操作系统（平台）硬件所执行的机器语言。</p><p>优点：</p><ul><li>编译好后的可执行文件，可以在没有编译器的机器上独立运行。</li><li>程序执行速度快</li></ul><p>缺点：</p><ul><li>跨平台不友好(如果是不同的平台，需要将源代码在特定的平台重新编译，甚至需要修改代码)</li></ul><blockquote><p>解释型语言</p></blockquote><p>解释型语言由解释器完成将源代码转换成机器语言，在任何平台上必须安装解释器才可以运行，而不同的平台只需要安装解释器，代码不需要修改也可以被解释。</p><p>优点：</p><ul><li>跨平台友好</li></ul><p>缺点：</p><ul><li>执行速度慢</li></ul><h1 id="Python是什么，Python简介"><a href="#Python是什么，Python简介" class="headerlink" title="Python是什么，Python简介"></a>Python是什么，Python简介</h1><blockquote><p>Python历史</p></blockquote><p>1989年，荷兰人<code>Guido van Rossum</code> 创造了Python.</p><p><code>Python</code>最初基于<code>ABC</code>教学语言.</p><blockquote><p>Python简介</p></blockquote><p><code>Python</code>可以和其他语言，如C、C++、Java的模块（方法/函数）轻松的结合在一起，因此<code>Python</code>又被称为“胶水”语言。</p><blockquote><p>Python的设计哲学</p></blockquote><p>优雅、明确、简单。</p><p>有些人说：“人生苦短，我用Python”</p><h1 id="Python的特点（优点和缺点）"><a href="#Python的特点（优点和缺点）" class="headerlink" title="Python的特点（优点和缺点）"></a>Python的特点（优点和缺点）</h1><blockquote><p>简单易学</p></blockquote><p>Python虽然语法格式要求严格，但是语法却很简洁。</p><blockquote><p>开源</p></blockquote><p>Python是开源的，使用Python编写的程序可以做商业用途也不用付费，并且可以让第三方开发者为Python开发提供优秀的功能。</p><blockquote><p>高级语言</p></blockquote><p>在使用Python编写程序时，开发者无需考虑底层细节问题，而专注于编写程序。</p><blockquote><p>解释型语言</p></blockquote><p>可移植性优秀</p><blockquote><p>面向对象</p></blockquote><p>Python既支持面向过程编程，也支持面向对象编程。</p><blockquote><p>强大的功能</p></blockquote><p>Python可以从简单的字符串处理到复杂的3D图形编程，这些借助Python的扩展模块可以轻松完成。</p><blockquote><p>可扩展性</p></blockquote><p>Python具有脚本语言中最丰富和强大的类库，不管是I/O、GUI、网络编程、数据库编程等绝大部应用场景，都可以使用Python内置的类库完成。</p><p>Python可以使用C或C++编写的代码，这样可以一定程度上的弥补执行速度慢的缺点。</p><blockquote><p>缺点</p></blockquote><p>速度慢，相比Java、C、C++编写的程序，运行效率都要慢。<br>源代码加密困难，由于是解释型语言，不像编译型语言那样会被编译成各种目标程序，所以加密困难。</p><h1 id="学Python，不需要有编程基础"><a href="#学Python，不需要有编程基础" class="headerlink" title="学Python，不需要有编程基础"></a>学Python，不需要有编程基础</h1><p>Python语法简明易懂，不像C++或C语言等语法复杂，并且在学习Python中也不需要太过于专注底层的细节，很多事情解释器都已经帮忙做好了。所以对于零基础的初学者来说，Python非常合适。</p><h1 id="Python能干什么，Python的应用领域"><a href="#Python能干什么，Python的应用领域" class="headerlink" title="Python能干什么，Python的应用领域"></a>Python能干什么，Python的应用领域</h1><blockquote><p>Web应用开发</p></blockquote><p>Python可以通过一些模块，使Python具备HTTP服务器与Python的Web程序之间的通信。</p><p>全球最大的搜索引擎<code>Google</code>，在其搜索系统中就大量的使用Python。</p><p><code>豆瓣</code>也是由Python编写的。</p><blockquote><p>操作系统管理、自动化运维开发</p></blockquote><p>大部分操作系统中，Python都作为标准的系统组件，例如大多数Linux发行版，BSD系、Mac OS X都集成了Python。</p><p>并且相对于Shell脚本来说，无论是可读性、性能、代码重用度以及扩展性方面都要优秀很多。</p><blockquote><p>游戏开发</p></blockquote><p>虽说Python的运行效率不算快，但很多游戏可以用C++编写高性能模块，而用Pyton编写游戏的逻辑。</p><p>例如，<code>文明</code>这款游戏就是使用Python实现的。</p><blockquote><p>编写服务器软件</p></blockquote><p>由于Python对各种网络协议的支持完善，所以经常被用于编写服务器软件以及网络爬虫。</p><blockquote><p>科学计算</p></blockquote><p>Python内置了很多工具，可以让科研人员编写科学计算程序。</p><h1 id="怎样学习Python，才能成为Python高手？"><a href="#怎样学习Python，才能成为Python高手？" class="headerlink" title="怎样学习Python，才能成为Python高手？"></a>怎样学习Python，才能成为Python高手？</h1><blockquote><p>编程语言都是相通的</p></blockquote><p>如果你具备一定的编程基础，接触一门新的编程语言时会发现，不同的编程语言其实是相通的，大多数不同的地方在于语法规则。</p><blockquote><p>Python对初学者友好</p></blockquote><ul><li><p>多实践、积累代码量</p><p>任何编程语言知识都是大量的，如果不在学习编程时就开始练习，那么可能当你学完素有的语法后，却把前面的知识忘得一干二净。</p><p>所以，学习编程，需要多写代码，没有途径可走。</p></li><li><p>时刻注意代码规范</p><p>在我们学习时，一定要养成良好的编程习惯，例如适当的编写注释，定义变量名称时不要随意使用无意义的字符。</p></li><li><p>开发经验必不可少</p></li></ul><p>当你熟练的掌握一门编程语言的语法时，你还需要大中型产品的开发经验，它会让你学得更多，简而言之站得更高，看得更远。</p><p><img src="/2019/08/29/Python-01-Python教程基础/Python知识体系框架.png" alt="Python知识体系图"></p><h1 id="Python-2-x和Python-3-x，初学者应该如何选择？"><a href="#Python-2-x和Python-3-x，初学者应该如何选择？" class="headerlink" title="Python 2.x和Python 3.x，初学者应该如何选择？"></a>Python 2.x和Python 3.x，初学者应该如何选择？</h1><p>推荐选择Python 3.x，因为Python将在2020不再更新Python 2.x，并且Python 3.x比Python 2.x 具有更多的特性与功能。</p><p>这里只是推荐，详细看Python3和Python2的区别可以看这本:<a href="http://c.biancheng.net/view/4147.html" target="_blank" rel="noopener">📖《Python3和Python2的区别》</a></p><h1 id="Python版本区别，Python3和Python2区别详解"><a href="#Python版本区别，Python3和Python2区别详解" class="headerlink" title="Python版本区别，Python3和Python2区别详解"></a>Python版本区别，Python3和Python2区别详解</h1><p>学习完基础再来…暂时未编写😅</p><p>不过可以知道的是，Python3相比与Python2在<code>语句输出、编码、运算和异常等</code>方面做出了调整。</p><h1 id="Python2to3-自动将Python2-x代码转换成Python3-x代码"><a href="#Python2to3-自动将Python2-x代码转换成Python3-x代码" class="headerlink" title="Python2to3 自动将Python2.x代码转换成Python3.x代码"></a>Python2to3 自动将Python2.x代码转换成Python3.x代码</h1><p>学习完基础再来…暂时未编写😅</p><p>学完完基础再来…暂时未编写</p><h1 id="Python-PEP-及时追踪Python最新变化"><a href="#Python-PEP-及时追踪Python最新变化" class="headerlink" title="Python PEP 及时追踪Python最新变化"></a>Python PEP 及时追踪Python最新变化</h1><p>为了追踪Python的更新动态，我们需要借助Python PEP 文档</p><blockquote><p>Python PEP文档</p></blockquote><p>Python语法修改方案是由<code>邮件列表</code>的形式进行讨论，但Python的PEP文档发布了，新的变化才会生效。</p><p><code>PEP(Python Enhancement Proposal)</code>，中译为<code>Python改进方案</code>。它主要由三个用途</p><ul><li><p>通知: 汇总Python核心开发者重要信息</p></li><li><p>标准化: 提供代码风格，文档或者其他指导意见</p></li><li><p>设计: 对提交的新功能进行说明</p></li></ul><p>如果想要查看提交的<code>PEP</code>历史，可以点击这里:<a href="https://www.python.org/dev/peps/" target="_blank" rel="noopener">PEP0文档</a></p><h1 id="Python底层是用什么语言实现的"><a href="#Python底层是用什么语言实现的" class="headerlink" title="Python底层是用什么语言实现的"></a>Python底层是用什么语言实现的</h1><p>大多数讨论的Python，所指的是CPython，它是用C语言编写的。</p><p>不仅有用C语言编写的Python也有用其他语法编写的Python。</p><p>不同语言实现Python的的原因，大部分是为了解决某些实际问题而创建的，例如：</p><ul><li><p>在嵌入式系统中运行Python代码</p></li><li><p>在运行框架(Java/.NET)或其他语言做代码集成。</p></li><li><p>在Web浏览器中运行Python代码</p></li></ul><p>以上所述使用CPython需要花费开发者大量精力也很难实现，所以才有了各种实现方式的Python.</p><blockquote><p>Stackless Python</p></blockquote><p><code>Stackless Python</code>自称为Python增强版，它没有依赖C语言的调用栈。</p><p>其新添加的功能最重要的是:解释器管理的微线程</p><p>支持版本是2.7.9和3.3.5，Stackless Python的所有额外功能都是内置stackiess模块内的框架。</p><blockquote><p>JPython</p></blockquote><p>由Java实现的Python。它将代码编译为Java字节码，开发者可以在Pyton模块中无缝使用Java类</p><p>JPython与CPython的主要区别:</p><ul><li><p>真正的Java垃圾回收机制</p></li><li><p>没有<code>全局解释器锁(GlobalInterpreter Lock,GIL)</code>，在多线程应用中可以充分利用多个内核</p></li></ul><p>支持版本: 2.7</p><p>缺点: 缺少对C/Python扩展API的支持，预计JPython3.x支持C/Python扩展API</p><blockquote><p>IronPython</p></blockquote><p>IronPython将Python引入至.NET框架中。</p><p>支持版本: 2.7.5</p><p>缺点: 类似JPython</p><p>相比于CPython的优点:</p><ul><li><p>没有全局解释器锁</p></li><li><p>用.NET语言家族编写的代码可以轻松集成到IronPython中，反之亦然。</p></li><li><p>通过<code>Silverlight</code>，在所有主流Web浏览器中都可运行。</p></li></ul><blockquote><p>PyPy</p></blockquote><p>社区内呼声最高的Python实现，它是由Python重写的Python。</p><p>支持版本: 2.7完全兼容,PyPy3与3.25完全兼容</p><p>PyPy与CPython实现的主要区别:</p><ul><li><p>使用垃圾回收</p></li><li><p>集成跟踪JIT编译器，可以提高性能</p></li><li><p>借鉴Stackless Python在应用层的无栈特性。</p></li></ul><p>缺点: 对C/Python扩展API不完善，但为CPyExt子系统C扩展提供了某种程度的支持。</p><h1 id="了解Jupyter-Notebook，你已然超越了90-的Python程序员"><a href="#了解Jupyter-Notebook，你已然超越了90-的Python程序员" class="headerlink" title="了解Jupyter Notebook，你已然超越了90%的Python程序员"></a>了解Jupyter Notebook，你已然超越了90%的Python程序员</h1><p>简单介绍下，Jupyter Notebook就是个整合了代码、计算输出、解释文档、多媒体资源的多功能科学运行平台。</p><p>去看原文吧，这个知道有这个东西，以后再去学习。</p><p><a href="http://c.biancheng.net/view/5279.html" target="_blank" rel="noopener">💿原文传送门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python系列第一章笔记，查看Python系列所有文章,请点击 &lt;a href=&quot;https://evanmeek.github.io/Python/&quot;&gt;💿&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://evanmeek.github.io/categories/Python/"/>
    
    
      <category term="Python系列" scheme="https://evanmeek.github.io/tags/Python%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装Rust</title>
    <link href="https://evanmeek.github.io/2019/08/20/Mac%E4%B8%8B%E5%AE%89%E8%A3%85Rust/"/>
    <id>https://evanmeek.github.io/2019/08/20/Mac下安装Rust/</id>
    <published>2019-08-19T18:30:40.000Z</published>
    <updated>2020-01-22T04:44:27.715Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章记录了我是如何在Mac下安装rust的过程.</p><a id="more"></a><p>首先在你Shell的配置文件内加入下面两行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static</span><br><span class="line">export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup</span><br></pre></td></tr></table></figure><p>然后打开终端，输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure><p>中间稍微等待一下，选择安装的方式即可。</p><p>安装好后记得执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source $HOME/.cargo/env</span><br></pre></td></tr></table></figure><p>最后再编辑$HOME/.cargo/config文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[registry]</span><br><span class="line">index = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;</span><br><span class="line">[source.crates-io]</span><br><span class="line">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class="line">replace-with = &apos;ustc&apos;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;</span><br></pre></td></tr></table></figure><p>就大功告成啦，赶快写一个HelloWorld吧!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章记录了我是如何在Mac下安装rust的过程.&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://evanmeek.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Rust" scheme="https://evanmeek.github.io/tags/Rust/"/>
    
  </entry>
  
</feed>
