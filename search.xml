<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux下连接蓝牙]]></title>
    <url>%2F2020%2F02%2F09%2FLinux%E4%B8%8B%E8%BF%9E%E6%8E%A5%E8%93%9D%E7%89%99%2F</url>
    <content type="text"><![CDATA[Linux下连接蓝牙设备的方式 准备事项必备软件如果是你Arch用户，你可以直接: 1&gt; pacman -S bluez bluz-utils pulseaudio-bluetooth pavucontrol 其中: bluez包是提供蓝牙的协议栈 bluez-utils包含了各式各样的工具 pulseaudio-bluetooth为提供音频服务器 pavucontrol 音频服务的图形化控制软件 启动蓝牙服务12&gt; systemctl enable bluetooth&gt; systemctl start bluetooth 启动音频服务12&gt; pulseaudio -k # 确保没有pulseaudio启动&gt; pulseaudio --start # 启动pulseaudio服务 将当前用户添加到lp用户组1&gt; sudo usermo -a -G lp $USER 连接蓝牙这里以连接我耳机来举例 使用bluetoothctl命令，开始连接: 键入power on打开控制电源器 键入scan on扫描附近的蓝牙设备 键入scan off关闭扫描（如果扫描出来你的设备再关闭） 键入devices命令可以查看已经扫描过的设备 键入agent on打开代理 键入pair $MAC进行配对（如果是陌生设备才需要配对，$MAC代表了MAC地址，支持Tab补全) 键入trust $MAC 如果你的设备是无PIN码的，可以这样手动认证。 键入connect $MAC连接设备 下面为一个实例: 1234567891011121314151617181920212223242526272829303132[bluetooth]# power on[CHG] Controller 84:C5:A6:00:59:64 Class: 0x001c010cChanging power on succeeded[CHG] Controller 84:C5:A6:00:59:64 Powered: yes[bluetooth]# scan onDiscovery started[CHG] Controller 84:C5:A6:00:59:64 Discovering: yes[NEW] Device 67:68:09:5E:69:C8 67-68-09-5E-69-C8[NEW] Device 60:21:6D:9E:D9:E8 60-21-6D-9E-D9-E8[bluetooth]# scan off[CHG] Device 60:21:6D:9E:D9:E8 TxPower is nil[CHG] Device 60:21:6D:9E:D9:E8 RSSI is nil[CHG] Device 67:68:09:5E:69:C8 RSSI is nil[CHG] Controller 84:C5:A6:00:59:64 Discovering: noDiscovery stopped[bluetooth]# devices Device E8:29:58:44:FE:D6 mobikeDevice E0:DC:FF:DC:5A:88 我永远喜欢LinuxDevice 94:BF:2D:90:7C:F9 EvanMeek的 Beats Studio³Device 74:40:BB:C4:04:D4 74-40-BB-C4-04-D4Device 67:68:09:5E:69:C8 67-68-09-5E-69-C8Device 60:21:6D:9E:D9:E8 60-21-6D-9E-D9-E8[bluetooth]# agent onAgent is already registered[bluetooth]# pair 94:BF:2D:90:7C:F9 Attempting to pair with 94:BF:2D:90:7C:F9[bluetooth]# connect 94:BF:2D:90:7C:F9 Attempting to connect to 94:BF:2D:90:7C:F9[CHG] Device 94:BF:2D:90:7C:F9 Connected: yesConnection successful[CHG] Device 94:BF:2D:90:7C:F9 ServicesResolved: yes[EvanMeek的 Beats Studio³]# 本文参考ArchLinux Bluetooth Wiki暗无天日的博客]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《十年》]]></title>
    <url>%2F2020%2F02%2F05%2F%E3%80%8A%E5%8D%81%E5%B9%B4%E3%80%8B%2F</url>
    <content type="text"><![CDATA[送給那個她 如果那兩個字沒有顫抖我不會發現 我難受怎麼說出口 也不過是分手如果對於明天沒有要求牽牽手就像旅遊成千上萬個門口 總有一個人要先走懷抱既然不能逗留何不在離開的時候一邊享受 一邊淚流十年之前我不認識你 你不屬於我我們還是一樣 陪在一個陌生人左右走過漸漸熟悉的街頭十年之後我們是朋友 還可以問候只是那種溫柔 再也找不到擁抱的理由情人最後難免淪爲 朋友直到和你做了多年朋友才明白我的眼淚不是爲你而流 也爲別人而流]]></content>
      <categories>
        <category>個人感想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解決Linux下Minecraft無法輸入中文的問題]]></title>
    <url>%2F2020%2F01%2F31%2F%E8%A7%A3%E6%B1%BALinux%E4%B8%8BMinecraft%E7%84%A1%E6%B3%95%E8%BC%B8%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E5%95%8F%E9%A1%8C%2F</url>
    <content type="text"><![CDATA[本篇文章解決Linux下Minecraft無法輸入中文的問題. 廢話自從我用Linux開始，玩得最多的遊戲是Minecraft，可是Minecraft在Linux下無法使用輸入法，這讓我這個國內的玩家十分憋屈，單人遊戲還好，聯機時不能交流就比較憋屈了。 網上流傳着一些腳本可以使得使用腳本時跳出一個輸入框，然後自動複製輸入的內容，並且關閉輸入框，可是這樣十分麻煩，並且像Minecraft中的木牌等物品是無法粘貼的，所以腳本也是有侷限性的。 今天無意中看到一個Mods，貌似是專門解決Linux用戶無法輸入中文的情況，那麼下面就讓我們開始解決這個問題吧！ 正題僅支持1.12.2帶有forge的Minecraft 下載由Yesterday17開發的KokoaLinux模組，然後將這個模組丟到mods目錄下啓動遊戲即可。 效果圖]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Doom Emacs Tramp Sending卡死问题]]></title>
    <url>%2F2020%2F01%2F22%2FDoom-Emacs-Tramp-Sending%E5%8D%A1%E6%AD%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在使用DoomEmacshttps://github.com/bbatsov/prelude/issues/594的 sudo-thin-file函数时出现不能输入密码的解决方案。 遇到的问题 使用 sudo-this-file函数出现: 1Tramp: Sending Password 原因原因是因为projectile占用了minibuffer，当Tramp试图请求输入密码时就会出现问题。 解决方案我在这个Issue找到的解决方案 我是在Domm Emacs的config.el里加上下面代码: 12(projectile-global-mode)(set projectile-mode-line &quot; Projectile&quot;) TG群里的Citreu还说可以设置~/.authinfo解决，这样好像更加安全。]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProxyChains入门使用教程]]></title>
    <url>%2F2020%2F01%2F07%2FProxyChains%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[身为天朝的一名开发者，fq已经成为必备技能了。ProxyChains就是一个强大的强制代理工具。 ArchLinuxArch下直接安装ProxyChains-ng这个包即可。 1sudo pacman -S proxychains-ng 安装好后编辑/etc/proxychains.conf。 找到最下面的[ProxyList]，往里面添加映射的类型，例如我想要http协议走代理就可以这么写。 123456[ProxyList]# add proxy here ...# meanwile# defaults set to &quot;tor&quot;http 127.0.0.1 8000# socks5 127.0.0.1 1080 使用非常简单，可以直接在需要走代理的程序前加上proxychains即可。 1234567891011➜ ~ proxychains curl google.com[proxychains] config file found: /etc/proxychains.conf[proxychains] preloading /usr/lib/libproxychains4.so[proxychains] DLL init: proxychains-ng 4.14[proxychains] Strict chain ... 127.0.0.1:8000 ... google.com:80 ... OK&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;301 Moved&lt;/H1&gt;The document has moved&lt;A HREF="http://www.google.com/"&gt;here&lt;/A&gt;.&lt;/BODY&gt;&lt;/HTML&gt; 如果闲命令太长可以写一个alias，在这里就不演示了。 MacOS如果你使用包管理器，例如homebrew可以直接执行: 1&gt; brew install proxychains-ng 但是会很慢，所以有第二种方式————手动编译安装。 1234&gt; git clone --depth 1 git@github.com:rofl0r/proxychains-ng&gt; cd proxychains-ng &amp;&amp; ./configure --prfix=/usr --sysconfdir=/etc&gt; make &amp;&amp; make install&gt; sudo make install-config # 生成proxychains.conf配置文件 这里可能会有一个坑————执行make install出错，想要解决很简单： 进入configure目录，修改config.mak文件，将bindir=/usr/bin改为bindir=/usr/local/bin 就算你安装好，并且配置好文件后可能照样不能使用，这一切都是因为苹果电脑的SIP保护系统，有关SIP的信息自己谷歌一下，再考虑要不要关闭。 关闭分两种，一种是让SIP进入debug模式，再一种就是永久关闭（除非手动启动）。 首先重启Mac，在重启时按住option键，进入选择启动磁盘项，然后按组合键Command+R即可进入恢复模式，进入恢复模式后先验证密码，然后在顶栏找到实用工具的终端,再看下一步吧。 debug模式 1&gt; csrutil enable --without debug 永久关闭 1&gt; csrutil disable 进行设置了后重启打开终端输入csrutil status，如果显示System Integrity Protection status:disbaled则说明关闭成功了。 除了配置文件路径不同其他都跟Arch下配置一样————/usr/local/etc/proxychains.conf]]></content>
      <categories>
        <category>软件分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《GNU Emacs Lisp编程入门》读书笔记]]></title>
    <url>%2F2019%2F12%2F21%2F%E3%80%8AGNU-Emacs-Lisp%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[借了本Elisp的书，不厚，200多页，大概一周(两周(一個月))就能看完吧! 第一章 列表处理列表是Lisp的基础。 Lisp列表介绍简单的Lisp列表书写形式: 1&apos;(rose violet daisy buttercup) ;; =&gt; (rose violet daisy buttercup) 这个简单的列表中的四个元素时四种不同花的名称。元素之间用空格隔开，并且被括号包住。 另有一种在elisp中常用到的写法: 1(+ 2 2) ;; =&gt; 4 这种写法是Lisp的一个特性————数据和代码都用相同的方式表示。 列表还允许嵌套列表，也就是说列表的元素也可以是列表。 Lisp原子原子意味着”不可再分”。例如刚刚列表内的’2’或者是’rose’等等，这些都是原子。 而列表却不是原子，因为列表是由CAR和CDR与CONS构成的。 技术上说，Lisp的列表有三种组合方式: 括号和括号中由空格分隔的原子 括号和括号中的其他列表 括号和括号中的其他列表和原子 一个列表可以仅有一个原子或完全没有原子 无任何原子的列表称作空列表: ()。你可以把空列表看为原子或列表。 原子和列表可以被称为符号表达式(symbolic expression)，又可称为S-表达式 。 Lisp编程几乎都是关于列表中的符号的(且有时是关于数字的). 双引号中的文本，都是单个原子:&#39;(Info &quot;Name:EvanMeek Age:18 Sex:Men**) 这种被双引号括起来的文本叫做字符串(string)。 列表中的空格Lisp中括号的数量无关紧要。下面两个的列表是完全相同的。 括号多1&apos;(1 2 3 4 5 6) ;; =&gt; (1 2 3 4 5 6) 括号少1&apos;(1 2 3 4 5 6) ;; =&gt; (1 2 3 4 5 6) 适当的在列表中加入一些空格以及换行符可以提高可读性。 GNU Emacs帮助你输入列表在Emacs中使用Emacs Lisp模式或Lisp交互模式输入Lisp表达式时可以用Tab按键使光标所在行自动缩排到适当的位置。要使某个区域的表达式都自动缩排的快捷键是C-M-\ 并且Emacs会具有括号匹配的功能，以防你迷失在Lisp的括号海洋中。 有兴趣的可以看下这个知乎提问。https://www.zhihu.com/question/356026550 运行一个程序如果你想运行一段Lisp程序，那么计算机可能会做三种事: 只返回列表本身; 提示出错信息; 将列表中第一个符号作为要执行的命令;大多数情况，我们希望计算机做的是第三件事 前面我们看到过一些列表的前面有一个单引号”‘“，它其实是Lisp中的一个引用(quote)。它的作用是告诉Lisp不要做对这个列表做任何操作，只返回列表本身即可。 1&apos;(只是返回本身 即可) ;; =&gt; (只是返回本身 即可) 而如果列表前没有quote，那么列表的第一个符号就会称为Lisp要执行的命令(函数)，后面的则是函数的参数。 1(+ 1 2 3 4) ;; =&gt; 10 Emacs中可以将光标放置一对S-表达式后按 C-x C-e就会将表达式读入至Lisp解释器中，进行解释，将结果输出至回显区，英文叫 mini buffer。 也可以对原子(没有被括号括起来)求值 产生错误消息编写Lisp代码时难免遇到错误，而Lisp解释器会在程序出错时输出报错信息。与其说是报错信息，不如说是有助的信息(书上这么说)。 下面，我们对一个没有引用并且第一个元素不是一个有意义的符号的列表进行求值。 1(Just Error!) ;; =&gt; Symbol&apos;s function definition is void: Just 这个输出结果就像是出错了一样，它告诉我们Just符号命令没有定义。也就是说Lisp解释器视图将(Just Error!)当成类似(+ 1 2)这种列表进行求值，但由于后者的第一个元素”+”是有意义的(已定义)，不会有任何问题，而我们编写的列表中第一个元素”Just”是没有任何意义(未定义)的，Lisp解释器不知道怎么办了，只好告诉我们一些有用的信息。 ## 我们已经讨论过一些符号或函数，例如”+”。就以”+”为例子，当我们对(+ 2 2)表达式求值时，计算机并不是执行的”+”这个命令，而是执行其对应的指令。我们甚至可以随意改变，例如我把”+”改为”Plus”。 Lisp解释器下面，简单解释下Lisp解释器在对一个列表求值时做了些什么。 首先，检查列表前是否有单引号(quote)，如果有则直接返回这个列表的输出形式。 若没有单引号则查看列表的第一个元素，是否有相对应的函数定义，如果有则执行对应的指令。 若没有则提示错误消息。以上就是Lisp解释器的工作方式。但都比较简单，下面将会介绍几种比较复杂的工作方式。 第一种。Lisp解释器还可以对符号求值(并不是只能对列表)，但这个符号前不能有单引号和被括号括起。 第二种，Lisp解释器在遇到一些特殊函数时。这些特殊的函数以特殊的方式运行着，这些特殊函数通常被称为特殊表(special form)。见名知意，它用于一些特殊的工作，例如定义函数之类的。 第三种，Lisp解释器在遇到一些不是特殊表，而是列表的一部分时。这可能意味着是一个嵌套列表，Lisp解释器首先查看列表中是否有另外一个列表，如果有则先解释内部列表，如果内部列表仍然具有一个列表，那么就再次解释更深的列表层级中的列表，最终以此返回结果。 否则Lisp解释器将会从左往右依次执行。 字节编译Lisp解释器还可以将Lisp代码编译成字节。这样的好处是可以让程序的执行速度更快，缺点是可读性几乎为零。 被编译成字节码后的源码叫做elc，可以通过命令(byte-compile-file)进行编译。 求值前面我们所得到的一些结果，都是由Lisp解释器求值得到的。求值也就是Lisp解释器处理表达式时进行的操作。 解释器对表达式求值时几乎总是会返回值，如果没有返回值，通常是会提示一些错误信息。 解释器对表达式求值不仅会返回值，还可能会有一些附加效果，可能是移动光标或拷贝文件、刷新Buffer之类的动作。 对一个内部列表求值上一节我们讨论过嵌套列表，这一小节解释了为什么内层列表总是首先被求值。首先给出答案:因为内层列表的返回值要被外层列表所使用。 下面通过一个例子了解这个求值的过程。 1(+ 1 (+ 2 3)) 我们知道使用快捷键C-x C-e可以对一个表达式求值，那么我们将光标放置(+ 2 3)表达式之后，然后按下这个快捷键，看看会发生什么。很显然，我们得到返回值5，那么再将光标放置整个表达式之后，按下快捷键得到返回值6。这就很好的解释了Lisp解释器对嵌套列表的求值过程。 我们可以通过快捷键C-h k然后键入C-x C-e查看这个快捷键所对应的符号(命令\函数)，也就是eval-last-sexp。 这个函数的作用是对最近的一个表达式进行求值，并且将结果打印至输出区域。 变量其他语言中，我们经常将某值赋值给一个变量，但你有见过可以将一个函数赋值给一个变量的语言吗(Python)? 在Lisp中，我们可以把值赋值给符号，并且这个符号的值可以使Lisp中任意表达式(符号、数字、列表、字符串)，并且符号的值是可变的，我们把一个有值的符号称为变量。 前面提到的将一个函数定义赋值给一个符号就是通过Lisp中变量的特性。Lisp的符号可以同时具有一个函数定义和一个值。我们可以把这种概念想象成具有多个抽屉的柜子。 例如变量fill-column是一个有值的符号，对它求值可以获取自动换行的字符数。 任何值都可以赋给符号，这个操作是:变量与一个值进行绑定。 fill-column只是一个很普通的值而已，如果我们对其求值时加上括号，将会发生一些错误。 1(fill-column) ;; =&gt; Symbol&apos;s function definition is void: fill-column 这个错误被打印在回显区，很容易可以理解为什么会出现这个错误。因为Lisp解释器将这个列表读入后试图寻找第一个元素与之相联系的函数定义，让而fill-column只是一个值为数字的变量罢了，所以就会引发这个错误。 符号无值时的错误信息下面我对一个没有赋值的符号进行求值。1(+ 2 2) ;; =&gt; 4 很显然，如果是在这个表达式右括号后执行eval-last-sexp将不会有任何问题，但我们现在将光标移动至+后，执行eval-last-sexp，会引发这个报错提示:Symbol&#39;s value as variable void: +。 这是因为Lisp解释器将无值的符号当成一个变量处理了，而Lisp解释器却没有找到任何关于+的变量，只找到了函数定义，因为就报错了。 参量参量对应着argument，也就是其他语言中参数的意思。例如(+ 2 3**这个列表的参数就是2和3，而这个+则是函数，+允许由多个参量。 不同的函数需要不同数目的参量，有些函数甚至不需要参量。 参量的数据类型函数所接收的参量也是有数据类型的限制的，例如+函数就规定其参量的值必须是数字。 有些函数允许有任意数量个参量，例如concat函数，它将任意多个字符串类型的参量合并为一个字符串。 1(concat &quot;My name is:&quot; &quot;EvanMeek&quot;) ;; =&gt; &quot;My name is: EvanMeek&quot; 请注意，concat函数的参量类型需要字符串并不意味着参量就必须写上字符串，这里指的是参量的值必须是字符串，请不要混淆。 例如我们可以在concat的参量中写上substring函数。 1(concat &quot;Nice to meet &quot; (substring &quot;fuck you&quot; 5 8)) 上面的concat是一个参量必须都为字符串类型且任意数量的函数，而substring是一个可变数量参量且有多种参量类型的函数。substring是可以对字符串这种单原子抽取出子字符串的，而这种操作可以取个好玩的名称原子分裂机。 作为变量和列表的值的参量 上一小节提到————有些函数允许有任意数量个参量，且参量数据类型不同，我们可以理解为有些函数的参量可以是任意任意数量个符号。 这一节，我们将谈谈函数的参量还支持那些。 函数参量还支持列表和变量，当参量为变量时，Lisp解释器就会寻找是否有有值的变量，如果有就返回值，例如: 12;; 结果可能不同，取决于你的Emacs配置。(+ 2 fill-column) ;; =&gt; 82 并且参量还可以是一个列表，例如: 1(+ 2 (+ 3 (+ 4))) ;; =&gt; 9 数目可变的参量前面提到过的函数已经具有这个规则了，参量的数目可变，例如我们已经知道的+函数: 12(+) ;; =&gt; 0(+ 2) ;; =&gt; 2 又或是\*函数: 12(*) ;; =&gt; 1(* 2) ;; =&gt; 2 所以它们都具有一个特性————参量数量可变。 12(* 1 2 3) ;; =&gt; 66(+ 1 2 3) ;; =&gt; 6 用一个错误类型的数据对象作为参量试想下，如果我们对函数提供了错误类型的参量会发生什么？ 1(+ 2 &apos;hello) ;; =&gt; Wrong type argument: number-or-marker-p,hello 我们知道+函数的参量必须是数字，而我们传入的参量2的&#39;hello被Lisp解释器操作时会试图将2和&#39;hello的返回值相加，但是&#39;hello的返回值不是一个数字，所以就会引发这个错误。 让我们来试着解读下Lisp解释器提示的错误信息。首先Lisp解释器明确的告诉了我们————Wrong type argument(参量类型错误)，再是一段我们看不懂的符号number-or-marker-p这个符号意味着:Lisp解释器提示我们+函数的参量所需的数据类型，number也就是数字，而marker是一个标记(Elisp的一个特性，缓冲区的位置是由标记决定的，我们可以通过快捷键C-@C-SPC命令设置标记)， 而p则是Lisp的一个历史问题(早期Lisp程序员中用”p”替代”predicate”用于表示是否为真)，类似的有zerop用于判断参量值是否为零。最后的hello则是我们传给+函数出错的参量的值。 message函数message函数用于给用户发送消息。这些消息是被打印在回显区的，它的第一个参量要求为一个FORMAT STRING(可格式化字符串)。 1(message &quot;Should you sleep now?&quot;) ;; =&gt; Should you sleep now? 双引号中的文本被打印在回显区(我们看到的是表达式的返回值，而打印只是一个附加效果)，这显得没什么新奇的，我们直接写一个字符串原子并且对其求值貌似也有同样的结果，下面将会介绍格式化字符串。 1(message &quot;The name of this buffer is: %s&quot; (buffer-name)) ;; =&gt; &quot;The name of this buffer is: 《GNU-Emacs-Lisp编程入门》读书笔记.md&quot; 这输出了我当前buffer的名称。重点在于第一个参量中存在一段特殊的子串%s，message函数的第二个参量的值将用于它，这个%s代表了接收一段字符传，类似的还有%d用于接收一个十进制数。 1(message &quot;The value of fill-column is %d&quot; fill-column) ;; =&gt; &quot;The value of fill-column is 80&quot; 这些特殊子串都支持变量、列表或符号，例如： 1(message &quot;我想吃%s，各来%d斤!&quot; (concat &quot;苹果、&quot; &quot;梨子、&quot; &quot;葡萄&quot;) (+ 1 1)) ;; =&gt; &quot;我想吃苹果、梨子、葡萄，各来2斤!&quot; 从第二个参量开始将会一次取代第一个参量中特殊子串的位置。 给一个变量赋值这一小节学习为一个变量赋值，常用的操作有set、setq、let，在这节主要将set和setq。并且描述这两个函数是如何工作的。 使用set函数我们要为flowers符号附上一个列表值，那么可以这么写1(set &apos;flowers &apos;(菊花 百合 玫瑰)) ;; =&gt; (菊花 百合 玫瑰) 这意味着我们将列表菊花 百合...绑定给了flowers符号。 两个参量的引用是为了让其不要求值，所以你可以知道set函数的第一个参量最好要加上引用，这大概是很常用的搭配。 使用setq函数setq函数与set函数很相似，它们只有一个区别，就是setq函数会自动给第一个参量加上引用，例如用setq完成上一小节的例子: 1(setq flowers &apos;(菊花 百合 玫瑰)) ;; =&gt; (菊花 百合 玫瑰) 并且它们俩都是可以为多个变量绑定多个值的，例如: 1234(setq 学生 &apos;(学号 地址 姓名 电话) 老师 &apos;(教师号 地址 姓名 电话))学生 ;; =&gt; (学号 地址 姓名 电话)老师 ;; =&gt; (教师号 地址 姓名 电话) 其中参量二绑定给参量一，参量四绑定给参量三，以此类推。 计数就是用setq函数完成了一个递增的操作。 首先生成一个初始化器，再生成一个递增器，再进行输出数值。 123(setq count 0) ;; 初始器(setq count (1+ count)) ;; 递增器count ;;输出 小结记录一下，加油努力，毕竟书中都说了，我已经跨过了最陡峭的那段山路。 Lisp程序由表达式组成，表达式是列表或单个原子。 列表由0个或更多的原子或内部列表组成，原子或列表之间由空格隔开，并由括号括起来，列表可为空。 原子是多字符的符号(如fill-column)，单字符的符号(如+号)，双引号之间的字符串或者数字。 对数字求值就是其本身 对双引号之间的字符串求值也是其本身 当对一个符号求值时，将返回它的值。 当对一个列表求值时，Lisp解释器查看列表首符号绑定在其上的函数定义，并执行其指令。 单引号告诉Lisp解释器返回后续表达式的书写形式，而不是像没有单引号时那样对其求值。 参量是传递给函数的信息。除了作为列表的第一个元素的函数之外，通过对列表的其余元素求值来计算函数的参量。 当对一个函数求值时总是返回一个值(除非得到错误信息)。另外，它也可以完成一些被称作附带效果的操作。在许多情况下，一个函数的主要目的是产生一个附带效果。 最后，希望这篇博客可以记录好第一章所讲。 练习一个一个来，题目写在博客内吧… 通过对一个不在括号内的适当符号求值，产生一个错误信息。 解答: 1一个不存在的变量 ;; =&gt; Symbol&apos;s value as variable is void: 一个不存在的变量 通过对一个在括号内的适当符号求值，产生一个错误信息。 解答: 1(又一个不存在的符号) ;; =&gt; Symbol&apos;s function definition is void: 又一个不存在的符号 创建一个每次增加2而不是1的计数器。 解答: 123(setq count 0) ;; 初始器 (setq count (+ 2 count)) ;; 递增器count ;;输出 写一个表达式，当对它求值时，它在回显区输出一条消息。 解答: 1(message &quot;这段消息是要输出至%s%s的&quot; &apos;回显 &quot;区&quot;) 第二章 求值实践这一章主要讲了关于buffer的一些知识，讲了一些关于buffer的函数，并且讲解了一些buffer的注意事项。 缓冲区名讲了两个函数，分别是(buffer-name)以及(buffer-file-name)。 首先得清楚buffer和文件的概念，buffer的中文翻译叫做缓冲区，它其实是将文件中的内容拷贝到Emacs中，所以在我们修改buffer时，文件并不会改动，只有当我们进行保存修改时才会。而文件是保存在磁盘上的信息，人们常常在修改buffer时说成”我在修改xx文件”，这严格意义上讲是错误的，但人们都知道其实我只是在修改buffer，而不是那个文件，只不过说成文件罢了，所以各位小伙伴不要误解。 计算机没有人类那么聪明，所以大家在写代码时要分清楚这两个的不同。 (buffer-name) ;; 1(buffer-file-name) ;; =&gt;&quot;/home/evanmeek/Documents/Blog/source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md&quot; 表达式(buffer-name)用于获取当前buffer的名称而(buffer-file-name)用于获取当前buffer所对应文件的完整路径，还要说明一点，并不是所有的buffer都有所对应的文件，例如\*scratch\*buffer就没有所对应的文件。 获得缓冲区如果想获得缓冲区本身，那么可以使用current-buffer。 12(buffer-name) ;; =&gt; &quot;《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;(current-buffer) ;; =&gt; #&lt;buffer 《GNU-Emacs-Lisp编程入门》读书笔记.md&gt; 我们发现这两个函数的返回值挺相似的，但实际上他们却完全不同，buffer-name获取到的只是一个名称罢了，而current-buffer函数获取到的是一个名称所指向的对象或实体。举个生活上的例子:你对小明说:”小明，帮我拿个苹果”，然后小明就拿给了你”苹”和”果”字，显然这不是你真正想要的，你想要的是叫苹果的那个实体，可以吃的，有维生素的水果。经过这个例子，希望大家都能理解。 切换缓冲区先介绍一个函数————other-buffer，这个函数用于发挥最近常打开过的buffer对象。例如最近常在\*scratch\*与test.el之间切换buffer，那么当前buffer为\*scratch\*时调用(other-buffer)时将会返回test.el的buffer对象。 再介绍一个函数————switch-to-buffer，这个函数接收一个Buffer对象的参量，可以切换当前buffer为Buffer参量。 12345(buffer-name) ;; =&gt; &quot;《GNU-Emacs-Lisp编程入门》读书笔记.md&quot;(other-buffer) ;; =&gt; #&lt;buffer *Backtrace*&gt;;; 根据最近最常打开过的buffer对象切换buffer(switch-to-buffer (other-buffer))(buffer-name) ;; =&gt; &quot;*Backtrace*&quot; 如果想要回到上一个buffer可以键入键序列C-x b RET，RET是回车。 前面几次提到调用(call)这个概念，实际上Lisp解释器对一个列表的首元素为一个函数进行处理时，就是在调用那个函数。 缓冲区大小和位点的定位先为大家介绍下四个函数: (point);; 获取当前光标在当前buffer的位点。 (buffer-size);; 获取当前buffer的字符数(包括空格) (point-min);; 获取当前光标中位点的最小可能值。默认是1,除非设置了变窄,毕竟默认是从第一个字符开始 (point-max);; 获取当前光标中位点的最大可能值。默认是最后一个字符的point,除非设置了增宽。 123456789;; 获取当前buffer的字符数(包括空格)(buffer-size) ;; =&gt; 10636;; 获取当前光标在当前buffer的位点。(point) ;; =&gt; 10525;; 获取当前光标中位点的最小可能值。默认是1,除非设置了变窄,毕竟默认是从第一个字符开始(point-min) ;; =&gt; 1;; 获取当前光标中位点的最大可能值。默认是最后一个字符的point,除非设置了增宽。(point-max) ;; =&gt; 10670 练习找一个文件，对它进行操作，将光标移动到缓冲区的中间部分。找出它的缓冲区名、文件名、长度、和你在文件中的位置。 缓冲区名 1(buffer-name) ;; =&gt; &quot;《GNU-Emacs-Lisp编程入门》读书笔记.md&quot; 文件名 1(buffer-file-name) ;; =&gt; &quot;/home/evanmeek/Documents/Blog/source/_posts/《GNU-Emacs-Lisp编程入门》读书笔记.md&quot; 长度 1(buffer-size) ;; =&gt; 11005 在文件中的位置 1(point) ;; =&gt; 11033 第三章 如何编写函数定义本章内容较多，不止于函数定义，还介绍了一些常用的函数。 defun 特殊表defun不以通常的方式对它的参量求值，因为它是特殊表。 这节将简单描述函数定义的过程。 一个函数定义在defun之后最多可有5个部分: 符号名，这个符号指向了这个函数的定义。 一个列表，包含了要传给函数的参量。若没有任何参量要传递，那么可以写空列表。 这个函数的文档，由双引号括住，此选项为可选。 使当前函数成为一个交互式函数的列表，此选项为可选。交互式函数将会在后的小节讲到。 函数的主题，也就是一系列的命令。下面是一个包含了五个部分的函数模板: 1234(defun funciton-name (arguments...) &quot;optional-documentation&quot; (interactive argument-passing-info) ;; optional body...) 我们通过这个模板写一个简单的函数吧，这个函数的功能呢是让其参量乘以7。 123(defun multiply-by-seven (number) &quot;使number(参量)乘以7&quot; (* number 7)) 这个函数的函数名就是multiply-by-seven，而函数名后面的列表也就是函数的参量，当我们调用函数时，传递给函数的参量的值就会被绑定到这个number上。并且number也可以为其他的名称，这取决于写代码的人，你可以改为multiplicand，这可能更符合函数定义的意思。并且这里的number的范围是仅在函数定义内才有效的，如果我们在函数定义外对number求值，可能会返回个错误信息。所以说，参量列表内的参量名可以是任意的，只要不与参量列表内的其他参量相同即可。这就比如：你班上的外号叫李大头，那么在这个班里的李大头代表的人就是你，而如果是在学校中，也有人的名字叫李大头，这时这个李大头就不代表你了。 跟随参量列表后的叫做函数文档，它的作用是当我们或任何人使用C-h f并键入函数名时所查看的函数帮助文档中的文本。这里还要注意一点，有些函数例如apropos在查看函数文档时会只显示文档的第一行，所以我们要在第一行就尽量写清楚这个函数的作用。通过C-h f查看函数文档将会弹出一个\*Help\*Buffer。 而这个例子的第三行就是函数的主体(往往比例子里多很多**，它是一个列表，功能是将number乘以7。 函数定义好了，但我们不要直接尝试调用，我先告诉你们调用的方式吧，把函数名作为一个列表的首元素，其余的作为参量最后eval即可。1(multiply-by-seven 7) 但可千万不要急着求值，因为肯定会报错。这主要是因为你只是写好了函数定义，并没有把函数定义给安装上。 安装函数定义将光标移动到我们写好的函数定义之后，eval一下即可安装好函数。安装完成后的函数就被包含在Emacs之中了，直到退出Emacs之前。如果已经尝试安装函数定义的童鞋应该已经发现了，在我们eval函数定义后，会在回显区显示函数名，这就代表我们成功安装了这个函数。 改变函数定义想要修改已经安装好的函数定义很简单，我们只需要重新安装一遍即可，例如我们想要将multiply-by-seven函数改为用+来实现，这样做: 12345(defun multiply-by-seven (number) &quot;使number(参量)加7次&quot; (+ number number number number number number number)) ;; =&gt; multiply-by-seven(multiply-by-seven 7) ;; =&gt; 49 所以编写Emacs Lisp代码时的流程通常是:写函数，装函数，测函数，改函数，装函数。 使函数成为交互式函数交互式函数的特点是可以通过M-x调用，还可以通过键序列调用，例如常用的移动光标C-n就是一个交互式函数，并且交互式函数是不会自动将返回值输出至回显区的，因为让一个函数称为交互式函数通常被认为是想得到函数的附加效果，而不是返回值。 想要使一个函数称为交互式函数，可以在函数定义时，将defun特殊表开头的列表的第四个元素写成一个interactive特殊表开头的列表。例如: 12345(defun multiply-by-seven-interactive (number) &quot;打印 number(参量) 乘以 7这是个交互式函数&quot; (interactive &quot;p&quot;) (message &quot;7 * %d = %d&quot; number (* number 7))) ;; =&gt; multiply-by-seven-interactive 安装好这个函数后，可以有三种方式调用它: 对表达式(multiply-by-seven-interactive 7**求值 键入C-u然后输入一个数字作为函数的参量，键入M-x然后键入函数名最后键入RET。 还有一种暂时没搞成功，等学到16章的第7节就知道了。 交互式函数不会自动将返回值打印至回显区 并且当使用第二种调用方式时，没有在C-u之后键入数字的话将会以默认值4来替代。 交互的multiply-by-seven函数我们为multiply-by-seven函数定义了交互式版本，但没有解释其中的(interactive &quot;p&quot;)列表是个什么东西，这里就说一下。 首先(interactive &quot;p&quot;)中的p代表将接收一个前缀参量，这个前缀参量也就是我们通过C-u 数字 M-x 函数名这种方式调用时的数字了，例如这个数字是5那么就会把5传递给number参量，然后在message函数中的(* 7 5)求值，最终由于函数是一个交互式函数，所以函数不会自动将返回值输出到回显区中，而message函数的返回值原本是带双引号的，由于是交互式函数，我们要的只是函数带来的附加效果，而不是返回值。 interactive函数的不同选项前面已经解释过interactive函数的p选项，其实interactive特殊表有20多个预定义的选项，我们可以结合多个选项使得将信息正确交互地选送给函数。 下面介绍两个选项，首先是r，它可以让Emacs将位点所在区域的开始值和结束值作为函数的两个参量: 1(interactive &quot;r&quot;) ;; =&gt; (13945 13978) 再则是B选项，它可告诉Emacs用缓冲区的名字作为函数的参量，它会让Emacs在小缓冲区提示用户输入缓冲区名字，并将跟在B后面的字符串作为提示，而且Emacs还会进行函数名的补全（按TAB）。 12;; 会出来一个交互式的窗口(interactive &quot;B请输入Buffer名称:&quot;) ;; =&gt; (&quot;test.el&quot;) 下面再看一个例子，可以获取任意Buffer所对应的文件路径以及位点的开始及结束点。 1234(defun get-buffer_name-point_start-point_end (buffer start end) &quot;获取buffer所对应的文件以及位点的开始结束值&quot; (interactive &quot;B请输入Buffer名称: \nr&quot;) (message &quot;Buffer-file:%s\npoint-start:%d\npoint-end:%d&quot;(buffer-file-name (get-buffer buffer)) start end)) 通过interactive的B选项获取任意buffer的名称，再通过r选项后去位点的开始和结束值。最后在输出时通过get-buffer获取Buffer对象，从而达到目的。 interactive是支持控制字符的，例如上个例子中用到的\n。并且interactive还可以无参量，这样的话跟mark-whole-buffer函数差不多。如果interactive的选项不能满足你的要求，那么你可以将参量传递给nteractive做为一个列表。 永久地安装代码前面我们写了那么多的函数，在我们没有关闭Emacs之前这些函数都是可以被我们随意求值的，但是当我们关闭Emacs之后再打开就必须重新安装函数才能求值了。所以有几种方式可以永久地安装函数或其他的代码。 如果代码作为个人使用，可以把函数定义的代码放到.emacs初始化文件中，当启动Emacs时，将会自动对.emacs文件中的代码求值。 如果代码很多，可以将函数定义存放至多个文件，然后使用load函数使得emacs对单独存放函数的文件求值。 如果是当前计算机其他用户需要使用的代码，可以将代码放入site-init.el文件中，这样使得所有的用户都可以使用你的代码。 如果你想让你的作为全世界的人使用，那么你可以将代码放到互联网上，或着给自由软件基金会发送一份拷贝，它有可能被加入下一个发行版本中。 Emacs在过去的年代里成长的道路————奉献。 let函数let函数与defun函数一样，都是EmacsLisp中的特殊表。 let函数将一个符号附着到或者绑定到一个值上。这些被绑定的值是只能在let函数之内使用，就像说defun特殊表举的例子，两个同名的事物在不同的场景下代表了不同的意思，例如你的房子和你朋友的房子都是房子，你对你朋友说，你要粉刷房子，在你听来是要粉刷你家的房子，但你朋友有可能会认为你要粉刷他的房子。 而let函数就避免了这种问题，在let函数中绑定的变量都只能在let函数中访问，这就是局部变量的概念。 let函数跟setq以及set函数有个很大的区别就在于: let函数绑定的变量可有任意个 setq和set只能有一个 let函数可以执行一个或多个列表。 let函数绑定的变量都是局部的。 let表达式的各个部分let表达式分为三个部分，第一个就是let符号，第二个是变量列表，第三个是主体。 第二个部分的变量列表是由一个列表组成的，这个列表内可以是任意多个符号或任意多个由两个元素组成且第一个元素必定是符号的列表。* 第三个部分是let表达式主体，由任意多个列表组成。 let表达式的模板看起来像: 1(let varlist body...) 其中变量列表的符号是由let特殊表赋初始化值的变量.符号本身的初始值是nil.而作为两元素列表的首元素的每一个符号被绑定到对第二个元素求值后的返回值. 所以一个简单的变量列表看起来可能是这样的:(apple (pear 10)).在这个例子中,apple的值是nil,因为我们没有为其赋予初始值.而pear的值为10. 那么当变量是由两个元素的列表组成,就可以是下面这样的模板: 123(let ((variable value) (variable value) variable...) (body1) (body2)...) let表达式例子现在需要创建一些关于水果的栗子,不同的水果有不同的数量. 12(let (apple (pear 10) (banana &apos;4斤) watermelon) (message &quot;苹果数量:%S\t梨子数量:%d\t香蕉数量:%s\t西瓜数量:%S&quot; apple pear banana watermelon)) ;; =&gt; &quot;苹果数量:nil 梨子数量:10 香蕉数量:4斤 西瓜数量:nil&quot; 我们创建了两个初始值为nil的变量apple和watermelon,以及一个绑定到10的变量pear,还有一个绑定到4斤的变量banana.随后在let主体中将创建的变量都用message函数打印在回显区. let语句中的未初始化变量在let表达式的变量列表中,允许不给予变量初始化值,那么Lisp解释器将会为其默认绑定到nil值上. 并且,如果没有给予初始值,那么它可以称作:作为独立的原子出现. if特殊表if函数是除了defun/let特殊表之外的一个特殊表,它用于让计算机做一些判断的工作. 首先来看if函数的模板: 12(if if-part then) 其工作方式是：首先测试if-part的返回值是否不为nil，如果不为nil，那么就执行then的表达式。 通常会把then部分放在if-part的下一行，这样更有利于阅读。 下面做一个简单的栗子: 12(if (&gt; 5 4) (message &quot;5 比 4 大!&quot;)) ;; =&gt; &quot;5 比 4 大!&quot; 其中&gt;函数测试它的第一个参量和第二个参量进行比较大小，如果第一个参量大于第二个参量则返回“真”，否则返回nil。 可往往在日常编码中，if-part的值不能直接确定，它可能是一个表达式，又可能是一个函数调用。 例如测试参量可能被绑定在函数定义的参量上: 123456(defun type-of-animal (animal-name) &quot;根据animal-name打印信息到回显区如果animal-name是符号&apos;fierce则返回&apos;tiger&quot; (if (equal animal-name &apos;fierce) (message &quot;It&apos;s a tiger&quot;)))(type-of-animal &apos;fierce) ;; =&gt; &quot;It’s a tiger&quot; type-of-animal函数详解 首先type-of-animal是包含了两个特殊表模板，分别是defun和if。type-of-animal是函数名，紧跟着函数名的是函数参量列表，然后跟着的是函数的文档。最后函数的主体内是一个if函数，if函数的的一个参量是一个列表，这个列表的首元素的符号是一个函数equal，在Lisp中，equal函数用于比较参量一和参量二是否相等，如果相等则输出if函数的第二个参量，也是一个列表，这个列表的首元素是符号且是函数message，将It&#39;s a tiger打印至回显区。 if-then-else表达式其实if-then-else表达式就是在if特殊表之上加了一个参量，其他没什么不同，新增的参量是当参量一的值为nil时，对参量三求值。 它的函数模板可以写成这样: 123(if true-or-false-test action-to-carry-out-if-the-test-returns-true action-to-carry-out-if-the-test-returns-false) 例如: 123(if (&gt; 4 5) (message &quot;5 大于 4!&quot;)(message &quot;4 小于 5&quot;)) ;; =&gt; &quot;4 小于 5&quot; 通过这个例子，我们发现当if函数的第一参量值为nil时就会对第三参量求值。并且第三参量的缩进也要少于第二参量。 那我们现在将type-of-animal函数改造成: 12345678(defun type-of-animal (animal-name) ;second version &quot;根据animal-name打印信息到回显区如果animal-name是符号&apos;fierce则输出&apos;It&apos;s tiger!否则输出Tt not fierce&quot; (if (equal animal-name &apos;fierce) (message &quot;It&apos;s tiger&quot;) (message &quot;It not fierce&quot;)))(type-of-animal &apos;fierce) ;; =&gt;&quot;It’s tiger&quot;(type-of-animal &apos;notfierce) ;; =&gt; &quot;It not fierce&quot; Lisp中的真与假Lisp中所有除了nil的都是真，nil也就是我们常说的假，nil有多种意思，一种就是nil代表假，另一种则是代表空列表，但往往都把空列表写成()，而当Lisp解释器对表达式求值时，只要值不是nil或空列表那么都是真，不管得到的值为一个数字或字符串或列表，它都代表真。 123456(if nil &apos;true &apos;false) ;; =&gt; false(if t &apos;true &apos;false) ;; =&gt; true 真也有另外一种表示方式，在表达式求值后没什么可返回时就会返回t，例如: 1(&gt; 5 4) ;; =&gt; t save-excursion函数各位还记得什么是位点(point)，什么是标记(mark)吗? Emacs是一个文本编辑器，主要还是与文本打交道，那么save-excursion函数就是与文本打交道的一个经典函数。 先让我们来回顾一下位点与标记: 位点(point)：及当前buffer中光标所在字符位置，例如当光标置于buffer的开头，那么point应该是1，若置于buffer的末尾，那么point就是当前buffer的字符数了。 标记(mark)：标记是buffer的另外一个位置，其中一个就是位点。在buffer中可以自定义很多标记，这样可以方便我们跳转至某个位点。设置标记的函数是(set-mark-command)，它绑定了一个键序列C-SPC，如果此时想要快速跳转至某个标记点，就可以使用命令(exehange-point-and-mark快速回到标记处，它绑定了一个键序列C-x C-x，并且还会将当初的位点设置一个标记，方便来回跳转。 位点与标记之间的缓冲区叫做现域(region)，有很多条命令是专用于操作现域的，例如:center-region|count-lines-region|kill-region|print-region 前面将了很多关于位点与标记的知识，下面正式介绍save-excursion函数，这个函数的作用主要是将位点和标记的当前位置保存，然后当其他会影响位点或标记的函数执行完后，再将标记的位点复原。 save-excursion函数模板: 12(save-excursion body...) 注意，save-excursion函数的函数体允许有多条表达式，但是只返回最后一条表达式的值。 回顾这一章学的东西还是挺多的，下面我就把书中的所有文字一字不差的抄下来。 先说几个提到但是没有过多解释的函数: eval-last-sexp对光标所处的位点前的最后一个符号表达式求值。如果这个函数激活时没有参量，那么将返回值输出在回显区，否则将打印在当前缓冲区中。 defun定义函数。这个特殊表最多可有五个部分：函数名、传送给函数的参量的模板、文档、一个可选的交互函数声明以及函数体。 interactiv向解释器声明这个函数可以被交互的使用，并且这个特殊表还可以用一个字符串，分成单个或多个部分，依次传送信息至这个函数的参量。 let声明在let表达式主体中使用的变量列表并且给它们赋初始值，初始值要么是nil，要么是一个指定的值，然后对let表达式主体的其他表达式求值并返回最后一个表达式的值。 save-excursion对这个函数主体求值前，记录位点和标记的值以及当前缓冲区。求值后恢复位点和标记。 if对函数的第一个参量求值，如果值为真，则对第二个参量求值，否则对第三个参量求值。 equal、eq测试两个对象的结构或内容是否相等用equal，测试两个对象是否完全相当用eq &lt; &gt; &lt;= &gt;=用于判断第一个参量的值是否大于/小于/大于或等于/小于或等于第二个参量的值，如果是则返回真，否则返回nil message用于往回显区内打印消息 setq setsetq 用于将第一个参量的值绑定到第二个参量的值，而第一个参量的值由setq自动加上引用。set 用于将第一个参量的值绑定到第二个参量的值，但是不会自动为第一个参量加上引用。 buffer-name这个函数用于获取一个缓冲区的名字 buffer-file-name这个函数用于获取缓冲区所对饮的名字 current-buffer这个函数用于获取当前缓冲区的buffer对象 other-buffer返回最近选择过的缓冲区 switch-to-buffer选择一个缓冲区 set-buffer设置当前缓冲区为某一个缓冲区 buffer-size返回当前缓冲区的字符数 point返回当前光标所对应缓冲区的位置 point-min返回当前缓冲区最小的字符数 point-max返回当前缓冲区最大的字符数 练习 编写一个非交互的函数，这个函数将其第一个参量(是一个数)的值翻倍。然后使这个函数成为一个交互函数 非交互: 12345(defun double(number) &quot;使number翻倍&quot; (setq number (* number 2)))(double 10) ;; =&gt; 20 交互式: 12345(defun double(number) &quot;使number翻倍&quot; (interactive &quot;n请输入要翻倍的数字: &quot;) (setq number (* number 2)) (message &quot;翻倍后:%d&quot; number)) 编写一个函数，测试fill-column的当前值是否大于传送给函数参量的值，如果是则打印适当的信息 12345678(defun is-bigger-to-fill-column (number) &quot;判断number是否比fill-column大&quot; (if (&gt; number fill-column) (message &quot;%d比fill-column要大&quot; number) (message &quot;%d比fill-column要小&quot; number)))(is-bigger-to-fill-column 79) ;; =&gt; &quot;79比fill-column要小&quot;(is-bigger-to-fill-column 81) ;; =&gt; &quot;81比fill-column要大&quot; 第四章 与缓冲区有关的函数本章将会介绍大量的函数定义。 查找更多的信息可以使用C-h f查看一个函数所对应的文档，使用C-h v查看一个变量所对应的文档，如果要在源代码文件中查看函数定义，可以使用函数find-tags，跳到相应的位置。 Lisp代码可以分为多个模块或包，如果想要查看某个模块的帮助，可以键入C-h p。 简化的beginning-of-buffer函数定义对于beginning-of-buffer函数你们可能已经使用过了，其绑定的键序列是M-&lt;。其作用是将当前光标移动至buffer的起始处。 下面我们将自己实现一个简单的beginning-of-buffer函数。 让我们来看看我们需要做什么事: 首先这个函数得是个交互式函数，以便我们能通过键序列调用或用M-x调用。 其次我们需要记录个位点为标记 最后我们再跳转到buffer起始处 相比与真正的beginning-of-buffer函数定义，没有考虑一些复杂的选项，但是我们先完成这个简化版本吧! 12345(defun simple-beginning-of-buffer () &quot;移动光标至buffer开始处&quot; (interactive) (push-mark) (goto-char (point-min))) 这个defun函数包含了5个部分: 首先是这个函数的函数名————simple-beginning-of-buffer 再就是函数的文档 随后是交互式表达式 然后记录位点为标记 最后跳转至buffer的起始处 由于这个函数是无参量的，所以交互式表达式内也不用写任何字符串，而push-mark函数默认将point加入到标记中，最后通过goto-char跳转至point-min的位置。如果想要回到原来的位置可以使用C-x C-x。 既然已经写了一个simple-beginning-of-buffer那我们也可以写一个simple-end-of-buffer吧! 12345(defun simple-end-of-buffer() &quot;移动光标至buffer结束处&quot; (interactive) (push-mark) (goto-char (point-max))) 最后则是，如果遇到不了解的函数，可以将光标放置函数之上，键入键序列C-h f RET即可。 mark-whole-buffer函数定义mark-whole-buffer 不比simple-end-of-buffer复杂多少。 这次我们来看一个函数的完整定义 这是书中的定义: 123456(defun mark-whole-buffer () &quot;Put point at beginning and mark at end of buffer.&quot; (interactive) (push-mark (point)) (push-mark (point-max)) (goto-char (point-min))) 书中讲不知道为啥函数体内的第一条表达式push-mark内还需要写(point)，但我现在再去看，这个函数已经改变了，并且也改掉了这个冗余的代码。 12345678910111213(defun mark-whole-buffer () &quot;Put point at beginning and mark at end of buffer.If narrowing is in effect, only uses the accessible part of the buffer.You probably should not use this function in Lisp programs;it is usually a mistake for a Lisp function to use any subroutinethat uses or sets the mark.&quot; (declare (interactive-only t)) (interactive) (push-mark) (push-mark (point-max) nil t) ;; This is really `point-min&apos; in most cases, but if we&apos;re in the ;; minibuffer, this is at the end of the prompt. (goto-char (minibuffer-prompt-end))) 并且还改了一些代码，先不看declare，我们发现变化的有(push-mark (point-max))，最新的mark-whole-buffer函数中函数体第二个表达式多了两个参量，第二个参量代表如果值不为nil则显示Mark set。第三个参量代表如果在瞬时标记模式下，值不为nil则激活。 并且最后一条表达式也修改过了，原本是point-min但改为minibuffer-prompt-end，其区别在于: minibuffer-prompt-end会在返回buffer位置时输出信息至minibuffer 在是如果当前buffer不是minibuffer那么就返回point-min append-to-buffer函数定义由于我看的这本书年代久远(2001)，现在是2019年，整整过去18年，Emacs也已经发生了巨大的变化。 所以我将先试着记录书中所讲的append-to-buffer函数再对Emacs 26.3版本的append-to-buffer函数进行讲解，希望对看到这篇博客的同仁们提供一些微薄的帮助。 这个计划已经鸽了，我发现用我现在所学还是很难解释清楚26.3版本的append-to-buffer函数的工作方式。所以后面的26.版 append-to-buffer会在以后完成，十分抱歉。 首先append-to-buffer函数的作用是将指定buffer区域(region)中的文本追加到当前Buffer的point前。 旧版append-to-buffer先让我们看看书中的append-to-buffer函数定义: 1234567891011(defun append-to-buffer (buffer start end) &quot;Append to specified buffer the text of the region.It is inserted into that buffer before its point.When alling from a program, give three arguments:a buffer or the name of one, and two character numbersspecifying the portion of the current buffer to be copied.&quot; (interactive &quot;BAppend to buffer: \nr&quot;) (let ((oldbuf (current-buffer))) (save-excursion (set-buffer (get-buffer-create buffer)) (insert-buffer-substring oldbuf start end)))) 通过阅读这个函数的文档就能很清晰的了解这个函数的工作方式。 略过函数名和文档，我们直接来看interactive。interative中的B代表让用户选择一个Buffer(可能不存在)并将buffer名称传给函数参量一，其次是一些友好的文本Append to buffer:，紧跟其后的\n用于控制换行，最后的r获取当前区域(point和mark)，并将其传给函数的参量二和参量三。 随后是一个let特殊表，在let的变量列表中，定义了一个oldbuf，其绑定的值是(current-buffer)的返回值，也就是当前Buffer对象。在let的表达式体中有一个save-excursion函数。 save-excursion函数体中有两条表达式，第一条表达式(set-buffer)用于将当前缓冲区变换到另外一个缓冲区，而其参量又是一个函数get-buffer-create，这个函数的作用是获取指定BUFFER对象或名(称为BUFFER-OR-NAME)，如果这个BUFFER-OR-NAME不存在，将会自动创建。 save-excursion函数体的第二条表达式是一个(insert-buffer-substring)函数这个函数将参量一从参量二到参量三的区域的字符串插入到当前Buffer的point之前。 26.3版append-to-buffer由于本人水平有限，如有错误，欢迎提出issue. 先让我们看函数定义原型: 123456789101112131415161718192021222324(defun append-to-buffer (buffer start end) &quot;Append to specified BUFFER the text of the region.The text is inserted into that buffer before its point.BUFFER can be a buffer or the name of a buffer; thisfunction will create BUFFER if it doesn&apos;t already exist.When calling from a program, give three arguments:BUFFER (or buffer name), START and END.START and END specify the portion of the current buffer to be copied.&quot; (interactive (list (read-buffer &quot;Append to buffer: &quot; (other-buffer (current-buffer) t)) (region-beginning) (region-end))) (let* ((oldbuf (current-buffer)) (append-to (get-buffer-create buffer)) (windows (get-buffer-window-list append-to t t)) point) (save-excursion (with-current-buffer append-to (setq point (point)) (barf-if-buffer-read-only) (insert-buffer-substring oldbuf start end) (dolist (window windows) (when (= (window-point window) point) (set-window-point window (point)))))))) 我们发现函数参量没有变化，并且注释也没有大的变化，只是函数体内发生了较大的变化。 首先是interactive函数参量发生了变化，变成了一个list函数，回想一下，list函数是用于构造一个列表的函数，这个list函数的第一个参量是(read-buffer)函数。 read-buffer函数可以通过buffer名称读取buffer中的字符串并返回。其第一个参量是用于提示用户的友好信息，并且特意指出这个提示信息必须是由冒号和空格结尾且被双引号包围的字符串。第二个参量用于也就是返回值，它的默认值为列表 回顾惯例抄书 describe-function\describe-variable打印一个函数或一个变量的文档。通常将其绑定到C-h f和C-h v find-tag找到存放某个函数或变量的源代码的文件，并切换到这个缓冲区，将位点(光标)置于相应函数或这变量的开始处。习惯上将其绑定到M--。 save-excursion保存位点和标记的位置，并在对save-excursion参量求值之后恢复这些值。它也保存当前缓冲区并返回到该缓冲区。 push-mark在指定位置设置一个标记，并在标记环中记录原来标记的值。标记是缓冲区中的一个位置，即使由一些文本被从缓冲区删除或者增加到缓冲区，标记仍将保持它的相对位置。 goto-char将位点设置为由参量指定的位置。参量值可以是一个数，也可以是一个标记，甚至可以是一个返回一个位置数字的表达式(point-min) insert-buffer-substring将来自一个缓冲区（这是被作为一个参量而传递给函数的）的文本域拷贝到当前缓冲区 mark-whole-buffer将整个缓冲区标记为一个域。一般将这个函数绑定到C-x h。 set-buffer将Emacs的注意力转移到另一个缓冲区，但是不该便显示的窗口。 get-buffer-create\get-buffer寻找一个已指定名字的缓冲区，或当指定名字的缓冲区不存在时就创建它。如果指定名称的缓冲区不存在，get-buffer函数就返回nil。 练习 编写自己的simplified-end-of-buffer函数定义，然后测试它是否能工作。 12345(defun simple-end-of-buffer() &quot;移动光标至buffer结束处&quot; (interactive) (push-mark) (goto-char (point-max))) 用if和get-buffer编写一个函数，这个函数要打印一个说明某个缓冲区是否存在的消息 1234567(defun is-exist-buffer (buffer-or-name) &quot;判断buffer-or-name是否为一个已存在的buffer&quot; (if (bufferp (get-buffer buffer-or-name)) (message &quot;%s存在!&quot; buffer-or-name) (message &quot;此缓冲区不存在!&quot;))) (is-exist-buffer &quot;test.el&quot;) ;; =&gt; &quot;test.el存在!&quot; 用find-tag找到copy-to-buffer函数的源代码 不会… 第五章 更复杂的函数本章我们将在已学内容的基础之上学习更复杂的函数，例如有使用两次save-excursion的copy-to-buffer函数，以及一个在interactive中使用*和or函数的函数。 copy-to-buffer函数的定义copy-to-buffer函数与前面学过的append-to-buffer的定义很类似。 copy-to-buffer是替换指定BUFFER的内容，而append-to-buffer是在指定BUFFER中追加内容。 首先来看看copy-to-buffer的函数定义: 12345678(defun copy-to-buffer-t (BUFFER START END) &quot;docutments...&quot; (interactive &quot;BCopy to buffer: \nr&quot;) (let ((oldbuf (get-buffer-create BUFFER))) (save-excursion (set-buffer BUFFER) (save-excursion (insert-buffer-substring oldbuf START END))))) 略过函数名与文档不看，可以看到这个函数被定义为交互式函数，并且这个函数的参量要求是一个BUFFER对象，以及两个表示位置的数字。这三个参量都由interactive所解决，其使得让用户选择一个BUFFER，然后获取当前Buffer的point和mark，作为START和END。 随后是一个let表达式，其在它的varlist部分将BUFFER参量通过get-buffer-create函数获取了其对象(就算BUFFER参量的值不存在也会创建一个)，并且将这个BUFFER对象赋值给oldbuf。在let表达式的BODY部分，出现了一个save-excursion函数，这个函数用于记录当前point和mark的位置，然后在其参量求值完毕后恢复记录的位置，这个参量也就是set-buffer，这个函数用于改变当前BUFFER为 参量BUFFER。随后又是一个save-excursion函数，其参量 insert-buffer-substring函数我们也了解过，其用于将当前BUFFER的START到END之间 的区间插入到oldbuf内。 insert-buffer函数的定义前面我们用过append-to-buffer以及copy-to-buffer，他们都是将当前BUFFER的内容拷贝或追加到某一个BUFFER中，而insert-buffer可以将当前BUFFER的内容，拷贝至一个已存在的BUFFER当中。 先来看看其函数定义: 12345678910111213(defun insert-buffer-t (buffer) &quot;docutmens..&quot; (interactive &quot;*bInsert buffer: &quot;) (or (bufferp buffer) (setq buffer (get-buffer buffer))) (let (start end newmark) (save-excursion (save-excursion (set-buffer buffer) (setq start (point-min) end (point-max))) (insert-buffer-substring buffer start end) (setq newmark (point))) (push-mark newmark))) 先简单整理一下这个函数都包含了什么东西: 一个参量 函数文档 定义交互式函数 interactive参量说明有*和 b 以及一个or函数，这个函数内有两个参量 第一个参量是bufferp函数 第二个参量是setq函数，setq的第二个参量是get-buffer函数。 随后是一个let表达式 let表达式中先是初始化了三个空变量 一个外层save-excursion函数 一个内层save-excursion函数 其第一个参量是一个set-buffer函数 第二个参量是setq函数 外层save-excursion的第二个参量是一个insert-buffer-substring函数 第三个参量是一个setq函数。 最后是一个push-mark函数。 insert-buffer函数中的交互表达式让我们先从interactive表达式说起，首先起表达式说明分为三个部分： *代表只读缓冲区，这个说明会在当b说明返回的buffer是一个只读缓冲区时在回显区提示错误。也就是说当这个insert-buffer函数当在一个只读缓冲区被调用时，将不被允许。 b代表要求是一个存在的缓冲区或者是缓冲区名，它与B说明不同。 Insert buffer:是友好的提示。 提示:*控制符无需后接一个换行符来分割不同的参量。 insert-buffer函数体主要有两个部分，分别是or函数和let函数。 先让我们来看看or函数，其第一个参量是一个bufferp函数，这个函数用于当其参量是是一个已存在的buffer或buffer的名称才会返回non-nil的值，也就是真/非假，其第二个参量是一个setq函数，里面有一个get-buffer函数，这个函数是用于获取一个已存在的buffer对象根据buffer对象或buffer的名称，并将buffer绑定到get-buffer的值之上。 其实这个函数的意思是，要让buffer参量确定是一个已存在的buffer，我们可以用if函数重写一遍。 用if表达式编写insert-buffer函数我们的需求是，必须确保buffer的值是一个已存在的buffer或buffer的名称。 12(if (not (bufferp buffer) (setq buffer (get-buffer buffer)))) 就可以这样写，当bufferp函数的值为nil时，那么就会尝试获取buffer的对象并且保存，否则则报错。 insert-buffer函数中的let表达式在我们确保buffer参量是一个非只读缓冲区后，可以开始写拷贝内容的代码了。 首先我们初始化三个空变量: start end newmark let表达式体中有一个外层save-excursion函数，其记录了我们的point和mark，其第一个参量又是一个save-excursion函数，我们称为内层save-excursion。内层save-excursion主要做了两件事，首先是将Emacs的注意力转移到buffer之上，随后为start以及end附上buffer的point-min和point-max的值，并且由于内层save-excursion已经求值完毕，那么会恢复在求值过程中可能变动的位点和标记的值。随后外层save-excursion函数的第二个参量是将buffer参量的内容插入到当前buffer从start到end结束的内容，这个start和end也就是buffer参量所有的内容。随后又把newmark变量绑定到值point之上，最后将newmark记录为标记。 beginning-of-buffer函数的完整定义前面我们尝试写了beginning-of-buffer函数的部分定义，它是一个无参量的函数，那么这次我们来写一个有参量的beginning-of-buffer函数。 这个带参量的beginning-of-buffer函数可以指定在当前缓冲区的几分之几标记位置。 那么现来说下需求:beginning-of-buffer函数接受一个可选参量，这个参量的返回是1-10之间，这个参量作为标记点的位置。 可选参量在需求里我们提到: beginning-of-buffer函数接受一个可选参量 除非特别声明，否则Lisp会认为函数的参量是必须在函数被调用时传递一个值给该参量的。如果不传入参量，则该函数就会出错:Wrong number of arguments。 而如果需要使一个或多个参量变为可选参数只需要在参量前加上&amp;optional关键字，例如: 123456789(defun beginning-of-defun-function-t (&amp;optional arg1 arg2) &quot;documentation&quot; (interactive &quot;P&quot;) (push-mark) (goto-char ;; if-there-is-an-argument ;; xxxx ;; else-go-to (point-min))) 对比前面的simple-beginning-to-buffer函数，好像唯一多的地方是在goto-char函数的第一个参量，变成了if特殊表。这个if函数判断由interactive的P参量获得到的前缀参量是否为一个非nil值，如果是则执行if then部分，否则执行跟simple-beginning-to-buffer一样的操作。 带参量的beginning-of-buffer函数goto-char函数中有一个if表达式，这个表达式做了很多关于算术的操作。 123456789101112(defun beginning-of-defun-function-t (&amp;optional arg) &quot;documentation&quot; (interactive &quot;P&quot;) (push-mark) (goto-char (if (&gt; (buffer-size) 10000) (/ (prefix-numeric-value arg) 10) (/ (+ 10 (* (buffer-size) (prefix-numeric-value arg))) 10)) (point-min))) 一眼看上去有些复杂，其实我们通过函数模板来揭开其中的奥秘，十分简单。 我们看将if函数的结构看成这样: 123(if (buffer-is-large divide-buffer-size-by-10-and-multiply-by-arg) else-use-alternate-calculation) 要吃饭了 这里的if函数用于检查缓冲区的大小，这是因为书中使用的是第18版本的Elisp，其使用了不大于800w的数字来描述缓冲区的大小，如果有在某次求值中遇到更大的缓冲区，Emacs就会试图用更大的数来描述它(通常叫做overflow溢出)。 那么现在就有两种情况了，分别是超大缓冲区和正常的缓冲区，这两种不同数量级的缓冲区有不同的处理方式，先来看看那超大缓冲区的处理方式 当(if (&gt; (buffer-size) 10000))时，执行if表达式的then部分，这部分内有一个prefix-numeric-value用于将从(interactive &quot;P&quot;)读入的参数转为一个数字，也就是把arg的值转为数字，并且将其除以10，這樣可以讓產生的數比緩衝區中相應的比例多只多一個字符。 完整的beginning-of-buffer函數12345678910111213141516171819(defun beginning-of-buffer-t (&amp;optional arg) &quot;Move point to the beginning of the buffer;leave mark at previous position.Wwith arg N, put point N/10 of the way from the true beginning.Don&apos;t use this in Lisp programs!\(goto-char (point-min)) is fasterand does not set the mark.&quot; (interactive &quot;P&quot;) (push-mark) (goto-char (if arg (if (&gt; (buffer-size) 10000) ;; Avoid overflow for large buffer sizes! (* (prefix-numeric-value arg) (/ (buffer-size) 10)) (/ (+ 10 (* (buffer-size) (prefix-numeric-value arg))) 10)) (point-min))) (if arg (forward-line 1))) 回顧慣例抄書 or 逐一對每一個參量求值，並返回第一個非空值（不是nil)。如果所有參量的值都是nil，則返回nil。 and 逐一對每一個參量求值，如果有任意一個參量的值爲nil，則返回nil，並且隨後的參量不會進行求值。 &amp;optional 指定函數定義時參量爲可選項，如果有任意參量前有&amp;optional則表明當前且隨後的參量都是可選參量。 prefix-numberic-value 將由 (interactive &quot;P&quot;)產生的尚未加工的前綴參量轉換成一個數值。 erase-buffer 刪除當前緩衝區的所有內容 bufferp 如果參量是一個buffer對象則返回真，否則返回 nil。 &amp;optional 參量練習題目 編寫一個帶可選參量的交互參量，這個函數要測試函數被調用時是否有參量（其值是一個數），這個數是否大於或小於fill-column的值，並將結果以一個消息的形式給出。然而，如果不帶參量調用這個函數時，則使用56作爲默認值。 解答 12345678910(defun bigger-fill-column (&amp;optional arg) &quot;判斷是否大於fill-columnARG爲可選參量，默認值爲56&quot; (interactive &quot;P&quot;) (if arg (if (&gt; arg fill-column) (message &quot;%d大於fill-column的值&quot; arg) (message &quot;%d小於fill-column的值&quot; arg)) (if (&lt; 56 fill-column) (message &quot;fill-column的值大於於56&quot;)))) 第六章 變窄和增寬變窄(narrowing)是Emacs的一個特性，它的作用是使得當前buffer在開啓變窄後將變窄範圍之外的內容屏蔽。 上面提到的屏蔽不僅有視覺效果而且還對EmacsLisp解釋器有效。 save-restriction特殊表前面我們學習過save-excursion函數，其作用是記錄當前位點和標記的位置，而對於變窄，Emacs提供了一個save-restriction函數，其作用是記錄當前變窄的標記位置，當其表達式內參量求值完成後再恢復記錄過的變窄的標記位置，這麼做可以讓當遇到取消變窄的表達式後可以恢復。 其函數模板見: 1(save-restriction body...) 注意: 如果同時連續使用save-excursion函數和save-restriction函數時必須將save-excursion函數放在save-restriction之前，類似於: 12(save-excursion (save-restriction)) 如果位置反過來則會出現save-excursion無法記錄變窄範圍之外的標記。 what-line函數這個函數是一個典型的同時使用save-restriction和save-excursion的例子，其作用是返回當前光標所在當前buffer的行數。 先看看它的實現: 123456789(defun what-line () &quot;Print the current line number (in the buffer) of point.&quot; (interactive) (save-restriction (widen) (save-excursion (beginning-of-line) (message &quot;Line %d&quot; (1+ (count-lines 1 (point))))))) 首先看到widen函數，這個函數可以取消變窄開啓，但是它被save-restriction包住，這意味着就算取消了變窄開啓，save-restriction也可以保證變窄範圍不會變化. 再看到beginning-of-line，這個函數會移動point到當前行的首個字符.明顯這個函數改變了point值，不過由於save-excursion的出現，這些改變位點和標記的操作都將會被恢復。 前面所做的類似widen和beginning-of-line都可以說是爲了後面真正求出行數的計算做的準備。 現在再讓我們看向(message)函數，裏面只是簡單的做了一個友好提示以及格式化，隨後讓我們注意(1+ (count-lines 1 (point)))，count-lines的作用是計算其第一個參量到第二個參量之間的總行數，至於1+是爲了處理一些疑難雜症。 練習：變窄題目 編寫一個函數，這個函數在即使設置了變窄開啓而使緩衝區的前一半不可見的情況下也能顯示出當前緩衝區的頭60個字符。要在顯示完成之後恢復位點、標記和變窄開啓等相關設置。對於這個練習題，要使用save-restriction、widen、goto-char、point-min、buffer-substring、message 和其他函數，真可以算得上是一個大雜燴。 解題 1234567891011(defun print-60-char () &quot;輸出當前buffer前60個字符變窄範圍之外也算&quot; (interactive) (save-restriction (widen) (save-excursion (message &quot;%s&quot; (buffer-substring (point-min) 60))))) 第七章 基本函數: car、cdr、cons本章學習car、cdr、cons等函數，這三個函數都是Lisp中非常基礎的函數。 car Contents of the address part of the Register. cdr Contents of the Decrement part of the Register. cons construct car和cdr函數我們見過類似這樣的列表: 1&apos;(cat dog tiger lion) 而這個列表的car也就是cat，car函數用於獲取列表的第一部分(也就是第一個符號)。 這個列表的cdr是(dog tiger lion)，cdr函數用於獲取列表的第二部分(除了首符號之外的符號)。 注意: 這裏由cdr獲取的部分是一個列表，而car獲取的部分只是一個符號罷了。 car和cdr函數都是非破壞性的，也就是說他們不會對操作對象有任何修改操作，只是讀取。 cons函數cons函數用於構造新列表，例如想要爲(cat dog tiger lion)中添加一個panda可以這麼寫: 1(cons &apos;panda &apos;(cat dog tiger lion)) ;; =&gt; (panda cat dog tiger lion) 注意: cons函數不能憑空構造一個新列表，其必須有一個待插入新元素的列表。 12(cons &apos;panda ()) (cons &apos;water &apos;(milk nongfu_spring)) ;; =&gt; (water milk nongfu_spring) 查詢列表的長度: length函數length函數可以獲取列表的長度，也就是元素的個數。 1(length &apos;(a b c d)) ;; =&gt; 4 也可以查詢空列表的長度: 1(length ()) ;; =&gt; 0 但是此函數必須有一個列表對象的參量: 1(length ) ;; =&gt; eval: Wrong number of arguments: length, 0 nthcdr函數nthcdr函數於cdr函數是有聯繫的，試想下如果你想要通過cdr函數獲取列表(cat dog lion)的最後一個元素，你可以這麼做: 1(cdr (cdr &apos;(cat dog lion))) ;; =&gt; (lion) 但假如這個列表的長度有10000，你想獲取最後一個元素還是用這種方式將會十分麻煩，這時候就可以使用nthcdr函數了，它可以重複cdr函數的操作。 123456;; 返回移出前五個元素的列表(nthcdr 5 &apos;(car dog lion tiger panda fish)) ;; =&gt; fish;; 返回移出前三個元素的列表(nthcdr 3 &apos;(car dog lion tiger panda fish)) ;; =&gt; (tiger panda fish);; 留下全部列表(nthcdr 0 &apos;(car dog lion tiger panda fish)) ;; =&gt; (car dog lion tiger panda fish) 注意: 當nthcdr第一個參量大於等於列表長度時將永遠得到nil值。 nthcdr函數也是不據破壞性的。 setcar函數setcar函數有些類似cons函數，只不過其會改變列表的值，也就是說具有破壞性的。 setcar將某個值替換某個列表的第一部分。 12345(setq animal &apos;(cat dog lion riger panda fish)) ;; =&gt; cat dog lion riger panda fish(setcar animal &apos;cow) ;; =&gt; cowanimal ;; =&gt; (cow dog lion riger panda fish) 於setcar類似的還有一個setcdr函數，其作用是將列表的第二個參量設置爲第一個參量的第二部分。 12345(setq animal &apos;(cat dog lion riger panda fish)) ;; =&gt; cat dog lion riger panda fish(setcdr animal &apos;(a b c d)) ;; =&gt; (a b c d)animal ;; =&gt; (cat a b c d) 練習題目 通過對幾個cons表達式求值，來構建一個四元素的，有關鳥的列表。試一試，當你對列表本身使用cons函數時會發生什麼？用一種魚取代這個列表的第一個元素。用其他魚的列表取代這個列表的其餘部分。 解題 1234567891011121314;; 鳥列表(setq fishes (cons &apos;sparrow (cons &apos;owl (cons &apos;kingfisher (cons &apos;ostrich ())))));; 魚取代鳥列表第一部分(setcar fishes &apos;多寶魚);; 魚列表取代鳥列表第二部分 (setcdr fishes (cons &apos;(甲魚 中華鱘) ()))fishes 第八章 剪切和存儲文本 本人又可以用回简体中文啦！ 而且词库还增加了！可以打字更快了呢！ 首先需要先引入一个概念————在Emacs中有一个kill环，这个环记录了kill的数据，在这里的kill不代表“杀死”，而是clip的意思。 zap-to-char函数书中讲了zap-to-char函数的两个版本，分别是第19版和第18版。 先让我们来看啊可能zap-to-char函数的第19版本。 123456789(defun zap-to-char (arg char) ;; version 19 implementation &quot;Kill up to and including ARG&apos;th occurrence of CHAR.Goes backward if ARG is negative; error if CHAR not found.&quot; (interactive &quot;*p\ncZap to char: &quot;) (kill-region (point) (progn (search-forward (char-to-string char) nil nil arg)) (point))) 简单的描述下这个函数做了什么: 这个函数的功能是将当前位点到指定字符之间的字符串剪切到kill环内，其ARG的作用是指定指定字符的次数(可能会有多个指定字符，所以可以选择是哪一个)。 例如有这么一段文字:Thus,if the cursor were are begining of this sentence... 我们的光标处于if the的t之上，当我们通过传递前缀参量2给zap-to-char函数，并且指定zap-to-char函数的CHAR参量为s就会发现the cursor were are beginning of this被截取了，并且通过C-y(Yark)可以将剪切掉的文本找回。 interactive 表达式让我们看看interactive表达式: 1(interactive &quot;*p\ncZap to char: &quot;) 双引号部分的作用: -r *代表只读缓冲区，也就是说当我们尝试对一个只读缓冲区使用zap-to-char函数将会 获得一个报错信息。 p代表这个函数可以传递一个数值类型的前缀参量。 \n 换行 c代表这个函数会提示输入一个字符类型的值。 Zap to char:一个友好的提示，冒号后面的空格只是让格式更好看罢了。 通过分析我们大概能知道，这个interactive表达式可以做到 监测是否为只读缓冲区，并且支持通过前缀参量传递数值类型的值，在使用这个函数时还会提示输入一个字符。 zap-to-char函数体函数体内通过几行简短的代码完成将当前位点到指定字符之间的文本添加到kill环内并删除的操作。 跳过interactive表达式，可以看到所有的代码都被一个kill-region函数给包裹起来了，其第一个参量是(point)，也就是当前的位点位置，第二个参量是progn函数，要讲解这个函数的作用先让我们看看search-forward函数。 search-forward函数或许你曾经使用过search-forward函数，它接收四个参量: 第一个参量是要查找的字符 第二个参量(可选)是指定查找范围，可以绑定当前Buffer的一个位置. 第三个参量(可选)是当查找不到时，可以指定一个返回值，如果为t，则再出错时只返回一个nil，如果既不为nil也不为t，则使搜索改变，并且返回一个nil，如果为nil则返回出错信息。 第四个参量(可选)是重复计数值————待查找字符出现的次数，如果值为负数则从后查找。默认值为1。 注意: 找到某个字符后位点也会随之改变。 progn函数progn函数很简单，它的作用就是将任意多个参量进行一一求值，并且返回最后一个参量的值。 在这个函数内将kill-region所需的第二个参量获取出来了。 首先使用search-forward函数将位点改变到要查找的字符上，然后再对(point)求值，利用自身特性返回最后一个参量的值，从而让kill-region函数正常工作。 总结zap-to-char函数了解了search-forward以及progn函数后我们大致能了解zap-to-char函数的工作方式了。 其中kill-region作用是将某个区域的字符添加到kill环，并且删除，其接收两个参量，第一个参量作为区域的开始，第二个参量作为区域的结束，区域开始很容易获取，通过对(point)求值可以得到，而区域的结束也就是我们要查找的字符的位置，首先通过progn函数将多条函数放在一个函数内，其中里面的search-forward将位点改变为待查找的字符上，由于search-forward函数的第一个参量必须要是一个字符串类型的值，所以我们将通过interactive函数获取的字符由char-to-string转化为字符类型，其次由于位点改变后我们再对(point)求值，可以获取区域结束的位置了。 第18版本的zap-to-char函数 个人感觉18版本的zap-to-char很复杂，但是也很精妙的体现出Emacs开发者的智慧。 第18版本的zap-to-char函数跟第19版本的区别在于，第18版本的剪切区域是去除待查找字符本身的。 先让我们看看代码: 1234567891011121314151617(defun zap-to-char-18 (arg char) (interactive &quot;*p\ncZap to char: &quot;) (kill-region (point) (if (search-forward (char-to-string char) ;; target nil ;; bind buffer position t ;; return arg) ;; repetition count (progn (goto-char (if (&gt; arg 0) (1- (point)) (1+ (point)))) (point)) (if (&gt; arg 0) ;; else-part (point-max) (point-min))))) 18版本的zap-to-char看起来更加复杂，并且功能也更多。 首先，两个版本的主要作用基本相同，都是为了将当前位点到指定字符的位置之间的区域剪切，18版本相比较于19版本，多了几个特性: 不会剪切指定字符(忽略指定的字符，其他的剪切) 当指定字符不存在将会改变位点为buffer的位点最小值或最大值。 下面让我们来分析下吧! 看到interactive表达式，并没有任何改变，这里可以忽略。而kill-region的第一个参量仍然是当前位点，后面则有巨大的改变。第二个参量被一个if表达式包裹住，这个if表达式的CONS部分是一个search-forward函数，其作用是判断指定字符是否存在，如果存在则执行THEN部分的progn表达式。 progn表达式主体progn函数的表达式主体内有两个参量，根据progn函数的特性，我们知道，只有最后一个参量会被返回，先看看第一个参量， 是一个goto-char函数，让我们回顾下18版本的特性，其在剪切时会忽略指定的字符，那么这个goto-char函数就是做了这么件事，当ARG大于0时(往前搜索时字符出现的次数)，那么就将位点往后挪一，反之加一。最后由于改变了位点， 并且progn函数的第二个参量是(point)又将改变后的位点返回，也就成了kill-region函数的结束区域了。 最后是if表达式的ELSE部分，其作用是当为查找到指定字符时，将会根据ARG的值来判断剪切到最后还是最前。 kill-region函数在前面的zap-to-char函数使用了kill-region函数，现在让我们来康康这个函数的内部实现吧！ 123456(defun kill-region-19 (begin end) &quot;Kill between point and mark.The text is deleted but saved in the kill ring.&quot; (interactive &quot;*r&quot;) (copy-region-as-kill begin end) (delete-region begin end)) 注意: 看注释 delete-region函数:接触Ckill-region函数的delete-region函数是一个由C语言宏编写的函数，让我们看看它的第一部分: 12345678910DEFUN ("delete-region", Fdelete_region, Sdelete_region, 2, 2, "r", doc: /* Delete the text between START and END.If called interactively, delete the region between point and mark.This command deletes buffer text without modifying the kill ring. */) (Lisp_Object start, Lisp_Object end)&#123; validate_region (&amp;start, &amp;end); del_range (XINT (start), XINT (end)); return Qnil;&#125; 这里不过多解释(书中没讲，本人也不太了解) 这个宏可以分为7个部分分别是: Lisp 中的函数名，也就是被双引号括住的”delete-region”。 C语言中的函数名，也就是Fdelete_region。 C常数结构名，Sdelete_region。 第四和第五部分是指明函数参量数目的最小和最大值。 第六部分就像interactive函数的说明表达式一样， 这里是”r”，代表函数的两个参量是某个缓冲区中某个区域的开始和结束。 第七部分是文档字符串，跟Emacs Lisp的函数文档不同在于换行时必须显式的写出\n。 再后面就是真正的函数参量，并且每个参量所对应的数据类型都有一段解释。 下面则是函数的主体了，其中validate-region函数用于检查参量的值的类型，而del-range函数则是用于删除区域内字符的函数。 用defvar初始化变量defvar用于初始化变量，想必有些小伙伴会想到setq，defvar与其的区别在于: defvar只能为无值的变量赋值。 defvar如果在为一个有值的变量赋值时将不会覆盖。 由defvar设置的变量可以给予变量文档。 123456(defvar box nil &quot;Just a test box&quot;)box ;; =&gt; nil(defvar box 20 &quot;Just a test box&quot;) box ;; = &gt; nil 不是说由 defvar定义的变量就不能够重新赋值了，其实是可以的，但是必须在变量文档前加上*，并且由setq变量重新赋值。 123456789(defvar t-box nil &quot;*Just a test box&quot;)t-box ;; =&gt; nil(defvar t-box 20 &quot;*Just a test box&quot;)t-box ;; =&gt; nil(setq t-box 20)t-box ;; =&gt; 20 copy-region-as-kill函数 这一小节我鸽了好久，原因是内容有点多，我懒得写。。 好了，让我们继续写吧(刚刚看了欧阳娜娜的Vlog，感觉真好)！ 先让我们看看这个函数的源码: 123456789101112131415(defun copy-region-as-kill (begin end) &quot;Save the region as if killed, but don&apos;t kill it.&quot; (interactive &quot;r&quot;) (if (eq last-command &apos;kill-region) ;; then-part: Combine newly copied text with previously copied text (kill-append (buffer-substring begin end) (&lt; end begin))`` ;; else-part: Add newly copied text as new element`` ;; to the kill ring and shorten the kill ring if necessary (setq kill-ring (cons (buffer-substring begin end) kill-ring)) (if (&gt; (length kill-ring) kill-ring-max) (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))) (setq this-command &apos;kill-region) (setq kill-ring-yank-pointer kill-ring)) 由于书上的内容我是前几天看的，而我每次写笔记又是直接根据源码来解读的，所以跟书上有些表达不同（甚至有错误），希望各位能理解（有没有人看都是个问题..)。 根据这个函数的文档可以知道，这个函数的作用是:如果某个区域被剪切过了那么就将其保存，但是并不再一次剪切。 copy-region-as-kill函数接收两个参量，它们分别代表了两个位置，通过这两个位置可以确定一个区域。 copy-region-as-kill函数体把视野转向interactive函数，其表达式只有一个r，它的作用是：代表这个函数接收一个region，也就是把point和mark作为这个函数的两个参量以数值类型传递过去。 随后让我们看到if特殊表，它几乎涵盖了整个函数体，下面我们来看看其CONS部分的作用。CONS部分如下: 1(eq last-command &apos;kill-region) 这里有一个我们没有遇到过的函数————eq，其作用跟equal函数类似，用于比较，但eq函数比较的是其参量的对象是否相同，然而eqaul函数用于判断其参量的内容或结构是否相同。 这里就是将last-command与kill-region进行比较，其中last-command是一个变量，其作用是记录最后一个执行过的命令。在这个例子中就是将 Emacs最后一次执行的命令与kill-region进行对象比对，测试其是否为同一个对象。换种说法就是if特殊表判断最后一次执行的命令是否为kill-region。 如果是kill-region那么会发生什么呢？先让我们回顾前一章所学的kill-region，其作用是将某个region添加到kill环中，并将其删除，从而实现剪切的操作。并且由于其通常只被kill-region函数所使用，所以对于kill-region进行单独适配。 让我们看向THEN部分吧！ 1(kill-append (buffer-substring begin end) (&lt; end begin)) 整个THEN部分只有一个kill-append函数， 通过这个函数名我们就大概能猜到其作用是将数据追加到kill环的操作。 首先，kill-append函数接收两个参量，先说第一个，其要求第一个参量是一个STRING类型的数值，而这里就可以使用buffer-substrin函数获得要追加的字符串。第二个参量用于判断将STRING 放置于kill环中原数据之前还是之后，这里就是将end与begin进行比较，如果结束位置小于开始位置则代表用户想要从缓冲区的开始往后剪切，否则是从缓冲区后往前进行剪切。 下面我们看ELSE部分，这个部分是当最后一个执行的命令不是kill-region时触发的，其作用让我们潸潸道来，首先是用setq函数更新kill-ring中的数据: 12(setq kill-ring (cons (buffer-substring begin end) kill-ring)) 其为kill-ring重新赋值，值为通过buffer-substring函数获取的字符串，并将其通过cons函数将字符串设置为kill-ring的car部分。 随后是一个if表达式，这个表达式的作用是防止kill环的长度超过kill-ring-max的值，如果当前kill-ring的长度超过kill-ring-max，那么就将kill-ring最后一个元素去除。去除的方式是通过setcdr以及nthcdr函数，首先通过nthcdr函数获取kill 环中最后一个元素，再通过setcdr函数将其设置为nil。 到此，涵盖整个函数体的if表达式就执行完了，后面的则一些后续的工作，例如设置this-command值为kill-region函数。 最后的: 1(setq kill-ring-yank-pointer kill-ring) 中的kill-ring-yank-pointer也只不过是kill-ring的一个全局变量的复制品罢了。 回顾 cdr,carcar 返回一个列表的第一个元素，cdr返回从列表第二个元素开始到最后一个元素的列表。 cons这个函数用于将其第一个参量插入至第二个参量从而构造一个新列表。 nthcdr获取第一个参量个第二个参量的cdr部分。 setcdr、setcarsetcar用于设置列表的car部分，setcdr用于设置列表的car部分。 progn这个函数可以依次对其多个参量求值并最终返回最后一个参量的值。 save-restriction这个函数用于记录当前缓冲区变窄是否设置，如果设置那么其后续的参量求值后都将恢复记录过的变窄设置。 search-forward这个函数用于查找字符串，如果查找就将当前位点改变为查找到的字符串的位点。并且其还自带四个参量: 要查找的字符串 查找的限制范围(region) 如果查找失败的处理方式，如果为nil则返回错误信息。 重复查找多次 kill-region此函数将region复制进kill环并 将其在buffer中删除。 delete-region将某个region之间的数据全部删除。 copy-region-as-kill将某个region之间的数据复制进kill环。 查找练习 编写一个查找字符串的交互函数。如果找到需要的字符串，在其后设置位点并显示这样的一条消息:”Found!” 12345(defun search-forward-t (str) (interactive &quot;MSearch String:&quot;) (let ((isfound nil)) (if (search-forward str nil nil nil) (message &quot;Found!&quot;)))) 编写一个函数，这个函数在回显区打印kill环的三个元素，如果kill环没有第三个元素，则打印一条适当的消息。 1234(defun print-kill-ring-three () (if (nthcdr 3 kill-ring) (nthcdr 3 kill-ring) (message &quot;kill-ring not have 3&apos;th cdr&quot;))) 在第19.29版中，copy-region-as-kill函数不再设置this-command变量。这种变化的后果是什么？要采取什么相应的变化，才能达到相同的效果? 答: 不会 第九章 列表是如何实现的本章讲述的是列表的原理而不是实现，也不知道书中为何要这么起标题。 列表是由一系列的成对指针构成的，这每对指针的第一个指针要么指向一个原子，要么指向另一个列表，而第二个指针要么指向下一个系列列表要么指向nil，nil也就代表这整个列表系列中最后一个列表。 指针其实就是一个指向电子地址的玩意，由此可得知列表就是一堆指向电子地址的指针。 那一个简单的列表举例 1&apos;(rose violet buttercup) 这个列表中有三个元素，每个元素也就是我们所说的一个成对的指针，如图: 123456 ___ ___ ___ ___ ___ ___|___|___| --&gt; |___|___| --&gt; |___|___| --&gt; nil | | | | | | --&gt;rose --&gt; violet --&gt; buttercup 上图每个方框都代表计算机中的某个地址，例如，第一个方框中保存的就是指向”rose”的地址，你也可以直接理解为保存的就是”rose”的地址，计算机可以直接通过地址来访问”rose”这个数据。而第二个方框要么指向下一个元素要么指向nil，这里是指向的下一个元素的地址，这个地址也就是第二个成对方框的地址，而这第二个元素的第一个方框中保存的是“violet”的地址，跟第一个元素的第一个方框一样，有不同的在于第三个元素的第二个方框，它指向的是一个nil，代表这个元素是这个列表最后的元素，也就是用于标记结束。 如果我们通过setq函数将这个整个列表赋值给一变量这个图会怎么表示呢? 1(setq bouquet &apos;(rose violet buttercup)) 我们知道setq的第二个参量是一个列表，所以只需要将这个列表的第一个元素的地址赋值给bouquet，这样就可以通过bouquet访问这个花(上面的这个列表可以称为花列表，因为它们都是花的名称)列表了。 用图表示: 12345678bouquet | | | ___ ___ ___ ___ ___ ___ --&gt; |___|___| --&gt; |___|___| --&gt; |___|___| --&gt; nil | | | | | | --&gt;rose --&gt; violet --&gt; buttercup 前面说过Lisp中除了列表就是原子，像前面这个花列表的每个元素也可以称为一个列表或是cons，因为是成对的结构，我们可以理解为car和cdr的关系，如果用图可以这样表示: 1234567bouquet | | ________ _______ ________ ________ _________ ________ --&gt; | car | cdr | | car | cdr | | car | cdr | | rose | 0 ----&gt; | violet | 0 ----&gt; | butter- | 0 | | | | | | | | cup | | ------- ------ -------- -------- --------- -------- 对于函数来说，我们可以将它的结构想象成一个抽屉，通过下图来将想象的抽屉画出来: 1234567891011121314151617181920 抽屉箱子 抽屉内容 ___________________| || symbol name | --&gt; bouquet| | -------------------| || symbol definition | --&gt; [none]| | -------------------| || variable value | --&gt; (rose violet buttercup)| | -------------------| || property list | --&gt; [not describe here]| | -------------------|/ \| ELisp把符号定义、变量值、符号名放在单独的抽屉内，每个抽屉内存储的是其指向的真正数据的地址，这样做的好处是例如在改变变量值时其他的符号不会有任何改变。 其实还有一个属性列表，书中没有讲，有兴趣的可以点下这个连接Property List With GNU-EMACS Manual 符号讲完，我们再继续讨论，如果将一个列表的cdr部分赋值给一个变量，那么用图怎么表示它的结构呢？先看看如下代码: 1(setq flowers (cdr bouquet)) 其实十分简单，也只不过是通过cdr函数取出bouquet变量所指向的花列表的第二部分，然后将其地址赋值给flowers变量。 12345678bouquet | flowers | | | ___ ___ | ___ ___ ___ ___ | | | | --&gt; | | | | | | --&gt; |___|___| --&gt; |___|___| --&gt; |___|___| --&gt; nil | | | --&gt;rose --&gt; violet --&gt; buttercup 带点偶对带点偶对(dotted pair)又被称为cons原胞(cons cell)，它代表一个成对的地址框。 我们都知道cons函数会把第一个参量作为新元素插入到第二个列表类型的参量中作为car部分，那如果插入一个新值其他与其他元素有关系的符号会不会有影响呢？请看代码和图: 1(setq bouquet (cons &apos;lily bouquet)) 上段代码可以得到下图: 12345678bouquet | flowers | | | ___ ___ ___ ___ | ___ ___ ___ ___ | | | | | | | --&gt; | | | | | | --&gt;|___|___|--&gt; |___|___| --&gt; |___|___| --&gt; |___|___| --&gt; nil | | | --&gt; lily --&gt;rose --&gt; violet --&gt; buttercup 如果用eq函数将flowers与bouquet的nthcdr 2 部分进行比较会是怎样呢? 1(eq flowers (nthcdr 2 bouquet)) 我们发现flowers的值并没有变化，这完全是因为Lisp中，想要得到一个列表的cdr，只要得到地址系列中下一个cons原胞的地址即可；要得到一个列表的car只需要的得到这个列表的第一个元素的地址；而要插入一个新元素，只不过是往列表中添加了新的cons原胞罢了。 经过上面的演示，可以得到一个列表最后一个cons原胞的最后一个地址指向的是。 练习将符号flowers设置为violet和buttercup两个元素组成的列表啊。 往这个列表中增加两种新的花名，并将这个列表赋值给more-flowers变量。将flowers的car设置为一种鱼的名字。看一看more-flowers列表现在的内容是什么? 1234(setq flowers &apos;(violet buttercup)) ;; ==&gt; (violet buttercup)(setq more-flowers (cons &apos;chrysanthemum (cons &apos;carnation flowers))) ;; ==&gt; (chrysanthemum carnation violet buttercup)(setcar flowers &apos;shark) ;; ==&gt; sharkmore-flowers ;; ==&gt; (chrysanthemum carnation shark buttercup) 第十章 找回文本 女朋友闹分手，很好(都是我的错)，我又有时间学习了.]]></content>
      <tags>
        <tag>EmacsLisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[参加广州LUG线下见面会]]></title>
    <url>%2F2019%2F12%2F15%2F%E5%8F%82%E5%8A%A0%E5%B9%BF%E5%B7%9ELUG%E7%BA%BF%E4%B8%8B%E8%A7%81%E9%9D%A2%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[今天下午我去参加了广州LUG线下见面会! &Emsp;&emsp;首先先对持续关注(Nobody)我博客的同仁们说声抱歉，博客好像有几个月没有更新了，主要是因为从NeoVim换为Emacs还未习惯。再加上我一直在找直接编写org文件，然后让后端渲染器能直接渲染org文件的博客后端渲染器。中间也确实见到过几个，例如org-page，但折腾来折腾去也未折腾好，所以还是使用Emacs编写Markdown吧。]]></content>
      <categories>
        <category>个人感想</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-文本处理三剑客-3]]></title>
    <url>%2F2019%2F12%2F12%2FLinux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2-3%2F</url>
    <content type="text"><![CDATA[4.1 grep: 文本过滤工具命令详解功能说明 grep命令可以从文本文件或管道数据流中筛选匹配的行或数据，还可以配合正则表达式一起使用。 语法格式 1grep [参数] [匹配模式] [需要查找的文件] 选项说明 参数选项 解释说明 -v 排除某行 -n 显示匹配行及行号 -i 不区分大小写 -c 统计匹配行数 -E 使用egrep命令替代grep –color=auto 为grep过滤后匹配的字符串添加颜色 -w 只匹配过滤的单词 -o 只输出匹配的内容 使用范例 基础范例 使用grep过滤不包括evanmeek字符串的行(-v参数实践) 1234567891011121314➜ cat test.txt ChinaJapanrootEvanMeekMyBlogevanmeek➜ grep -v "evanmeek" test.txtChinaJapanrootEvanMeekMyBlog 提示: grep命令-v参数正如刚刚输出所示，会将过滤参数后的内容。 使用grep过滤包括evanmeek字符串的行，并显示其所在行行号(-n实践) 12345678910111213# 文本内容相同，我们使用下面这条命令，看看会发生什么➜ grep -n "evanmeek" test.txt # 我们得到了test.txt中包含evanmeek的行且行号。# 我们也可以使用.匹配任意内容，相当于看test.txt文件内容加上行号➜ grep -n "." test.txt 1:China2:Japan3:root4:EvanMeek5:MyBlog6:evanmeek6:evanmeek 不区分大小写参数实践 12345# grep在过滤时可以选择忽略区分大小写，默认是区分的# 文件内容相同,使用-i参数忽略大小写，-n参数选择要筛选的内容并有行号➜ grep -i -n "evanmeek" test.txt4:EvanMeek6:evanmeek 计算匹配的字符串的数量(-c参数实践)]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python-07]Python函数和Lambda表达式]]></title>
    <url>%2F2019%2F10%2F09%2FPython-07-Python%E5%87%BD%E6%95%B0%E5%92%8CLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Python系列第七章笔记，查看Python系列所有文章，请点击💿 本章记录定义函数、调用函数以及大量有关Python的高级内容。 还会记录Lambda表达式，学习完Lambda表达式后可以让源代码更加简洁。 Python函数（函数定义、函数调用）用法详解我们之前以及用到过很多的函数，例如:print() range() len() 等等，不过这些都是Python的内置函数，Python还允许我们自定义函数，也就是将一段代码定义成函数，从而达到一次编写、多次调用的目的 。 Python函数的定义想要定义函数需要使用def关键字实现，语法格式如下: 123def function_name([params]): code_space [return [value]] 其中由[] 括起来的为可选部分。 语法格式解释: function_name: 函数名，需要符合合法的标识符。 params: 形式参数列表，也就是定义该函数可以接受的参数。可以有多个，多个之间使用英文逗号(, )隔开。 code_space: 代码块，也就是调用函数时需要执行的代码，记得缩进。 注意: 在创建函数时，即使函数不需要参数，也必须保留括号。 例子: 123# 求最大值def my_max(x,y): return x if x &gt; y else y Python函数的调用调用函数也就是执行定义过的函数。 函数调用语法格式: function_name([params]) 注意:函数定义时有多少个参数，我们调用时就必须传入相同数量的参数个数。并且如果调用的函数原型没有参数，调用时也不能省略括号。 例子: 1print(my_max(10,20)) 运行过程: 12320[Process exited 0] 为函数提供说明文档前目提到过可以使用help() 命令查看指定函数的帮助文档。 想要为函数添加说明文档可以在函数声明后，代码块之前插入字符串以作为函数的说明文档。 例子: 123456def say_helloworld(): &quot;输出HelloWorld&quot; print(&quot;HelloWorld&quot;)print(help(say_helloworld))print(say_helloworld.__doc__) 运行过程: 12345678910Help on function say_helloworld in module __main__:say_helloworld() 输出HelloWorld(END)None输出HelloWorld[Process exited 0] Python函数值传递和引用传递(包括形式参数和实际参数的区别)形参实参的区别形参又被称为形式参数，也就是指：在定义函数时，函数列表中的参数，叫做形参。 实参又被称作实际参数，也就是指：在调用函数时，向函数列表中传递的参数，叫做实际参数。 值传递与引用传递值传递使用场景: 不可变类型(字符串，数字，元组)引用传递: 可变类型（列表、字典） 两者区别: 值传递的时候，实参传递给形参后，如果形参被修改，实参不收影响。引用传递时，则会改变。 例子: 123456789def change_param(x): x+=[4] if isinstance(x,list) else 1 print(x)a = 10change_param(a)print(a)b = [1,2,3]change_param(b)print(b) 运行过程: 1234561110[1, 2, 3, 4][1, 2, 3, 4][Process exited 0] Python函数参数传递机制(超级详细)本笔记不讨论，想要了解查看原文 Python位置参数一句话解释:调用函数时传入的实参的数量和位置必须和定义函数时的形参保持一致 Python关键字参数如果不想要记住参数的位置，我们可以使用关键字参数特性，在调用函数时为实际参数指定一个参数名。 例子: 1234def test(x,y,z): return x*y+zprint(test(10,20,10))print(test(z=10,y=20,x=10)) 运行结果: 1234210210[Process exited 0] 注意:如果要在传递实参时混用关键字参数与位置参数，必须确保关键字参数置于位置参数之前。 Python默认参数我们可以给形参指定默认参数，这样在调用时，可以省略传入实参。 例子: 12345def user_name(name=&quot;未命名&quot;): print(&quot;你的姓名:&quot;,name)user_name()user_name(&quot;EvanMeek&quot;) 输出结果: 1234你的姓名: 未命名你的姓名: EvanMeek[Process exited 0] Python 函数可变参数如果在编写函数时，不确定需要使用多少个参数，我们就可以使用可变参数这个特性。 可变参数有两种形式，分别是在形参之前添加个一* 与在形参之前添加个两* 。 可变参数:形参前添加一个*例子: 12345# 忽略这个反斜杠，因为markdown的缘故def test(x,\*y): print(type(x),&quot;\n&quot;,x) print(type(y),&quot;\n&quot;,y)test(10,&quot;你好&quot;,&quot;世界&quot;,9.09,0xa) 输出结果: 123456&lt;class &apos;int&apos;&gt; 10&lt;class &apos;tuple&apos;&gt; (&apos;你好&apos;, &apos;世界&apos;, 9.09, 10)[Process exited 0] 可以看到，实际上可变参数是将多个参数包含在一个元组内，然后将其输出。 可变参数:形参前添加两个*前面的第一种可变参数形式，是往形参前添加一个*，并且我们知道它其实就是个元组，那么第二种形式提前透露一下，它其实就是个字典 例子: 1234def test(x,**y): print(type(x),&quot;\n&quot;,x) print(type(y),&quot;\n&quot;,y)test(10,语文=100,数学=9.99,英语=8.88) 输出结果: 123456&lt;class &apos;int&apos;&gt; 10&lt;class &apos;dict&apos;&gt; &#123;&apos;语文&apos;: 100, &apos;数学&apos;: 9.99, &apos;英语&apos;: 8.88&#125;[Process exited 0] 可变参数：形参前添加两个*语法格式如下: **kwargs *kw表示创建一个名为kwargs的空字典，该字典可以接收任意多个以关键字参数赋值的实际参数。 例子: 1234def test(x,**y): print(type(x),&quot;\n&quot;,x) print(type(y),&quot;\n&quot;,y)test(10,语文=100,数学=9.99,英语=8.88) 运行结果: 123456&lt;class &apos;int&apos;&gt; 10&lt;class &apos;dict&apos;&gt; &#123;&apos;语文&apos;: 100, &apos;数学&apos;: 9.99, &apos;英语&apos;: 8.88&#125;[Process exited 0] Python逆向参数收集详解逆向参数也就是说将程序中定义的列表、元组、字典等对象的元素拆开后传递给函数的参数。 逆向参数收集需要在传入的列表、元组参数之前添加一个星号，在字典参数之前添加两个星号 例子: 123456789def get_sum(*x): sum = 0 for ele in x: sum += ele return sumnum_list = range(1,101)print(get_sum(*num_list)) 运行结果: 1235050[Process exited 0] 字典也支持逆向收集，字典会以关键字参数的形式传入。 例子: 1234567def get_student(stu_id,stu_name,**x): print(&quot;学号:&quot;+str(stu_id)) print(&quot;姓名:&quot;+str(stu_name)) print(&quot;其他:&quot;+str(x))stu_info = &#123;&quot;stu_id&quot;:0,&quot;stu_name&quot;:&quot;张三&quot;,&quot;stu_age&quot;:18,&quot;stu_address&quot;:&quot;广州市&quot;&#125;get_student(**stu_info) 输出结果: 12345学号:0姓名:张三其他:&#123;&apos;stu_age&apos;: 18, &apos;stu_address&apos;: &apos;广州市&apos;&#125;[Process exited 0] Python None(空值)及用法Python中有一个特殊的常量None，其表示为空值，它不等于空列表，也不等于空字符串。 None 具有自己的数据类型，通过type() 可以查看它的类型。 123&lt;class &apos;NoneType&apos;&gt;[Process exited 0] None 为NoneType 数据类型的唯一值，不能创建其他NoneType类型的变量，但是可以为任何变量赋值为None 。 None 常用场景是:assert断言，判断，以及函数无返回值。 Python return函数返回值详解语法格式: return [返回值] return 语句是用于给函数的调用处返回一个值。 return 语句可以在同一函数中出现多次，但只要有一个得到执行，就会结束函数的执行。 例子: 1234def sum(x,y): return x+yprint(sum(10,20)) 输出结果: 12330[Process exited 0] return 的返回值可以为任意类型。 Python函数返回多个值的方法Python允许函数同时返回多个值，它会将多个返回值封装成元组。 例子: 123456789def multi_return(): return 10,20,30,40# 序列解包a,b,c,d = multi_return()# 序列解包test_list = multi_return()print(a,b,c,d)print(test_list)print(multi_return()) 输出结果: 1234510 20 30 40(10, 20, 30, 40)(10, 20, 30, 40)[Process exited 0] Python partial偏函数及用法见原文 Python函数递归当一个函数体内调用自身，就被称为函数递归 。 我们可以使用函数递归来模式循环，但这种循环不需要使用循环控制。 下面我们做一个数学题: f(0)=1,f(1)=4,f(n+2)=2*f(n+1)+f(n)，其中n是大于0的整数，求f(10)的值。我们将会使用循环和递归两种不同的方式来求当f(10)的值。 递归例子: 123456789def fn(n): if n==0: return 1 elif n==1: return 4 else : return 2 * fn(n-1)+fn(n-2)print(fn(10)) 可以看到，我们在函数体内调用了自身，这样当我们执行到调用自身时，那么这就是递归，而对于来fn(10)说，也等于式子2*fn(9)+fn(8) ，而其中fn(9) 又等于2*fn(8)+fn(7) ，以此类推，最终当计算到fn(2) 等于2*fn(1)+fn(0) 时，那么就会开始返回，这个递归也就具有了结束的时候，最终得到fn(10)的值。 注意:递归类似于循环，必须在某个时刻函数的返回值是确定的，也就是不再调用自身，否则递归将会变成无穷递归，也就是死循环。 Python变量作用于(全局变量和局部变量)变量有作用的范围，这个范围被称为作用域。 作用域是值，代码能够访问该变量的区域，如果超出该区域将不可访问。** 变量的范围分为两种局部变量 和全局变量 。 Python局部变量局部变量是指在函数内部定义并使用的变量，它只在函数内部有效 。 例如: 1234567def text(): demo = &quot;HelloWorld&quot; print(demo)text()# 获取局部变量demoprint(demo) 输出结果: 1234567HelloWorldTraceback (most recent call last): File &quot;test.py&quot;, line 7, in &lt;module&gt; print(demo)NameError: name &apos;demo&apos; is not defined[Process exited 1] 可以看到程序报错了，那是因为后面的print(demo)语句访问了在当前作用于不存在的变量，所以就会报错。 局部变量:每个函数执行时，系统都会为该函数分配一块临时内存空间 ，所有局部变量都被保存在这块空间内。而当函数执行完后，系统将会将这块内存空间释放，从而局部变量也就失效了，因此当我们再次访问以为存在的局部变量时，解释器就会抛出错误NameError，因为根本不存在。 Python全局变量全局变量与局部变量相反，全局变量是指能够作用于函数内外的变量，也就是说全局变量可以在任何地方使用。 定义全局变量有两种方法: 在函数体外定义变量，一定是全局变量: 1234567demo = &quot;HelloWorld&quot;def text(): print(demo)text()print(demo) 输出结果: 1234HelloWorldHelloWorld[Process exited 0] 在函数体内定义全局变量。即使用global 关键字对变量进行修饰后，该变量就会变成为全局变量。 1234567def text(): global demo demo = &quot;HelloWorld&quot; print(demo)text()print(demo) 输出结果: 1234HelloWorldHelloWorld[Process exited 0] 注意:在使用global修饰变量时不可以直接给变量赋值。 获取指定作用于范围中的变量Python提供了三个函数用于访问指定作用于中的变量。 我们可以把变量与值理解为一个个字典，把key理解为变量名或变量的内存地址，把值理解为value。 而下面这三个方法就可以访问某个作用于下的所有字典。 globals() 该函数返回全局范围内所有变量组成的变量字典。 locals() 该函数返回当前作用域范围下所有变量组成的变量字典。 vars(object) 获取object所在作用域范围下所有变量组成的变量字典，若不给参数，则与locals() 无区别。 例子: 1234567891011121314151617181920def global_test(): global name global name2 global name3 name = &quot;Evan&quot; name2 = &quot;Chen&quot; name3 = &quot;Li&quot;global_test()print(&quot;全局作用于下所有变量字典:&quot;,globals())print(&quot;指定访问全局作用域下key为name2的变量字典:&quot;,globals()[&apos;name2&apos;])def local_test(): age=age1=age2=age3= 20 print(&quot;age:&quot;,age) print(&quot;age作用域下所有变量字典:&quot;,locals()) print(&quot;指定访问当前作用于下key为age的变量字典:&quot;,locals()[&apos;age&apos;])local_test()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python-06]Python流程控制]]></title>
    <url>%2F2019%2F09%2F28%2FPython-06-Python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Python系列第六章笔记，查看Python系列所有文章，请点击💿 Python中的流程结构也就是选择语句，选择语句又分为3种语法形式，分别是if、if else、if elif else。 if 语句语法格式: 12if 表达式: 代码块 if else 语句语法格式: 1234if 表达式: 代码块 1else: 代码块 2 if elif else 语句语法格式: 123456789if 表达式1: 代码块 1elif 表达式2: 代码块 2elif 表达式3: 代码块 3...else: 代码块 n 以上三种选择结构的语法形式差别不大，它们有个共性，就是当表达式的值为True时会执行代码块内的代码 。 选择语句的表达式相当于条件，当表达式的条件满足后，就会执行代码块内的代码啦。 注意:Python的代码块是通过缩进标记的，具有相同缩进的多行代码属于同一个代码块 . if表达式真假值得判断方法 表达式可以是任意类型，不过下面的几种类型将会被Python解释器当做False处理: Flase、None、0、&quot;&quot;、()、[]、{} Python if else语句用法范例(注意事项_)1)代码块不要忘记缩进 每一个缩进就代表了一个代码块，如果没有没有缩进程序可能会出现各种问题。 1234s_age = input(&quot;请输入您的年龄:&quot;)age = int(s_age)if age &gt;= 18:print(&quot;你成年了.&quot;) 输出结果: 1234File &quot;test.py&quot;, line 4 print(&quot;你成年了.&quot;) ^IndentationError: expected an indented block 有时没有缩进不代表程序没有错误。 123456s_age = input(&quot;请输入您的年龄:&quot;)age = int(s_age)if age &gt;= 18: print(&quot;你成年了.&quot;)print(&quot;成年了，就要修身养性.&quot;)print(&quot;你未成年.&quot;) 运行过程: 12345请输入您的年龄:10成年了，就要修身养性.你未成年.[Process exited 0] 虽然程序没有报错，但是确是不符合逻辑的，应该是当输入的年龄大于等于18岁才输出成年了，就要修身养性，但是由于没有将其缩进，所以造成了代码的运行结果不如人意。 2)语句不要随意缩进 我们必须保证同一个代码块内的代码必须保持相同的缩进，如果多一个缩进或少一个缩进都会出现不可预料的错误。 1234int a = 10if a &gt; 9: print(&quot;a &gt; 9&quot;) print(&quot;====&quot;) 运行结果: 1234 File &quot;test.py&quot;, line 1 int a = 10 ^SyntaxError: invalid syntax Python解释器抛出了一个SyntaxError错误 3)if表达式不要遗忘冒号 Python解释器将冒号表示为代码块的开始，如果遗忘冒号也会引发一些错误，因为Python解释器无法识别代码块的开始。 1234if 10 &gt; 9 print(&quot;9 &gt; 10&quot;)else: print(&quot;10 &lt; 9&quot;) 输出结果: 123456 File &quot;test.py&quot;, line 1 if 10 &gt; 9 ^SyntaxError: invalid syntax[Process exited 1] 以冒号作为代码块的开始在其他语句结构也是如此，例如循环、类等。 Python if语句嵌套此笔记不讨论此内容，如需了解，请点击此处查看原文 Python pass语句及其作用如果你想要一个代码块内什么都不做，但是没有这个代码块语法又不通过，你可以使用pass ，其是Python中的空语句，它什么也不做，唯一的功能就是占位了。 12345if 10 &gt; 9: print(&quot;xxx&quot;)else: passprint(&quot;xxxx&quot;) Python assert断言函数及用法assert断言函数 与if分支类似，不过它的特点是:当它的表达式条件为False时将会抛出异常，程序崩溃 。 123num = int(input(&quot;请输入大于10且小于100的数字:&quot;))assert 10 &lt; num &lt; 100print(num) 当我们输入非大于10且小于100的数字将会抛出异常: 1234567请输入大于10且小于100的数字:1000Traceback (most recent call last): File &quot;test.py&quot;, line 2, in &lt;module&gt; assert 10 &lt; num &lt; 100AssertionError[Process exited 1] Python 如何合理使用assert本小节通过一些实际应用的例子，演示assert在Python中的用法。 某商场促销活动，对商进行打折销售，现在需要做到如果折后价大于0或小于原价，那么输出折后价，否则报错。 12345678# 原价price = float(input(&quot;请输入原价:&quot;))# 折扣力度discount = float(input(&quot;请输入打几折:&quot;))# 折后价update_price = price * (discount * 0.1)assert 0 &lt; update_price &lt; priceprint(&quot;折后价为:&#123;:.2f&#125;¥&quot;.format(update_price)) 正常结果: 12345请输入原价:100请输入打几折:8折后价为:80.00¥[Process exited 0] 错误结果: 12345678请输入原价:100请输入打几折:18Traceback (most recent call last): File &quot;test.py&quot;, line 7, in &lt;module&gt; assert 0 &lt; update_price &lt; priceAssertionError[Process exited 1] 在实际工作中，assert可以提前预防一些问题。 Python while循环语句详解本笔记不讨论while 循环语句的使用，想要了解的同学，可以点击查看原文 Python for循环及用法详解本笔记不讨论for 循环语句的使用，想要了解的同学，可以点击查看原文 Python循环结构中else用法(入门必读)Python中，循环语句后可以跟着一个else语句块。其作用是，当循环条件为Fale时，会直接执行紧跟着循环语句块后的else语句块内的代码。 例子: 123456count_i = 0while count_i &lt; 5: print(&quot;count_i小于5:&quot;,count_i) count_i+=1else: print(&quot;count_i大于或等于5:&quot;,count_i) 输出结果: 12345678count_i小于5: 0count_i小于5: 1count_i小于5: 2count_i小于5: 3count_i小于5: 4count_i大于或等于5: 5[Process exited 0] 读者可能会想，这样做其实也没什么，就算没有else程序也照样会执行else内的代码。 其实这种语法是Python中一个为了让代码更加具有可读性、美观而有的一个语法。 for循环也是可以紧跟else的。 例子: 1234for i in range(1,6): print(i)else: print(&quot;输出完毕&quot;) 输出结果: 1234567812345输出完毕[Process exited 0] Python(for和while)循环嵌套及用法如果将一个循环语句放入一个循环体内，就会形成循环嵌套。 当程序遇到循环嵌套时，如果外层循环的循环条件允许，则会执行外层循环的循环体，而内层循环将会被外层循环的循环体来执行(只是内层循环需要反复执行自己的循环体而已)。只有当内层循环执行结束且外层循环的循环体也执行结束时，才会再次通过判断外层循环的条件，决定是否再次开始执行外层循环的循环体。 居上所述，假设外层循环的循环次数为n次，那么内层循环的循环次数为m次，那么可得出内层循环的循环体实际上需要执行n x m 次。 例子: 12345for i in range(0,3): j = 0 while j &lt; 3: print(&quot;i:&#123;&#125;\tj:&#123;&#125;&quot;.format(i,j)) j += 1 输出结果: 1234567891011i:0 j:0i:0 j:1i:0 j:2i:1 j:0i:1 j:1i:1 j:2i:2 j:0i:2 j:1i:2 j:2[Process exited 0] i 为外层循环的数，j为内层循环的数，可以看到每次内层循环结束后外层循环的i才会发生改变，当时每次外层循环结束后，再次进入循环体后，将会重置内层循环j的值。 嵌套循环可以无限嵌套，但开发者最好不要超过三层循环，不然逻辑很容易混乱。 Python嵌套循环实现冒泡排序冒泡排序算法的实现思想: 比较相邻元素大小，若前一个比后一个大则交换位置。 从第一对相邻元素到结尾的最后一对相邻元素，对每一对相邻元素做上一步骤的比较工作，并将最大的元素放在后面。 将循环缩短，除去最后一个数，再重复第二步骤操作。 持续做步骤三操作，将每次循环缩短一位。 实现: 123456789test_list = [10,23,4522,55,13,5123,5,1321235.33,42.123]for i in range(len(test_list)-1): # 每次得到最大值后循环缩短，因为最大值已经在最后 for j in range(len(test_list)-i-1): # 如果相邻元素的第一个元素比第二元素大则: if(test_list[j]&gt;test_list[j+1]): test_list[j],test_list[j+1]=test_list[j+1],test_list[j]print(&quot;排序后:&quot;,test_list) 输出结果: 1排序后: [5, 10, 13, 23, 42.123, 55, 4522, 5123, 1321235.33] Pyton break用法详解在我们使用循环时，当条件满足那么循环体内的代码将会一路执行，直到循环体结束为止，如果我们想在执行循环体时直接终止循环或跳出本次循环，则可以使用coontinue或break 语句。 break用于完全结束一个循环，杀死循环。 例子: 123456sum = 0for i in range(0,100000): print(&quot;i的值为:&quot;,i) sum += i if sum == 5050: break 输出结果: 1234567891011121314i的值为: 0i的值为: 1i的值为: 2i的值为: 3i的值为: 4......i的值为: 94i的值为: 95i的值为: 96i的值为: 97i的值为: 98i的值为: 99i的值为: 100 可以看到，当sum值为5050时，循环将会被杀死，不再执行。 如果循环体外带上了else块，那么如果循环体内执行了break语句，则else语句块内的代码不会被执行。 123456for i in range(1,4): print(i) if i &gt; 2: breakelse: print(&quot;else&quot;) 输出结果: 12345123[Process exited 0] 可以看到，当for循环体内执行了break语句后，else内的代码也不会执行。 break语句只能结束当前执行的循环，而不能结束被嵌套循环的外层循环。 Python continue用法continue与break类似，但不同点在于continue只能跳出本次循环，并不能终止循环。 例子: 1234for i in range(1,5): if i == 2: continue print(i) 输出结果: 12345134[Process exited 0] 可以看到，当循环内部执行continue之后，下面的代码将不会被执行。 如何避免Python出现死循环为了避免Python程序出现死循环，所以必须确保循环结构中至少有能让循环条件为False或让break语句得以执行的语句。 Python推导式详解Python推导式，是Python独有的一种特性。使用推导式可以快速生成列表、元素、字典以及集合类型的数据。 列表推导式利用range区间、元组、列表、字典和集合等数据类型、快速生成一个满足指定需求的列表。 语法格式: [表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]] if条件表达式为非必须的。 列表推导式例子: 求0-10的平方 12test_list = [x * x for x in range(11)]print(test_list) 输出结果:[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 例子2: 求0-10的平方，并且满足可以整除2 12test_list = [x * x for x in range(11) if x % 2 == 0]print(test_list) 输出结果: [0, 4, 16, 36, 64, 100] 上面的列表推导式都只有一个循环，但实际上它可以使用多个循环。 例子: 12test_list = [(x,y)for x in range(5) for y in range(4)]print(test_list) 输出结果: 12345[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3), (4, 0), (4, 1), (4, 2), (4, 3)][Process exited 0] 其实Python的列表推导式可以使用循环语句重写: 12345test_list2 = []for x in range(5): for y in range(4): test_list2.append((x,y))print(test_list2) 输出结果同上 当然，也支持多层循环嵌套的推导式。 元组推导式元组推导式同列表推导式一样，可以使用range区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。 语法格式: (表达式 for 迭代变量 in 可迭代对象 [if条件表达式]) if条件表达式为可选 首先将元组推导式与列表推导式做一个对比。 例子: 1234test_list = [x for x in range(10)]print(test_list)test_tuple = (x for x in range(10))print(test_tuple) 输出结果: 1234[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&lt;generator object &lt;genexpr&gt; at 0x106f3d450&gt;[Process exited 0] 可以看到，除了元组推导式是使用() 圆括号而列表推导式是使用[] 方括号之外，还有就是元组推导式生成的结果并不是一个元组，而是一个生成器对象 。 我们可以通过tuple() 函数将生成器对象转换为元组或使用循环遍历生成器对象，获取各元素。 1234x = (x for x in range(10))for ele in x:\ print(ele,end=&quot; &quot;)print(tuple(x)) 输出结果: 0 1 2 3 4 5 6 7 8 9 () 注意:当我们遍历了生成器对象后，原生成器对象将不复存在，这就是为什么我们遍历了生成器对象后再将原生成器对象转换却得到空元组的原因 我们还可以使用__next__() 方法遍历，但很不方便。 12345678910111213x = (x for x in range(10))print(x.__next__())print(x.__next__())print(x.__next__())print(x.__next__())print(x.__next__())print(x.__next__())print(x.__next__())print(x.__next__())print(x.__next__())print(x.__next__())print(tuple(x))print(x.__next__()) 输出结果: 12345678910111213141516170123456789()Traceback (most recent call last): File &quot;test.py&quot;, line 13, in &lt;module&gt; print(x.__next__())StopIteration[Process exited 1] 可以看到被遍历后的生成器将会被清空，并且需要注意的是next方法需要不能越界 Python 字典推导式同前两个推导式一样，都可以接住多种数据类型生成符合需求的字典。 语法格式: {表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]} 例子: 将列表内元素作为键，其元素长度为值 123test_list = [&apos;Hello&apos;,&quot;World&quot;]test_map = &#123;key:len(key) for key in test_list&#125;print(test_map) 输出结果: {&#39;Hello&#39;: 5, &#39;World&#39;: 5} 例子2: 调换键值对 12345test_list = [&quot;语文&quot;,&quot;数学&quot;,&quot;英语&quot;]test_dict = dict.fromkeys(test_list,100)print(test_dict)test_dict2 = &#123;v:x for x,v in test_dict.items()&#125;print(test_dict2) 输出结果: 1234&#123;&apos;语文&apos;: 100, &apos;数学&apos;: 100, &apos;英语&apos;: 100&#125;&#123;100: &apos;英语&apos;&#125;[Process exited 0] Python集合推导式同上，可以使用常用数据类型快速生成符合需求的集合。 语法格式: {表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]} 注意：集合推导式的语法格式与字典推导式的语法格式相同，为了区分它们，同时看表达式的形式，如果是以键值对(key:value)的形式，那么就是字典，否则反之 例子: 123newset = &#123;i**2 for i in range(3)&#125;print(newset)print(type(newset)) 输出结果: 12&#123;0, 1, 4&#125;&lt;class &apos;set&apos;&gt; Python zip函数及用法zip() 函数可以将多个列表转化一个zip对象(可迭代对象)。 例子: 123list1 = list(range(1,10))list2 = list(range(-10,0))print([x for x in zip(list1,list2)]) 输出结果: 1234[(1, -10), (2, -9), (3, -8), (4, -7), (5, -6), (6, -5), (7, -4), (8, -3), (9, -2)][Process exited 0] Python reversed函数及用法reversed()函数用于将各种序列进行逆序排序 ，但不会影响序列本身。 例子: 12string = &quot;HelloWorld&quot;print([x for x in reversed(string)]) 输出结果: [&#39;d&#39;, &#39;l&#39;, &#39;r&#39;, &#39;o&#39;, &#39;W&#39;, &#39;o&#39;, &#39;l&#39;, &#39;l&#39;, &#39;e&#39;, &#39;H&#39;] Python sorted函数及用法sorted函数用于将各种序列进行排序。 例子: 12345string = &quot;123456789&quot;re_string = [x for x in reversed(string)]print(re_string)sort_string = sorted(re_string)print(sort_string) 输出结果: 1234[&apos;9&apos;, &apos;8&apos;, &apos;7&apos;, &apos;6&apos;, &apos;5&apos;, &apos;4&apos;, &apos;3&apos;, &apos;2&apos;, &apos;1&apos;][&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;][Process exited 0] Python项目实战之猜数字游戏代码如下: 12345678910111213141516171819202122# 随机数模块import randomprint(&quot;&#123;0:=^20s&#125;&#123;1:s&#125;&#123;0:=^20s&#125;\n&quot;.format(&quot;==========&quot;,&quot;欢迎游玩猜数字游戏&quot;))# 随机数(1-20之间)randomNum = random.randint(1,20)# 只给用户5次机会for count in range(1,6): print(&quot;\n算上这次，你还有&#123;:d&#125;次机会!\n&quot;.format(5-count)) num = int(input(&quot;请输入猜测的数(范围1~20):&quot;)) if num&gt;randomNum: print(&quot;\n系统&gt;&gt; 大了点!!!&quot;) elif num &lt; randomNum: print(&quot;\n系统&gt;&gt; 小了点!!!&quot;) else: print(&quot;\n系统&gt;&gt; 恭喜你猜中了数字!!!&quot;) breakelse: print(&quot;\n系统&gt;&gt; 很遗憾，你没有猜到正确答案，答案为:&#123;:d&#125;&quot;.format(randomNum)) 猜中运行实例: 12345678910111213141516171819202122232425262728====================欢迎游玩猜数字游戏====================算上这次，你还有4次机会!请输入猜测的数(范围1~20):10系统&gt;&gt; 小了点!!!算上这次，你还有3次机会!请输入猜测的数(范围1~20):15系统&gt;&gt; 大了点!!!算上这次，你还有2次机会!请输入猜测的数(范围1~20):14系统&gt;&gt; 大了点!!!算上这次，你还有1次机会!请输入猜测的数(范围1~20):13系统&gt;&gt; 恭喜你猜中了数字!!![Process exited 0] 猜错运行实例: 123456789101112131415161718192021222324252627282930313233343536====================欢迎游玩猜数字游戏====================算上这次，你还有4次机会!请输入猜测的数(范围1~20):1系统&gt;&gt; 小了点!!!算上这次，你还有3次机会!请输入猜测的数(范围1~20):1系统&gt;&gt; 小了点!!!算上这次，你还有2次机会!请输入猜测的数(范围1~20):1系统&gt;&gt; 小了点!!!算上这次，你还有1次机会!请输入猜测的数(范围1~20):1系统&gt;&gt; 小了点!!!算上这次，你还有0次机会!请输入猜测的数(范围1~20):1系统&gt;&gt; 小了点!!!系统&gt;&gt; 很遗憾，你没有猜到正确答案，答案为:3[Process exited 0] Python项目实战: 绕圈圈面试题1234567891011121314151617181920212223242526272829303132333435363738394041SIZE = 7array = [[0] * SIZE]# 创建一个长度SIZE * SIZE的二维列表for i in range(SIZE - 1): array += [[0] * SIZE]# 绕圈的方向(0:下 1:右 2：左 3:上)orient = 0# l 控制行索引 c控制列索引l = 0c = 0for i in range(1,SIZE * SIZE + 1): array[l][c] = i # 如果位于1号转弯线上 if l+c == SIZE - 1: # l &gt; c，位于左下角 if l &gt; c: orient = 1 else : orient = 2 elif (c == l) and (c &gt;= SIZE / 2): orient = 3 elif (l == c - 1) and (c &lt;= SIZE / 2): orient = 0 if orient == 0: l += 1 elif orient == 1: c += 1 elif orient == 2: c -= 1 elif orient == 3: l -= 1for i in range(SIZE): for j in range(SIZE): print(&quot;%02d&quot; % array[i][j],end = &quot;&quot;) print(&quot;&quot;)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《笨方法学习VimScript》所学]]></title>
    <url>%2F2019%2F09%2F27%2F%E8%AF%BB%E3%80%8A%E7%AC%A8%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0VimScript%E3%80%8B%E6%89%80%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[身为一名每天使用Vim超过5小时的人来说，十分有必要学习一下VimScript，正好看到这本书作为入门很合适。这篇文章则是记录我读完此册子所学。 为什么选择这本书?&emsp;首先，我是一个重度Vim用户，目前记笔记，写代码等操作都是在Vim中实现的，为了让这个强大的古老神器能在我手上发挥巨大威力，所以我决定看书学习Vim。而这本书的前言说的就很好，第一句则是程序猿们很喜欢实现自己的idea，虽然我现在只是一名学生，但在我日常生活中经常想把自己使用Vim时的好点子加入我的vimrc 中。再就是这本书的每章都只讲述一个主题，虽然内容简短但是信息丰富，这样我很喜欢，没有过多啰嗦的地方，有些地方这本书更推荐看Vim自带的文档，这样也让读者有一个自我理解与学习的过程，就像书中所说现实世界中事情的进展并不是遇到问题后可以很快速轻松的解决。 前言所提到的都是这本书是面向谁的，以及读完这本书能获得些什么，并且给了一些学习时的忠告，最后提醒了要多利用:help命令. 预备知识这本书主要讲VimScript所以，在学习VimScript之前，得了解Vim的基本使用，例如buffer,window,normal mode,insert mode,text mode。 最好是具有编程经验。 本书基于Vim-7.3版本撰写的，所以读者需要确保系统安装了&gt;=7.3版本的Vim。 创建Vimrc文件这一节没有提到Vimrc 是什么，我这里提一下，是Vimrc一个文件，文件内的可以写vim的命令，而写在Vimrc 中的命令都被称为Ex命令，Ex命令不是这一小节的讨论范围。 主要说到在Linux或Mac OS X中，这个文件位于home目录下，并且是以.vimrc命名的，而在Windows下则是位于home文件夹下，并以_vimrc命名。 以上三个系统，都可以在Vim中通过执行:echo $MYVIMRC得知此文件的位置等信息。 注意:若你没有找到此文件，请自行创建 打印信息主要提到Vim中打印命令和注释的使用与作用。 Vim中的打印命令有:echo 和echom ，其区别在于: echo 仅仅输出回显表达式结果。 回显表达式 echo {expr1} 其中{expr1}就是回显表达式 echom 输出回显表达式结果，并且将其存储在message-history 内 message-history message-history 是消息历史，可以通过命令查看:messages 注释VimScript可以通过&quot; 字符添加注释，就像这样: 12&quot; 将&lt;space&gt;映射为zannoremap &lt;space&gt; za 设置选项Vim中有两种选型: 布尔选项(on 或off)以及键值选项。 布尔选项类似于开关，例如想让Vim中显示行号，可以执行::set number，这就代表开启，如果想要关闭，则可以使用::set nonumber 代表关闭状态，如果不想纠结当前状态，只想切换可以执行:set number!，如果想知道当前状态的值，可以执行:set number?，这样可以看到选项的值。 键值选项有些选项，比不是像布尔选项只有两种状态，它们可能会有一个不固定的值，例如改变行号宽度的选项numberwidth ，如果我们想查看numberwidth 的值，可以执行set numberwidth?。 一次性设置多个选项前面我们一直在使用:set命令设置单个选项的值，不过:set命令还允许一次设置多个选项的值。 12:set numberwidth=2:set nonumber 可以写成:set numberwidth=2 nonumber 练习‘number’的帮助文档: 在每行前显示行号。 relativenumber的帮助文档: 在每行前显示相对于光标所在行的行号。布尔型选项 建议开启这个选项，它可以让你在上下移动光标时不需要动脑子去算。 numberwidth的帮助文档: 键值选项，该选项可以设置行号的列数，Vim中默认为4，也就是说当行号超过9999则会自动扩容。 wrap的帮助文档: 布尔选项，该选项的作用是自动换行，默认打开。 shiftround的帮助文档: 布尔选项，表示没看太懂，文档内是说将缩进取整为shiftwidth 的倍数。这个是命令是应用于&gt; 和 &lt; 命令的 matchtime的帮助文档: 键值型选项，默认值为5，作用是设置配对括号的时间。 基本映射从这一章节开始，逐渐变得有趣起来。 映射是数学中一个有趣的概念，而在VimScript中，键盘的映射也是非常重要且能让Vim随你心意的一个重要概念，因为你可以通过键盘映射告诉Vim: 当我按下某组键位时，则执行某些命令。 最简单的键盘映射是map命令，map命令还可以使用特殊字符，map命令不可以映射注释 练习映射按键_，让当前行上移一行。 :map _ ddkp 模式映射我们知道Vim中有很多种模式，常见的有:normal,visual,insert 而上一章节所学的map 命令只能应用在normal 模式下。 不过不用担心，VimScript提供了应用在不同模式下的映射，它们是:nmap,vmap,imap 分别对应了三种常见的模式。 注意:在插入模式映射下，Vim只会按你所想去做，所以如果要执行normal模式下的命令，别忘了使用&lt;Esc&gt; 退出插入模式再使用. 练习在insert模式下，可通过按&lt;C-u&gt; 将当前光标所在的单词转换成大写格式。 1:imap &lt;C-u&gt; &lt;esc&gt;vgU 在normal模式下，按C-u将当前光标的单词转换成大写格式。 1:nmap &lt;C-u&gt; vwgU 精确映射书上说本章内容会比较难理解，其实很简单.. 前面我们学了map以及三种模式对应的映射命令，但他们有一个问题，就是如果当前映射的键再次被映射了，那么当我们使用其快捷键时，就会执行原先映射的键，这就是递归。 想要避免递归映射，我们可以使用另一组映射命令，可以使得映射的键不会进行递归。 例如nmap 的非递归映射命令是:nnoremap 其中的nore 应该就是not recursion的意思，其他两种模式映射命令也是如此。 注意:我们应当在任何时候都使用非递归映射，以免递归映射带来的不必要麻烦 练习unmap的帮助文档: unmap是一个系列命令，其作用是在映射命令作用的模式中删除映射，同系列的其他命令还有nunmap vunmap xunmap sunmap ounmap iunmap lunmap cunmap 等。 LeadersLeaders是Vim中让用户自定义的特殊键位，其作用主要是作为映射键位的前缀键，这样可防止在映射过多快捷键后覆盖的问题。 想要设置leader键，执行命令::let mapleader = &quot;选择你想要的&quot;，默认的Leader键为\ Local Leader前面所提到的Leader更偏向于全局键位映射，如果我们需要对不同文件类型设置不同的快捷键，则可以使用Local Leader 。 想要设置Local Leader 的键位，可以执行::let maplocalleader = &quot;&lt;space&gt;&quot; 你可以把替换成你想要的。 本章本小节只是粗略的提了下LocalLeader的作用，后面的章节将会更加详细的介绍。 练习mapleader的帮助文档: 其实也没什么好说的，上面都写完了，这里说一点:mapleader 的值仅在定义映射时被使用，就算后面改变’mapleader’也不会影响已经定义过的映射。 maplocalleader的帮助文档: 主要就说一两句忠告:在全局插件里应该使用&lt;Leader&gt; 而在一个根据文件类型有不同操作的插件里应该使用&lt;LocalLeader&gt; ，还有就是mapleader 和maplocalleader 的值是可以相同的。 编辑你的Vimrc文件这一章算一个小技巧，书中是这么说的：当你在疯狂编码时 突然想加点什么到Vimrc中，但是你又必须立刻编辑vimrc以防忘记，并且又不想退出当前文件，以防打断思路，那么本小节将会实现这个小技巧。 编辑映射我们可以在新建一个分屏，然后那个分屏中编辑vimrc，通过几个简单的键位，即可实现。 :nnoremap &lt;Leader&gt;er :vsplit $MYVIMRC&lt;cr&gt; 这个命令使用快捷键Leader+e+r 实现新建一个纵向分屏 并且在纵向分屏中打开$MYVIM ，注意最后的&lt;cr&gt; 代表回车，你们可以试下去掉会&lt;cr&gt;发生什么。 重读映射配置当我们添加完即刻所想的idea后，我们还需要重载配置文件，但还是需要再次拼写那长长的命令，所以我们直接通过精确键盘映射完成重读映射，在多次使用后，重读一次配置文件的时间不超过0.2秒 :nnoremap &lt;Leader&gt;sr :source $MYVIMRC&lt;CR&gt; 练习说让我添加一些没意义的映射…那好吧，我想要快速执行外部命令，并将外部命令的输出插入到当前文本中。 我要执行的外部程序是:figlet ，这是一个可以将字符转化为字符画的一个小程序，那么我可以这样映射。 :nnoremap &lt;Leader&gt;fl :r !figlet 这样当我按下&lt;Leader&gt;+f+l 这个键盘映射后将会自动帮我输入我映射的值，然后等到我输入一些内容，按下回车后就会将figlet的执行结果插入到当前文本中。 myvimrc的帮助文档: 文档中说，$MYVIMRC 是一个环境变量，这个环境变量指向的是vimrc 文件，这个文件用于VIM启动时的初始化。并且这个环境变量如果没有被设置或使用VIMINIT则会从5个地方开始查找，分别是1. 环境变量$VIMINIT 2.用户vimrc文件 3.环境变量$EXINIT 4.用户exrc文件 5. 默认的vimrc文件(位于$VIMRUNTIME/defaults.vim) AbbreviationsAbbreviations是Vim中一个灵活且强大的特性，其主要用于insert replace command 模式 书里说了，只讲insert 模式下的abbreviations，简单的说abbreviations 就是一个缩写替换，可以自定义一些缩写，当你在insert 模式下键入这些缩写就会被替换成事先定义好的值。 insert 模式的abbreviations 命令是:iabbrev 例如::ibbrev name8 EvanMeek ，执行这条命令当我们在插入模式下键入name8 并按下空格，Vim的abbreviations 特性就会将其替换为我们定义好的EvanMeek 。 Keyword CharactersKeyword Characters是abbreviations 的一个概念，Vim中有一个keyword范围列表 想要查看这个返回列表可以执行命令::set iskeyword? ，你将会看类似iskeyword=@,48-57,_,192-255 的结果，这里简单介绍一下，这是一个格式，这个格式包含了如下几种: 48-57 其实是ASCII值在48-57之间的字符，也就是数字(0-9) 192-255 是ASCII值，代表了一些特殊的ASCII字符 @ 代表除了小写字母ASCII字母以外的字母 _ 以及下划线 为什么说Keyword Characters是Abbreviations 的概念，因为: 当在插入模式下键入缩写后的后一个字符不包含在iskeyword 列表中则会将定义好的全拼替换掉缩写，例如我们敲就不在iskeyword 列表中，所以可以替换。 下面举个abbreviations 特性的常用例子吧: 1:iabbrev em7 email:the_lty_mail@foxmail.com 重载配置文件后，当我们在插入模式下键入em7然后再键入一个非iskeyword 列表中的字符，将会替换为email:the_lty_mail@foxmail.com。 为什么不用Mappings?其实书上的例子已经很好的解释这个问题了。 首先用mappings做一个替换::inoremap lol ILoveLOL，然后你进入insert 模式，键入你玩不玩lol? ，此时lol 将会被替换为ILoveLOL ，让我们用abbreviations 特性再做相同的操作。 执行命令: 12:iunmap lol:iabbrev lol ILoveLOL 现在再试试，你就懂了。 练习为我常用的字符串添加abbreviations 特性与配置中。 1:iabbrev info email:the_lty_mail@foxmail.com name:EvanMeek WebSize:https://evanmeek.github.io 更多的Mappings前面用到了很多多字符的mappings但是我们一直没有提到mappings的连续性。 首先运行如下命令::nonoremap jk dd 当我们处于 normal模式时，快速键入jk Vim则会执行我们映射的 dd 命令，当前行被删除了。 现在再试试按jk，但是在按下j 后等待一会儿，再按下k ，我们会发现，Vim不会执行我们所映射的那个命令。这是因为，当我们设置的多字符mappings在键入时，如果没有快速连贯的输入，那么Vim就不会识别。 一个更为复杂的Mapping书中是在normal模式下将单词用&quot;&quot;包住。 运行命令:nonoremap &lt;LEADER&gt;&quot; viw&lt;ESC&gt;a&quot;&lt;ESC&gt;hbi&quot;&lt;ESC&gt;lel 现在解释一下: viw 高亮选中单词 &lt;ESC&gt; 退出visual模式，此时光标会在单词的最后一个字符上 a 移动光标至当前位置后并进入insert 模式 &quot; 插入一个&quot; &lt;ESC&gt; 退出insert模式，进入normal模式 h 光标左移 b 移动光标至单词头部 i 进入insert模式 &quot; 键入一个&quot; &lt;ESC&gt; 返回到normal模式 l 光标右移，置于单词头部 e 移动光标至单词尾部 l 光标右移，置于第一个添加的引号上 需要注意的是:这里是使用nonoremap 映射的，而非nmap 映射，所以尽管映射的字符已经被映射，Vim也只会讲其中的字符按默认功能执行。 练习创建一个mappings，使用单引号而不是双引号。 :nonoremap &lt;LEADER&gt;&#39; viw&lt;ESC&gt;a&#39;&lt;ESC&gt;hbi&#39;&lt;ESC&gt;lel 本地缓冲区的选项和映射如题所示，本章会讲到本地缓冲区，我们将会对本地缓冲区与全局缓冲区做对比。 为了演示，请打开两个文件，例如file1 和file2，然后输入一些字符。 映射首先，我们打开 file1 ，然后执行命令: 12:nnoremap &lt;LEADER&gt;d dd:nnoremap &lt;BUFFER&gt; &lt;LEADER&gt;x dd 现在我们再打开file2 ，然后使用刚刚映射的快捷键，你会发现第一个映射的快捷键可以使用，但是第二个则不行，现在我们再打开file1 ，却发现两个快捷键都可以被使用。 好了，现在解释一下这是为什么。首先，我们看到两个映射不同的地方除了映射键以外，第二个映射还多了个&lt;buffer&gt; ，这代表了我们当前映射的快捷键只有在当前缓冲区 起作用，而当我们切换到另外一个缓冲器，那么自然映射不起作用了。 本地Leader本地Leader的作用是: 更精确的定义映射。 有时我们在使用一些对特殊缓冲区起作用的插件时，为了防止与全局Leader映射起冲突，所以就需要使用本地Leader，也就是&lt;localleader&gt; 。 设置前面几个章节我们都是使用set 命令进行设置VIM的，但是为了让我们的设置更加精准，在不同特殊缓冲区具有不同的设置时，我们就应该使用本地设置setlocal 命令进行设置，下面来看几个例子: 仍然是操作file1 和file2 ，首先，我们打开file1 键入命令::setlocl wrap 然后在打开file2 键入命令::setlocal nowrap ，然后为两个文件键入长长的一段字符。 你会发现file1 是具有自动折行的，而file2 却不具备。 注意:不是所有命令都可以设置setlocl的，如果需要查看命令是否可以设置为setlock 那么可以通过命令执行:Help命令查看命令的帮助文档 覆盖这一小节其实不需要做什么演示，一句话就可以概括:本地缓冲区命令要比全局缓冲区优先级高，如果本地缓冲区命令与全局缓冲去起了冲突，那么Vim将会忽略全局缓冲区的命令 练习阅读:help local-options 写完了两章，结果被Nvim的交换文件给重置了，心态崩了 自动命令自动命令与映射一样重要。 自动命令可以让Vim自动执行某些命令，这些命令会在某些事件触发时执行。 下面看一个例子: :autocmd BufNewFile * :write 输入这条命令，然后使用:edit 命令新建一个缓冲区，你会发现会缓冲区会被自动写入进文件了。 下面我们就来解释一下。 自动命令结构先讲一下自动命令结构，你就可以很清晰的了解自动命令为什么能做到监听事件了。 :autocmd BufNewFile * :write BufNewFile 代表要监听的“事件” 代表事件过滤的“模式（pattern）” :write 代表要执行的命令。 这条命令的实际上做的事是: 当Vim监听到BufNewFile 这个事件后, 对所有类型的文件，因为过滤模式是* , 执行:write 命令。 另一个栗子: :autocmd BufNewFile *.txt :write 这个例子是将事件过滤模式改为了*.txt ，代表只有新建缓冲区的文件类型为txt 才会触发这个自动命令。 多个事件一个自动命令可以绑定多个事件，多个事件之间由逗号分隔开。 例如: :autocmd BufWritePre,BufRead *.html :normal gg=G 这个自动命令将会在文件类型为html 的缓冲区写入文件时或者读入文件类型为html 类型的文件至缓冲区时进行文本缩进处理。 FileType事件FileType可以让Vim在设置一个缓冲区的filetype 时触发。 见名知意，filetype 也就是文件类型的意思。 例如我们要对JavaScript与Python映射快速添加注释的快捷键，但由于两门编程语言的注释语法不同，所以我们就可以根据FileType 的值设置不同的文件，定义不同的映射。 12:autocmd FileType javascript nnoremap &lt;buffer&gt; &lt;localleader&gt;c I//&lt;ESC&gt;:autocmd FileType python nnoremap &lt;buffer&gt; &lt;localleader&gt;c I#&lt;ESC&gt; 本地缓冲区缩写本章很简单，只是将缩写添加一个范围限制。 首先，我们执行命令::iabbrev &lt;buffer&gt; --- Hello 再进入插入模式，键入Hello --- World 我们发现，--- 被替换为了Hello ，这没什么新鲜的，但是当我们打开另一个缓冲区，将会发现这个缩写不起作用了，因为这个缩写是local iabbrev 自动命令组前面几章，我们学习了自动命令，但其实他在某些场景下仍然有些问题。 例如，先执行命令::autocmd BufWrite * :echom &quot;Writing buffer&quot; 然后使用:write 命令将当前缓冲区写入文件，然后执行:messages 命令查看消息日志。你当然会看见Writing buffer 在消息列表中。 然后重复上面的操作，我们将会看到Writing buffer 在消息列表出现了两次，如果我们再执行上面的自动命令:autocmd BufWrite * :echom &quot;Writing buffer&quot; ，然后再重复刚刚的操作，你将会看到Writing buffer 出现了4次. 这样是有问题的，因为自动命令被重复设置了，因为Vim不知道你是想替换前面设置的自动命令。 这会有什么问题?直接说吧，这样会影响Vim的启动速度，因为你的命令通常都是写在~/.vimrc 下，但是每次启动Vim 时，都会加载vimrc ，而这些重复的自动命令将会大大降低Vim的启动速度。 你可以执行下面的命令，模拟延迟情况。 :autocmd BufWrite * :sleep 200m 如果还不够，你可以多执行几次。 键入: :autocmd! 以取消所有的自动命令。 把自动命令放到组中(Grouping Autocommands)上面的问题，可以通过将自动命令放入一个组内解决。 例如: 1234augroup testGroup autocmd BUfWrite * :echom &quot;Write ONE&quot; autocmd BUfWrite * :echom &quot;Write TWO&quot;augroup END 中间的两行缩进可以省略。 现在试试将缓冲区写入文件，然后查看消息列表。然后再执行如下命令: 123augroup testGroup autocmd BUfWrite * :echom &quot;Write THREE&quot;augroup END 现在再将缓冲区写入文件，然后查看消息列表，于是，操蛋的事就发生了。。。 清楚自动命令组你以为定义相同的自动命令组将会自动替换，但其实不是。。。 为了解决这个问题，所以你最好这么做: 1234:augroup testGroup:autocmd!:autocmd BUfWrite * :echom &quot;Write FOUR&quot;:augroup END 请注意,autocmd!，这将会把当前组内的自动命令都先清空，然后再定义新的自动命令。 你现在可以试试还会不会有:Write ONE TWO ... 等信息 Operator-Pending映射]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[功能强大-基于GPU加速-Kitty终端]]></title>
    <url>%2F2019%2F09%2F26%2F%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7-%E5%9F%BA%E4%BA%8EGPU%E5%8A%A0%E9%80%9F-Kitty%E7%BB%88%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[由于实在忍受不了iTerm2的卡顿，所以我尝试使用一款速度更快的终端——Kitty Kitt终端简介从官方介绍内，Kitty具有以下特性: 使用GPU进行渲染，以降低系统负载和更加平滑的滚动效果。使用多线程渲染使得输入延迟最低。 现代终端功能: 图像、Unicode、真彩色、OpenTye连体字、鼠标、聚焦跟随 对多个终端窗口进行不同的窗口布局操作 可通过脚本或Shell进行控制 使用Kittens框架，可以让一些小型程序用于扩展Kitty 允许在任意程序中使用回滚历史的功能]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>软件折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[趣学Haskell-01]]></title>
    <url>%2F2019%2F09%2F26%2F%E8%B6%A3%E5%AD%A6Haskell-01%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[Python-05]Python字符串常用方法详解]]></title>
    <url>%2F2019%2F09%2F23%2FPython-05-Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Python系列第五章笔记，查看Python系列所有文章，请点击💿 Python字符串拼接(包含字符串拼接数字)先说一个Python中书写字符串的一种特殊方式，如果我们将两个字符串紧挨着写，那么Python则会自动拼接它们。 12str1 = &quot;Hello&quot;&apos;,World&apos;print(str1) 输出结果:Hello,World Python字符串拼接数字 某些场景下，我们需要将字符串与其他数据类型进行拼接，例如数字，但Python是不支持直接将数字与字符串拼接的，所以我们得先将数字转换成字符串，再进行拼接。 12345678str1 = &quot;This number is:&quot;number = 1.1001# 使用str()方法将数值类型的变量转化成字符串print(str1+str(number))# 使用repr()方法将数值类型的变量转化成字符串print(str1+repr(number))# 直接将字符串类型与数值类型进行拼接print(str1+number) 输出结果: 123456This number is:1.1001This number is:1.1001Traceback (most recent call last): File &quot;test.py&quot;, line 8, in &lt;module&gt; │ print(str1+number)TypeError: can only concatenate str (not &quot;float&quot;) to str 可以看到，我们必须先将数值类型的变量转换成字符串类型才能进行拼接，否则将会引发TypeError的错误。 str()与repr()的区别 str()与repr()都可以将数值转换成字符串，但其中str是Python内置的类型，和int、float一样 ，然而repr()则只是一个函数。 repr()方法还可以以Python表达式的形式来表示值: 123str1 = &quot;This number is:&quot;print(str1)print(repr(str1)) 输出结果: 12This number is:&apos;This number is:&apos; Python截取字符串(字符串切片)方法详解Python的字符串实际上是由多个字符组成的，并且允许通过索引访问字符串的某个字符，其语法格式为: str[index] str代表要获取的字符串，index代表字符串的某个下标。 Python中字符串的第一个字符默认从0开始访问，依次推进则是0,1,2,n…，并且Python还允许使用负数作为索引下标，负数从-1开始，依次推进。 例子: 12345str1 = &quot;HelloWorld&quot;# 获取&apos;H&apos;print(str1[0])# 获取&apos;o&apos;print(str1[-6]) 输出结果: 12Ho 除了通过索引单次获取单个字符外，Python还可以使用中括号对字符串以范围的方式获取，被获取的字符串称为”子串”，其语法格式为: string[start:end:step] string代表要截取的字符串 start代表要截取子串的开始位置 end代表要截取子串的结束位置(不包括该字符) step代表从start开始，每step个距离获取一个字符。默认为1，可忽略该值。 例子: 12345str1 = &quot;HelloWorld&quot;# 截取&apos;Hello&apos;print(str1[0:6])# 截取&apos;Hold&apos;print(str1[0:len(str1):3]) 输出结果: 12HelloWHlod Python还支持使用in运算符判断是否包含某个子串. 例子: 1234str1=&quot;HelloWorld&quot;print(&apos;Hello&apos; in str1)print(&quot;World&quot; in str1)print(&quot;Test&quot; in str1) 输出结果: 123TrueTrueFalse Python len()函数详解:获取字符串长度或字节数len()函数用于获取字符串的长度，或字符串占用的字节。 例子: 12str1=&quot;HelloWorld&quot;print(len(str1)) 输出结果:10 如果想知道字符串所占用的字节数，可以先将字符串编码后，再获取。 例子: 123str1=&quot;你好世界&quot;print(len(str1))print(len(str1.encode())) 输出结果: 12410 encode()方法可以将字符串转换成不同编码格式的字符。 例如: 1234str1=&quot;你好世界&quot;print(len(str1.encode()))# 将字符串转换成gbk编码格式print(len(str1.encode(&apos;gbk&apos;))) 输出结果: 12812 Python split()方法详解: 分割字符串split()方法可以实现将一个字符串按照指定的分隔符分成多个子串，这些子串会被保存至列表中，其语法格式为: string.split(sep,maxsplit) string代表要分割的字符串 sep代表指定的分隔符，默认为None，也就是任何空字符，例如空格，\n，\t等 maxsplit代表最大分割次数，如果不指定或者指定为-1，则表示分割次数无限制。 如果不指定sep，那么maxsplit也不能指定 例子: 12345678910str1 = &quot;192.168.0.0.1&quot;# 指定分隔符为&apos;.&apos;，最大分割数为3次list1 = str1.split(&apos;.&apos;,3)print(list1)# 指定分割符为&apos;0.&apos;，最大分割数为-1list1 = str1.split(&apos;0.&apos;,-1)print(list1)# 不指定split()参数list1 = str1.split()print(list1) 输出结果: 123[&apos;192&apos;, &apos;168&apos;, &apos;0&apos;, &apos;0.1&apos;][&apos;192.168.&apos;, &apos;&apos;, &apos;1&apos;][&apos;192.168.0.0.1&apos;] Python join()方法: 合并字符串join()方法算是split()方法的逆方法，它可以将列表(或元素)中多个字符串元素采用固定的连接负连接在一起，其语法格式为: newstr = str.join(iterable) newstr代表合并后产生的新字符串. str代表连接符 iterable代表合并操作的源字符串数据。 例子: 123path = [&apos;usr&apos;,&apos;bin&apos;,&apos;python3.7&apos;]str1 = &apos;/&apos;.join(path)print(str1) 输出结果: 1/usr/bin/python3.7 Python count()方法，统计字符串出现的次数count()方法用于统计字符串在另一个字符串出现的次数，若不存在则返回0，否则返回统计的次数，其语法格式如下: string.count(sub[,start[,end]]) string代表字符串源 sub代表要检索的字符串 start代表检索字符串的起始位置，若不指定则默认为0开始 end指定检索的终止位置，若不指定则默认为字符串长度 例子: 12str1 = &quot;叽里呱啦，嘻嘻哈哈，高高兴兴&quot;print(str1.count(&apos;嘻嘻哈哈&apos;,0,len(str1))) Python find()方法：检测字符串中是否包含某个子串find()方法用于检索字符串中是否包含目标字符串，若包含则返回第一次出现该字符串的索引，否则返回-1。其语法格式为: string.find(sub,start,end) string要检索的字符串源 sub要检索的子串 start检索的起始位置 end检索的终止位置 例子: 123str1 = &quot;叽里呱啦，嘻嘻哈哈，高高兴兴&quot;print(str1.find(&quot;嘻嘻哈哈&quot;))print(str1.find(&quot;嘻嘻哈哈&quot;,6,len(str1))) 输出结果: 125-1 Python还提供了rfind()方法，与find()方法不同的是，其实从字符串的右侧开始检索 Python index()方法: 检测字符串中是否包含某个字符串index()方法与find()方法类似，唯一不同的是，index()方法检索子串若没找到，则会抛出异常。 同理，Python也提供了个rindex()方法，作用于rfind()方法类似。 Python字符串对齐方法ljust()、rjust()和center()详解Python 的str类提供了3种可以用来进行文本对齐的方法，分别是ljust()，rjust()，center() Python ljust()方法ljust()是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。语法格式如下: 1string.ljust(width,fillchar) string 表示被填充的字符串 width 表示包括string长度在内，字符串要占的总长度 fillchar 表示填充时占位的字符，默认为空格 例子: 123string = &apos;HelloWorld&apos;string2 = &quot;你好世界&quot;print(string.ljust(15,&apos;*&apos;),string2) 输出结果: 1HelloWorld***** 你好世界 Python rjust()方法rjust()方法与ljust()方法类似，唯一不同的是rjust()方法是向字符串左侧填充字符以右对齐的目的。语法格式: str.rjust(width,fillchar) 例子: 12string = &quot;HelloWorld&quot;print(string.rjust(15,&apos;*&apos;)) 输出结果: 1*****HelloWorld Python center()方法center()方法与rjust()、ljust()方法类似，其作用是在字符串两边填充字符以进行居中对齐。语法格式: str.center(width,fillchar) 例子: 12string = &quot;HelloWorld&quot;print(string.center(20,&apos;*&apos;)) 输出结果: *****HelloWorld***** Python startswith()和endswith()方法startswith()方法与endswith()方法都是用来检索指定字符串是否为字符串源的开头或结尾。 startswith()方法startswith()方法用于检索指定字符串是否为字符串源的开头。如果是返回True，否则反之。语法格式: str.startswith(sub,start,end) str: 字符串源 sub: 指定的字符串（子串) start: 指定开始检索的索引位置，可选参数，默认为开头。 end: 指定结束检索的索引位置，可选参数，默认为字符串源结尾。 例子: 123string = &quot;HelloWorld&quot;print(string.startswith(&quot;He&quot;,2))print(string.startswith(&quot;Wo&quot;,5)) 输出结果: 12FalseTrue endswith()方法endswith()方法用于检索字符串是否以指定字符串结尾 语法格式: str.endswith(sub,start,end) 例子: 123string = &quot;HelloWorld&quot;print(string.endswith(&apos;ld&apos;))print(string.endswith(&apos;rl&apos;,0,len(string)-1)) 输出结果: 12TrueTrue Pyhton大小写转换(3种)函数及用法Python提供了三种函数，方便用于转换字符串大小写，分别是title(),lower(),upper(). title()方法title()方法用于将字符串的字符转换为大写，其他字符转换为小写，并返回。 若不需要进行转换，则会直接返回 语法格式: str.title() 例子: 12string = &quot;HelloWorld&quot;print(string.title()) 输出结果: 1Helloworld lower()方法lower()方法用于将字符串中大写的字符转换为小写字符，并返回。 语法格式: str.lower() 例子: 12string = &quot;HelloWorld&quot;print(string.lower()) 输出结果:helloworld upper()方法upper()方法用于将字符串中小写的字符转换为大写字符，并返回。 语法格式: str.upper() 例子: 12string = &quot;HelloWorld&quot;print(string.upper()) 输出结果: HELLOWORLD Python去除字符串中空格Python提供了三种方法，用于去除字符串中的特殊符号或指定字符，例如换行符(\n)，回车符(\r)，制表符(\t)，它们分别是strip(),ltrip(),rtrip(). strip()方法strip()用于去除字符串前后(左右侧)的特殊符号或指定字符。 语法格式: str.strip(char) str: 字符串源 char: 指定删除的字符，可选参数，默认为空格、换行符、回车符、制表符 例子: 1234string = &quot;\r 排山倒海\t\n\r&quot;print(repr(string))print(repr(string.strip()))print(repr(string.strip(&apos;\r&apos;))) 输出结果: 123&apos;\r 排山倒海\t\n\r&apos;&apos;排山倒海&apos;&apos; 排山倒海\t\n&apos; lstrip()方法lstrip方法用于去除字符串前(左侧)的特殊符号或指定字符。 语法格式: str.lstrip(char) 例子: 123string = &quot;\t\n\r排山倒海&quot;print(repr(string))print(repr(string.lstrip())) 输出结果: 12&apos;\t\n\r排山倒海&apos;&apos;排山倒海&apos; rstrip()方法rstrip()方法与lstrip()方法以及strip()方法很类似，只不过其作用是去除字符串后(右侧)的特殊符号或指定字符。 语法格式: str.rstrip(char) 例子: 123string = &quot;排山倒海\t\n\r&quot;print(repr(string))print(repr(string.rstrip())) 输出结果: 12&apos;排山倒海\t\n\r&apos;&apos;排山倒海&apos; Python format()方法格式化输出方法详解语法格式: str.format(args) str: 字符串源 args: 参数列表，使用逗号进行分割 format()方法的重点在于搞清楚str显示样式的格式。在差UN感觉爱你显示样式模板时，需要使用{}和:来指定占位符，其完整的语法格式为: {[index][:[[fill] align] [sign] [#] [width] [.precision] [type]]} 注意,语法格式中的[]括起来的都是可选参数 参数含义如下: index : 指定后面设置的格式要作用到args中第n个数据，数据的索引值从0开始，默认值为args中数据的先后顺序自动分配排列。 fill : 指定空白处填充的字符。注意，当填充字符为逗号,切作用于整数或浮点数时，该整数(或浮点数)会以逗号分隔的形式输出，例如(1000会输出1,000)。 align : 指定数据的对齐方式 align 参数及含义 align 含义 &lt; 数据左对齐 &gt; 数据右对齐 = 数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对 数据类型有效 ^ 数据居中，此选项续和width参数一起使用 sign : 指定有无符号数 sign 含义 + 正数加正号，负数加负号 - 正数不加正好，负数加负号 空格 正数前加空格，负数前加负号 # 对于二、八、十六进制数，使用此参数，会显示对应的前缀 width : 指定输出数据时所占的宽度。 .precision : 指定保留的小数位数。 type : 指定输出数据的具体类型 type类型值 含义 s 对字符串类型格式化 d 十进制整数 c 将十进制整数自动转换成对应的 Unicode字符 e或者E 转换成科计数法后，再格式化输出 g或G 自动在e和f中切换 b 将十进制数自动转换成二进制表示，再格式化 o 将十进制数自动转换成八进制表示，再格式化 x或X 将十进制数自动转换成十六进制表示，再格式化 f或F 转换为浮点数(默认小数点后保留6位),再格式化输出 % 显示百分比(默认显示小数点后6位) 例子: 12string = &quot;姓名:&#123;:&gt;5s&#125;\n工资:&#123;:&gt;10.2F&#125;\n&quot;print(string.format(&quot;张三&quot;,1001.223)) 输出结果: 123姓名: 张三工资: 1001.22 例子2: 1234567891011# 货币形式显示print(&quot;$:&#123;:,d&#125;&quot;.format(1000009922399))# 科学计数法显示print(&quot;科学计数法:&#123;:e&#125;&quot;.format(1000.123))# 十六进制显示print(&quot;1016的十六进制:&#123;:x&#125;&quot;.format(1016))# 百分比形式显示print(&quot;百分比显示:&#123;:.0%&#125;&quot;.format(0.99)) 输出结果: 1234$:1,000,009,922,399科学计数法:1.000123e+031016的十六进制:3f8百分比显示:99% Python encode()和decode()方法: 字符串编码转换前言: 世界最早的字符编码时ASCII编码，它最多表示256个符号，每个符号占用1个字节，随着技术的发展，多国的文字都需要进行编码，所以出现了很多种编码格式，例如UTF-8也就是最通用的编码格式，Python3.x默认也是使用UTF-8编码格式。 Python中有两种常用的字符串类型: str与bytes类型，str用来表示Unicode字符,bytes用来表示二进制数据。 所以我们就需要使用encode()和decode()方法进行转换。 Phthon encode()方法encode()方法是str提供的功法，其作用是将str类型转换成bytes类型，这个操作也被称为编码。 语法格式如下: str.encode([encode=&quot;utf-8&quot;],[errors=&quot;strict&quot;]) encoding : 指定在编码时采用的字符编码，默认采用utf-8。当只有这个参数时，可以省略=直接写str.encode(&quot;UTF-8&quot;) errors : 指定错误处理方式，默认为strict，其可选项有: errors 含义 strict 遇到非法字符就抛出异常 ignore 忽略非法字符 replace 用?替代非法字符 xmlcharrefreplace 使用xml的字符引用 例子: 12string = &quot;HelloWorld&quot;print(string.encode()) 输出结果: b&#39;HelloWorld&#39; Python decode()方法decode()可以将bytes类型的二进制数据转换成str类型，这个过程被称为解码 语法格式: bytes.decode([encoding=&quot;utf-8&quot;],[errors=&quot;strict&quot;]) 例子: 123string = &quot;HelloWorld&quot;print(string.encode())print(bytes.decode(string.encode())) 输出结果: 12b&apos;HelloWorld&apos;HelloWorld 注意:解码时必须使用与编码时相同的编码格式，否则将会抛出异常 Python dir()和help()帮助函数Python提供了两个函数，用于帮助程序员查询文档，掌握这两个函数则可以查看所有函数(方法)的用法及功能. dir() 列出指定类或模块包含的全部内容，包括函数、方法、类、变量etc. help() 查看某个函数或方法的帮助文档。 例子: 查看字符串能调用的全部内容 1print(dir(str)) 输出结果: 123456789101112[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__getnewargs__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;,&apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;, &apos;center&apos;, &apos;count&apos;, &apos;encode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;format_map&apos;, &apos;index&apos;, &apos;isalnum&apos;, &apos;isalpha&apos;, &apos;isascii&apos;, &apos;isdecimal&apos;, &apos;isdigit&apos;, &apos;isidentifier&apos;, &apos;islower&apos;, &apos;isnumeric&apos;, &apos;isprintable&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;, &apos;join&apos;, &apos;ljust&apos;, &apos;lower&apos;, &apos;lstrip&apos;, &apos;maketrans&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;rjust&apos;, &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;] 注意:其中以_结尾的方法为私有方法，不希望被外界直接调用。 help() 想要查看某个方法或函数的帮助文档，就使用help()函数 print(help(str.format)) 输出结果: 12345678Help on method_descriptor:format(...) S.format(*args, **kwargs) -&gt; str Return a formatted version of S, using substitutions from args and kwargs. The substitutions are identified by braces (&apos;&#123;&apos; and &apos;&#125;&apos;).(END)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自我反省]]></title>
    <url>%2F2019%2F09%2F23%2F%E8%87%AA%E6%88%91%E5%8F%8D%E7%9C%81%2F</url>
    <content type="text"><![CDATA[自我反省，回想一下开学以来自己都做了些什么? &emsp;&emsp;还在暑假时，我就十分期待开学，因为暑假一个人有些无聊。不是说hack不够快乐，而是我更想偶尔跟朋友一起娱乐。现在开学也有20天了，我却发现我开学时的计划已经被我忘得干干净净了。所以我得总结一下，自开学以来，李天宇都干了些什么? &emsp;&emsp;由于在上学期竞选了社团技术部的部长，所以我不得不处于刚开学就忙得不可开交的状态。说实话，我并不擅长管理，而社团部门部长这一任职对我来说压力挺大的，我得每天留意微信，遗漏掉任何一条消息，都可能失去大量的信息。正是因为我每天微信消息很多，所以我越来越讨厌那些发长语音的人(除了我女朋友)，如果长语音能清晰地表达出意思还好，但往往很多人都是在嗯…啊…昂…徘徊，花费近1min的时间去听那个信息量两三句话的语音，简直让我每次听完都想立刻瞬间移动到对方面前，大喊几声:”你到底想说什么?你发语音能不能别发那么长段的!”，不过得益于网络的发展，我并不需要瞬间移动过去，我偶尔会把这两句话通过微信以网络传输的方式发送至对方。事情往往没有想得那么简单，因为我发完那两句话之后，对方可能又是一个长语音过来，解释他刚刚说的。讲了这一个小例子，读者们可能意识到，我是想表达:因为很多人是这么做的，所以我在使用微信时是十分低效的。每次想到这里，我就回想起在irc内通过邮件列表互相交流的时光是多么的美好。 &emsp;&emsp;我几乎每天都会在图书馆待上一阵子，正如此时，我就在图书馆敲打着蝶式键盘写着这一句。每天在图书馆的时间，我都用来学习Python了，因为我在暑假时在B站发现一位up主，他使用Vim完成日常的写代码、写文章、记笔记的事情，并且在看过他演示后，我便被他所提到的Vim彻底吸引了，因为实在太高效了。那时我每天就研究关于Linux某些软件的配置，例如:i3wm,ranger,neovim，其中我渐渐觉得Python几乎出现在我所接触到的软件的任何地方，可能是由于其第三方库丰富以及语法简单、优雅，程序可移植性高的缘故，由Python开发的开源软件，大多数都可以很轻松的使用Python扩展你想要添加的新功能。其中ranger我就想着为其提供一些新功能，所以我便开始学习Python，图书馆的日子基本都是学习Python这门语言了。 &emsp;&emsp;前面介绍了我生活的一些七七八八的东西，搞的我脑子很乱，我发现我还是不怎么会写作，下次得好好看下如何写作了，这篇文章暂时先写到这里，等我什么时候(咕咕咕) 有新想法了再继续吧!]]></content>
      <categories>
        <category>个人感想</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python-04]Python列表、元组、字典和集合]]></title>
    <url>%2F2019%2F09%2F08%2FPython-04-Python%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Python系列第四章笔记，查看Python系列所有文章，请点击💿 什么是序列，Python序列详解（包括序列类型和常用操作）序列：一块可存放多个且连续的内存空间，并且这些值有顺序，可通过索引进行访问。 常见的序列有: 字符串、列表、元组、集合和字典。 这些常见的序列，除了集合和字典不支持索引、切片、相加和相乘的操作，其余的都可以。 序列索引索引就是一个序列中每个元素的编号。第一个元素的索引是0，也就是说想要访问某个序列的第一个元素，那么它的索引就是0，而想要访问最后一个元素，那么它的索引就是序列长度-1 索引还分为正索引值和负索引值，它们的区别仅仅在于访问方式不同。 注意: 正索引值的起始位置是0，结束位置是序列长度-1 负索引值的起始位置是-1,结束位置是-(序列长度-1) 例子: 根据索引访问序列元素 12str = &quot;Hello World&quot;print(&quot;str 的第一个字符是:%s，最后一个字符是:%s&quot; % (str[0],str[len(str)-1])) 输出结果:1str 的第一个字符是:H，最后一个字符是:d 序列切片刚刚我们通过索引值进行访问序列元素，那么序列切片也是可以做到的，它可以访问某个范围内的元素。 语法格式: 1sname[start:end:step] sname:序列名称 start:切片开始的索引位置（包括该位置），此参数可不指定，默认为0。 end:切片结束的索引位置(不包括该位置)，此参数可不指定，默认为序列的长度。 step:切片的范围，也就是每次取元素时，要隔多少个位置，此参数可不指定，可以直接忽略最后一个冒号 例子: 12345str = &quot;Hello World&quot;# 获取整个字符串print(str[:])# 从索引4开始，一直到最后一个，没隔2个字符取一次。print(str[4::2]) 输出结果: 12Hello WorldoWrd 序列相加序列可以使用+运算符，进行相加操作，他会将两个序列进行连接，但不会去除重复的元素。 例子: 123str1=&quot;hello&quot;str2=&quot;world&quot;print(str1+str2) 输出结果:helloworld 序列相乘使用*运算符，可以将序列的元素进行重复。 例子: 12str1 = &quot;hello\t&quot;print(str1*3) 输出结果:hello hello hello tips:可以使用序列相乘，创建指定长度空列表 1test_list = [None]*5 检查元素是否包含在序列中使用in关键字可以检查序列中的元素是否存在。 语法格式: 1value in sequence 例子: 12str1=&quot;Hello&quot;print(&apos;o&apos; in str1) 输出结果: True tips:使用not in关键字可以检查是否不存在 和序列相关的内置函数Python提供了几个用于操作序列的内置函数，可以很方便的操作序列。 Python list列表详解Python提供了一种数据结构————list(列表) 列表可以存储多个不同数据类型的元素。 Python创建列表创建列表分为两种方式 使用=运算符创建列表 语法格式: 1listname = [element1,element2...elementn] listname: 列表的名称 element1: 列表的元素 例子: 123456# 创建一个列表test_list1 =[&quot;one&quot;,1,True,1.0]print(test_list1)# 创建一个空列表empty_list = []print(empty_list) 输出结果: 12[&apos;one&apos;, 1, True, 1.0][] 使用list()函数创建列表 例子: 123str1=&quot;HelloWorld&quot;test_list = list(str1)print(test_list) 输出结果: 1[&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;W&apos;, &apos;o&apos;, &apos;r&apos;, &apos;l&apos;, &apos;d&apos;] 访问列表元素两种方式：通过索引访问和通过切片访问。 删除列表不常用，因为Python具有垃圾回收机制，有些不需要再使用的列表将会自动回收。 使用del关键字进行删除 语法格式: 1del listname 注意:删除后的列表不能再次使用 Python list列表添加元素的3种方法Python append()方法添加元素append()方法在列表的末尾追加元素。 语法格式: 1listname.append(obj) listname代表要添加元素的列表;obj代表要添加到列表末尾的数据。 obj可以是单个元素，也可以是其他序列。 例子: 12345678910# 追加单个元素list1 = [0,1,2,3]print(list1)list1.append(4)print(list1)# 追加一个列表list2 = [5,6,7,8]print(list2)list1.append(list2)print(list1) 输出结果:1234[0, 1, 2, 3][0, 1, 2, 3, 4][5, 6, 7, 8][0, 1, 2, 3, 4, [5, 6, 7, 8]] 注意:使用append()函数时，如果是传递的单个数据，将会直接追加到列表后，但是如果传入的是个列表（序列），那么则会追加一个列表形式的元素。 想要访问刚刚追加的列表元素的其中一个可以这样： 1234list1 = [0,1,2]list2 = [3,4,5]list1.append(list2)print(list1[3][2]) 输出结果:5 Python extend()方法添加元素刚刚我们使用append()函数追加了个列表元素，但是并没有像添加单个字符一样作为一个整体添加，而我们只需要使用extend()方法就可以将列表以整体的方式添加进去。 例子: 123456list1 = [0,1,2,3]print(list1)list2 = [5,6,7,8]print(list2)list1.extend(list2)print(list1) 输出结果: 123[0, 1, 2, 3][5, 6, 7, 8][0, 1, 2, 3, 5, 6, 7, 8] Python insert()方法插入元素需要指定插入列表元素的位置时，可以使用insert()方法。 语法格式: 1listname.insert(index,obj) index: 将obj插入到listname列表的索引 例子: 123456test_list1 = list(range(1,11))print(test_list1)print(len(test_list1))test_list1.insert(len(test_list1),11)print(test_list1) 输出结果: 123[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]10[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] Pyhton list列表删除元素(3种方法) del删除 del语句在Python中可以删除变量、列表的元素 1234test_list = list(range(1, 11))print(test_list)del test_list[1::2]print(test_list) 输出结果: 12[1, 2, 3, 4, 5, 6, 7, 8, 9, 10][1, 3, 5, 7, 9] 根据元素值进行删除 可以使用remove()方法来删除列表元素。 删除第一个被查找到的元素。 注意:remove()方法不是根据索引来删除元素的，而是查找元素本身，再进行删除，所以如果找不到元素，则会报错 例子: 1234test_list = [&apos;test&apos;, 30, &apos;test2&apos;, 10, 30]test_list.remove(&apos;test&apos;)test_list.remove(30)print(test_list) 输出结果: 1[&apos;test2&apos;, 10, 30] 删除列表所有元素 使用clear()方法可以删除列表的所有元素。 例子: 123test_list = [&apos;test&apos;, 30, &apos;test2&apos;, 10, 30]test_list.clear()print(test_list) 输出结果: 1[] Python list列表修改元素修改列表元素，可以通过列表索引获取元素进行赋值。 1234testlist = list(range(1,10))print(testlist)testlist[len(testlist)-1] = 100print(testlist) 输出结果: 1234[1, 2, 3, 4, 5, 6, 7, 8, 9][1, 2, 3, 4, 5, 6, 7, 8, 100][Process exited 0] 使用slice语法对列表部分进行赋值。 slice语法，不要求新赋值的元素个数与原来的元素个数相等。也就是说使用slice剩余法既可以为列表增加元素，也可以为列表删除元素。 12345b_list = list(range(1,5))print(b_list)b_list[1:3] = [&apos;a&apos;,&apos;b&apos;]print(b_list) 输出结果: 12[1, 2, 3, 4][1, &apos;a&apos;, &apos;b&apos;, 4] Pyhthon list常用方法(count、index、pop、reverse和sort)快速攻略Pyhton为list提供了一些常用的方法。 我们使用dir(list)方法可以看到列表包含的所有方法。 1print(dir(list)) 输出结果: 123456 _&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;,5 &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setat4 tr__&apos;, &apos;__setitem__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;c3 lear&apos;, &apos;copy&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;2 , &apos;sort&apos;] 注意，方法名包含双下划线的不推荐使用 count()方法count()方法用于统计列表中某个元素出现的次数 语法格式 listname.count(obj) listname:列表名称 obj:表示判断是否存在的元素 例子: 123a_list = [2]*5print(a_list)print(&quot;2出现%d次&quot; % a_list.count(2)) 12[2, 2, 2, 2, 2]2出现5次 index()用法index()方法用于定位某元素在列表的索引位置，如果该元素没有出现，则会引发ValueError错误。 语法格式: listname.index(obj,start,end) index()方法可以传入start,end参数，用于指定在列表的某范围内搜索元素 例子: 123test_list = list(range(1,10))print(test_list)print(test_list.index(9)) 输出结果: 12[1, 2, 3, 4, 5, 6, 7, 8, 9]8 pop用法pop()方法会溢出列表中指定索引处的元素，如果没有传入参数，则会移除列表中最后一个元素。 语法格式: listname.pop(index) 例子: 12345678test_list = list(range(1,10))print(test_list)# 默认移除最后一个元素test_list.pop()print(test_list)# 移除第一次元素print(test_list.pop(0))print(test_list) 输出结果: 12345[1, 2, 3, 4, 5, 6, 7, 8, 9][1, 2, 3, 4, 5, 6, 7, 8]1[2, 3, 4, 5, 6, 7, 8] reverse()方法reverse()方法会将列表中所有元素反向存放。 语法格式; listname.reverse() 例子: 1234test_list = list(range(1,11))print(test_list)test_list.reverse()print(test_list) 输出结果: 12[1, 2, 3, 4, 5, 6, 7, 8, 9, 10][10, 9, 8, 7, 6, 5, 4, 3, 2, 1] sort()用法sort()方法用于对列表元素进行排序。 语法格式: listname.sort(key=None,reserse=Fale) key参数用于指定从每个元素中提取一个用于比较的键。 reverse参数用于设置是否需要逆序，默认为False也就是从小打到排序，否则反之。 例子: 12345678a_list = [123,213,1,325,1,51,213,5132,4156]print(a_list)# 对列表进行排序a_list.sort()print(a_list)# 逆序排序a_list.sort(reverse=True)print(a_list) 输出结果: 123[123, 213, 1, 325, 1, 51, 213, 5132, 4156][1, 1, 51, 123, 213, 213, 325, 4156, 5132][5132, 4156, 325, 213, 213, 123, 51, 1, 1] Python range()快速初始化数字列表Python的range()函数能够生成一系列的数字。 12for value in range(1,5): print(value) 输出结果: 12341234 range()方法是指定从第一个值开始，生成连续的数字，直到指定的第二值为止(不包括第二个值) range()方法可以指定步长，也就是说，每次连续增加时所增加的数值。 Python tuple元组详解与列表类似，元组也可以存储任何Python的数据类型，但元组是不可变的，一旦赋值则不可修改。 Python中，使用()小括号包住的一列数据，被称为元组，而各数据之间又由,逗号隔开。 元组的数据类型是:tuple 12test_tuple = tuple(range(1,11))print(type(test_tuple)) 输出结果: 123&lt;class &apos;tuple&apos;&gt;[Process exited 0] Python创建元组= 运算符直接创建元组可以使用赋值运算符=将一个元组赋值给变量。 语法格式: 1tuplename = (element1,element2...elementn) 其中tuplename表示要创建的元组名,element代表元素。 例子: 1234567num_tuple = tuple(range(1,11))str_tuple = (&quot;Just A Test&quot;,)object_tuple = (&quot;a&quot;,1,2.22,num_tuple,list(range(1,5)))print(num_tuple)print(str_tuple)print(object_tuple) 输出结果: 123(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)Just A Test(&apos;a&apos;, 1, 2.22, (1, 2, 3, 4, 5, 6, 7, 8, 9, 10), [1, 2, 3, 4]) 注意 :创建元组时，如果元组内只有一个元素，那么必须要在元素后加上一个逗号，否则Python解释器将会一位是字符串。 1234test_str = (&quot;Just a Test&quot;)str_tuple = (&quot;Jest a Test&quot;,)print(type(test_str))print(type(str_tuple)) 输出结果: 12&lt;class &apos;str&apos;&gt;&lt;class &apos;tuple&apos;&gt; 使用tuple()函数创建元组Python提供了tuple()函数创建元组，我们可以将一些常见的对象，转化成元组。 语法格式: tuple(iterable: Iterable[_T_co]=...) 例子: 12345test_list = list(range(1,21,2))test_tuple = tuple(test_list)print(type(test_list))print(type(test_tuple)) 输出结果: 12&lt;class &apos;list&apos;&gt;&lt;class &apos;tuple&apos;&gt; Python访问元组元素可以通过元素的下标获取或通过切片操作获取。 Python修改元组元素虽然前面提到元组是不可变序列，但还是可以通过一些手段进行修改元组内的数据。 重新赋值1234test_tuple = tuple(range(1,6))print(test_tuple)test_tuple = tuple(range(1,20))print(test_tuple) 输出结果: 12(1, 2, 3, 4, 5)(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19) 连接多个元组12345test_tuple = tuple(range(1,6))print(test_tuple)test_tuple2 = tuple(range(6,11))test_tuple += test_tuple2print(test_tuple) 输出结果: 12(1, 2, 3, 4, 5)(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) Python删除元组若创建的元组不再使用可以使用del语句将其删除。 Python元组和列表的区别本节讨论元组和列表的区别: 区别 元组 列表 元素是否允许任意修改 ❌ ⭕ 是否能作为map的key ⭕ ❌ 内存占用小 ⭕ ❌ Python列表和元组的底层实现这里就不记录笔记了，总的来说就是列表是一个长度可变且连续的内存空间，当列表的元素满了后，将会申请更多的内存空间，再将原本的内存空间拷贝过去。而元组则是一个空间带下固定且连续的内存空间。Python对元组进行了优化，例如为了避免系统老是释放和申请内存空间这一繁琐且耗时的操作，所以每次释放元组时其实是将其放入一个缓存中，如果下次还需要申请相同数据的元组，则可以直接从缓存中拿到。 具体介绍看这里💿Python列表和元组的底层实现 Python dict字典dict字典属于可变序列，但是无序的序列，其内容是键值对的形式保存的。 键值对也可以称为映射，所以字典的值与键是互相对应的关系。 Python字典特征 特征 解释 通过键读取元素 通过字典中的键来获取指定项，而不是通过索引获取 字典是任意数据类型的无序集合 和列表、元组不同，索引值可以通过数字获取对应的元素，而字典中的元素是无序的。 字典是可变的，并且可以任意嵌套 字典可以在原处增长或缩短，并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其他字典 字典中的键必须是唯一的 字典中不允许出现相同的键，否则只会保留最后一个键值对 字典中的键必须是不可变的 字典中的值是不可变的，所以只能使用数字、或元组、字符串等，不能使用可变，例如可变序列：列表 Python中字典的数据类型为dict Python创建字典花括号语法创建字典字典中每个元素都包含两个部分，分别是键和值。因此在创建字典元素时，需要在键和值之间以冒号:分隔，相邻元素之间使用逗号分隔，所有元素放下大括号{}间。 语法格式: dictname = {&#39;key1&#39;:&#39;value&#39;,&quot;key2&quot;:&quot;value&quot;} 其中dictname 代表字典名，key:value 表示各个元素的键值对。 使用花括号创建字典例子: 12test_dict = &#123;&quot;语文&quot;:80,&quot;数学&quot;:12&#125;print(test_dict) 输出结果 {&#39;语文&#39;: 80, &#39;数学&#39;: 12} 通过fromkey()方法创建字典Python中使用dict字典类型提供的fromkeys()方法创建所有键值为空的字典。 语法格式 dictname=dict.fromkeys(list,value=None) list参数表示字典中键的列表，value参数默认为None，表示所有键对应的值。 例子: 123knowledge = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;scores = dict.fromkeys(knowledge,100)print(scores) 输出结果: 1&#123;&apos;语文&apos;: 100, &apos;英语&apos;: 100, &apos;数学&apos;: 100&#125; 通过dict()映射函数创建字典dict()函数常用创建字典方法 函数创建字典.png) Pyton访问字典dict()通过元素的键进行访问值，不能像列表或元组通过下标或切片的形式来访问。 例子: 12345test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])test_dict = dict(test_dict)print(type(test_dict))print(test_dict[&apos;姓名&apos;])print(test_dict.get(&quot;性别&quot;)) Python删除字典如需手动删除，可以使用del语句。 Pythton dict字典基本操作(包括添加、修改、删除键值对)本小节对字典实现常见的操作: 向字典中添加新的键值对 修改字典中的键值对 从字典中删除指定的键值对 判断字典中是否存在指定的键值对 Python字典添加键值对为字典中添加新的键值对只需要为不存在的key赋值。 语法格式: dict[key]= value dict表示字典名称,key代表新建键值对的键,value代表新建键值对的值 例子: 1234test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])test_dict = dict(test_dict)test_dict[&apos;班级&apos;] = 502print(test_dict.get(&quot;班级&quot;)) 输出结果: 502 Python字典修改键值对这里的修改是指:修改键值对的值。 Python中如果新添加的键值对的键存在，那么则会覆盖原本的键值对的值 例子: 123456test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])test_dict = dict(test_dict)test_dict[&apos;班级&apos;] = 502print(test_dict.get(&quot;班级&quot;))test_dict[&apos;班级&apos;] = 999print(test_dict.get(&quot;班级&quot;)) 输出结果: 12502999 Python字典删除键值对如果要删除字典中的键值对，则可以使用del语句，指定要删除的键值对的键。 例子: 123456test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])test_dict = dict(test_dict)test_dict[&apos;班级&apos;] = 502print(test_dict.get(&quot;班级&quot;))del test_dict[&apos;班级&apos;]print(test_dict.get(&quot;班级&quot;)) 输出结果: 12502None 判断字典中是否存在指定键值对如果需要判断字典是否存在指定键值对的键，可以使用in或not in运算符。 注意:这里的in或not in运算符都是基于key来判断字典中某个键值对是否存在的. 例子: 12345test_dict = ([&apos;姓名&apos;,&apos;LTy&apos;],[&apos;性别&apos;,True])test_dict = dict(test_dict)del test_dict[&apos;姓名&apos;]print(test_dict.get(&quot;姓名&quot;))print(&apos;姓名&apos; in test_dict) 输出结果: 12NoneFalse Python dict字典方法完全攻略(全)想查看dict该类包包含哪些方法，可以使用dir()方法进行查看。 Python keys(),values()和items()方法这三个方法可以获取字典中特定的数据. keys()方法用于返回字典中的所有键; values()用于返回字典中所有键对应的值; items()用于返回字典中所有的键值对; 例子: 12345test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;test_dict = dict.fromkeys(test_dict,100)print(test_dict.keys())print(test_dict.values())print(test_dict.items()) 输出结果: 123dict_keys([&apos;英语&apos;, &apos;语文&apos;, &apos;数学&apos;])dict_values([100, 100, 100])dict_items([(&apos;英语&apos;, 100), (&apos;语文&apos;, 100), (&apos;数学&apos;, 100)]) 注意:Python2.x中，上面提到的方法的返回值是列表类型。但在Python3.x中，以上方法返回的类型不是序列类型。 Python copy()方法copy()方法用于返回一个具有相同键值对的新字典: 例子: 1234test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;test_dict = dict.fromkeys(test_dict,100)test_dict2 = test_dict.copy()print(test_dict,&quot;\n&quot;,test_dict2) 输出结果: 12&#123;&apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;数学&apos;: 100&#125;&#123;&apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;数学&apos;: 100&#125; 注意Python的copy()方法涉及到深拷贝与浅拷贝的关系，当字典A拷贝键值对给字典B后，那么拷贝的数据(字典B内)将会在字典A对键值对进行修改时发生变化，而字典A添加新的键值对，字典B不收影响。 Python update()方法updae()方法可以使用一个字典所包含的键值对来更新已有的字典。 如果被更新的字典中已存在对应的键值对，那么原键值对值将会被覆盖，否则将会被添加。 例子: 123456789test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;test_dict = dict.fromkeys(test_dict,100)test_dict2 = test_dict.copy()print(type(test_dict))test_dict[&apos;语文&apos;]=100test_dict2[&apos;物理&apos;]=200test_dict2.update(test_dict)print(test_dict,&quot;\n&quot;,test_dict2)print(test_dict,&quot;\n&quot;,test_dict2) 输出结果: 12345&lt;class &apos;dict&apos;&gt;&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100&#125;&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 200&#125;&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100&#125;&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 200&#125; Python pop方法pop()方法可以获取指定key的value，并删除。 例子: 123test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;test_dict = dict.fromkeys(test_dict,100)print(test_dict.pop(&apos;语文&apos;)) 输出结果: 12100&#123;&apos;英语&apos;: 100, &apos;数学&apos;: 100&#125; Python popitem()方法popitem()方法用于弹出字典中最后一个键值对(这里的最后一个其实是随机的，因为字典是无序序列，所以并不能说的某个键值对的位置取向). 例子: 1234test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;test_dict = dict.fromkeys(test_dict,100)print(test_dict.popitem())print(test_dict) 输出结果: 12(&apos;数学&apos;, 100)&#123;&apos;英语&apos;: 100, &apos;语文&apos;: 100&#125; Python setdefault()方法setdefault()方法用于根据key来获取value，但有两种场景，第一种是，如果获取的键值对的key存在字典中，则会直接获取改键值对的value，不存在则会为该key先将value设置为默认的value，然后再返回该key对应的value。 特点:setdefault方法总能返回指定key对应的value; 例子: 12345678test_dict = &#123;&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;&#125;test_dict = dict.fromkeys(test_dict,100)# 要设置的键值对的key不存在.test_dict.setdefault(&apos;物理&apos;,120)print(test_dict)# 要设置的键值对的key存在.test_dict.setdefault(&apos;语文&apos;,200)print(test_dict) 输出结果: 12&#123;&apos;数学&apos;: 100, &apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 120&#125;&#123;&apos;数学&apos;: 100, &apos;英语&apos;: 100, &apos;语文&apos;: 100, &apos;物理&apos;: 120&#125; Python使用字典格式化字符串我们知道，在格式化字符串时，如果格式化字符串模板中包含多个变量时，则后面月必须按顺序加上相同个数的变量，如果变量过多，则会十分麻烦，Python提供了用字典格式化字符串的方式来解决。 例子: 123student = &apos;姓名:%(name)s\t班级:%(class)d\t综合成绩:%(score)f&apos;student_info = &#123;&apos;name&apos;:&apos;LTy&apos;,&apos;class&apos;:604,&apos;score&apos;:99.5&#125;print(student % student_info) 输出结果: 1姓名:LTy 班级:604 综合成绩:99.500000 Python set集合详解set集合的特点: 数据唯一性(必须保证集合中每种数据元素是唯一的) 数据不可变(只允许存储不可变的数据类型，例如列表、字典、集合则是不允许存储在集合中的) 集合是无序的，所以每次输出元素时，排序顺序可能都不同。 Python创建set集合有两种创建set集合的方法，分别是使用{}创建和使用set()函数将列表、元组等数据类型转化为集合。 使用{}创建语法格式: setname = {element1,element2...elementn} setname代表集合的名称。 例子: 12test_set = &#123;1,2,3,4&#125;print(test_set) 输出结果: 1&#123;1, 2, 3, 4&#125; 使用set()函数创建集合set()函数为Python的内置函数，其可以将字符串、列表、元组以及range对象等可迭代的对象转换成集合。 语法格式: setname = set(iteration) iteration就表示可迭代的对象。 12345678set1 = set(&quot;I Love China&quot;)set2 = set(list(range(1,6)))set3 = set(tuple(range(1,6)))set4 = set(range(1,6))print(set1)print(set2)print(set3)print(set4) 输出结果: 12345# 从输出结果看，字符串被打乱了&#123;&apos;a&apos;, &apos;L&apos;, &apos;h&apos;, &apos; &apos;, &apos;C&apos;, &apos;e&apos;, &apos;n&apos;, &apos;i&apos;, &apos;I&apos;, &apos;v&apos;, &apos;o&apos;&#125;&#123;1, 2, 3, 4, 5&#125;&#123;1, 2, 3, 4, 5&#125;&#123;1, 2, 3, 4, 5&#125; 注意:如果想要创建空集合，必须使用set()函数实现，因为如果只给一对{}，Python解释器会将其视为一个空字典。 Python访问set集合元素由于set集合是无序的，所以无法通过下标索引进行访问，但是我们可通过遍历set集合访问元素。 1234set1 = set(&quot;I Love China&quot;)for ele in set1: print(ele,end=&apos;&apos;) 输出结果: 1oCenaL Ihvi Python删除set集合想要手动删除set集合可以使用del()方法。 1234set1 = set(&quot;I Love China&quot;)print(set1)del(set1)print(set1) 输出结果: 12345&#123;&apos;a&apos;, &apos;i&apos;, &apos;e&apos;, &apos; &apos;, &apos;L&apos;, &apos;C&apos;, &apos;o&apos;, &apos;h&apos;, &apos;I&apos;, &apos;n&apos;, &apos;v&apos;&#125;Traceback (most recent call last): File &quot;test.py&quot;, line 4, in &lt;module&gt; │ print(set1)NameError: name &apos;set1&apos; is not defined Python set集合基本操作(添加、删除、交集、并集、差集)set集合最常用的场景是添加、删除元素以及在多个集合之间做交集、并集、差集等运算。 向set集合中添加元素Python为set集合提供了add()方法，其可以向set集合添加元素。 语法格式: setname.add(element) setname表示要添加元素的集合，element代表添加的元素。 注意:element不可为可变数据类型 从set集合中删除元素想要从集合中删除某个元素可以使用remove()方法 语法格式: setname.remove(element) 例子: 1234set1 = &#123;1,2,3,4&#125;print(set1)set1.remove(1)print(set1) 输出结果: 12&#123;1, 2, 3, 4&#125;&#123;2, 3, 4&#125; 注意:如果要删除的元素已经被删除，再次删除则会引发KeyError错误 如果想要在删除失败时不抛出异常，我们可以使用discard()方法。 例子: 12345678set1 = &#123;1,2,3,4&#125;print(set1)set1.remove(1)print(set1)set1.discard(1)print(set1)set1.remove(1)print(set1) 输出结果: 1234567&#123;1, 2, 3, 4&#125;&#123;2, 3, 4&#125;&#123;2, 3, 4&#125;Traceback (most recent call last): File &quot;test.py&quot;, line 7, in &lt;module&gt; │ set1.remove(1)KeyError: 1 discard()方法与remove()方法的唯一区别在于:删除失败时是否抛出异常 o Python set集合做交集、并集、差集运算set集合最常用的操作也就是进行交集、并集、差集以及对称差集运算了，首先看这张图: 图中有两个集合，分别是: set1={1,2,3} set2={3,4,5} 下面的表格展示了不同的运算，得到的不同的结果。 Python set集合方法详解(全)如果想要看set集合所有的方法，可以使用dir(set)进行查看。 Python set方法 方法名 语法格式 功能 add() set1.add() 向set1集合中添加非可变元素 clear() set1.clear() 清空set1集合中所有的元素 copy() set2=set1.copy() 拷贝set1集合中的元素给set2 difference() set3=set1.difference(set2) 将set1中有而set2中没有的元素给set3 difference_update() set1.difference_update(set2) 从set1中删除与set2相同的元素 discard() set1.discard(element) 删除set1中的element元素 intersection() set3=set1.intersection(set2) 取set1和set2的交集赋值给set3 intersection_update() set1.intersection_update(set2) 取set1和set2的交集并且将值赋值给set1(更新set1的值为set1与set2的交集) isdisjoint() set1.isdisjoint(set2) 判断set1和set2是否没有交集，有交集返回False;没有则返回True issubset() set1.issubset(set2) 判断set1是否是set2的子集 issuperset() set1.issuperset(set2) 判断set2是否是set1的子集 pop() a = set1.pop() 取出set1中一个元素并赋值给a remove() set1.remove(element) 移除set1中的element元素 symmetric_difference() set3=set1.symmetric_difference(set2) 取set1和set2中互不相同的元素给set3 symmetric_difference_update() set1.symmetric_difference_update(set2) 取set1和set2中互不相同的元素并更新set1的值 union() set3=set1.union(set2) 取set1和set2的并集，赋值给set3 update() set1.update(element) 添加列表或集合中的元素到set1 Python frozenset(set集合的不可变版本)前面我们所学习的set集合是可变的，而frozenset则是set集合的不可变版本，它不具备set集合的所有能改变集合本身的方法。 frozenset的主要使用场景: 当集合元素不需要改变的时候，使用frozenset替代set将会更加安全。 当某些API需要不可变对象作为参数时，必须用到frozenset替代set。 深入底层了解Python字典和集合、一眼看穿他们的本质本小节涉及到未知的知识，推荐去原文看**查看原文 Python深拷贝和浅拷贝详解本小节涉及到未知的知识，推荐去原文看查看原文]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python-03]Python变量类型和运算符]]></title>
    <url>%2F2019%2F08%2F31%2FPython-03-Python%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Python系列第三章笔记，查看Python系列所有文章，请点击💿 本章重点:Python变量数据类型、运算符。 Python是弱类型语言。 弱类型含义: 所有变量无需声明即可使用。 变量的数据类型随时可变。 Python变量及其使用变量: 数据可发生无数次变化。 数据类型可发生变化。 常量: 一旦保存数据，则不可修改。 赋值运算符: = type()作用:查看变量的数据类型 Python数值类型（整型、浮点型和复数）及其用法Python中的数值类型都是不可变的。 有些人可能会问，不是不可变么，为什么我定义的int类型变量的值仍然可以变化，那是因为底层实现将新的值存放到新的一块内存中，然后将修改变量指针的指向。 Python整型 整型是用来表示没有小数部分的数，整数包括：正整数、0、负整数 Python整型的四种表示形式： 十进制(0-9) 二进制(0-1) 八进制(0-7) 十六进制(0-9-A-F/a-f) Python浮点型 浮点型是用来保存带小数的数值，浮点数包括:十进制形式、科学计数形式。 十进制形式的写法: 1float_dex = 1.100111 科学计数形式 1float2 = 2e3 Python复数 我跳过了本节，如果读者想看，可以点击进行访问💿Python复数 Python字符串详解(包含长字符串和原始字符串)Python字符串必须使用引号括起来，可以是单引号也可以是双引号，但必须成对。 如果字符串内仍然包含引号，可以使用以下两种方法解决: 用另一种成对的引号包括起来 123str1 = &quot;I&apos;m EvanMeek.&quot;str2 = &apos;Evan:&quot;Hello World.&quot;&apos; 用转义字符进行转义 1str1 = &apos;I\&apos;m EvanMeek&apos; 转义字符还可以用来转义换行符，应用场景通常是: 字符串过长，转义换行符，使其不换行 12print(&quot;mac mac macmac mac macmac mac mac \mac mac macmac mac mac&quot;) Python长字符串 长字符串常用场景是: 定义大段文本内容为字符串时 12str1 = &apos;&apos;&apos; &quot;Fuck you ! Bitch!&quot;,said he.&quot;Mother fuck!&quot;,said she. Python原始字符串 在Windows下,路径是使用反斜杠作为路径区分的，如果需要将反斜杠转义，那必须再加一个反斜杠，这样非常麻烦，就可以使用下面的案例来解决: 转义反斜杠写路径 1path = &apos;C:\\User\\Admin\\Desktop&apos; 使用原始字符串写反斜杠 1path = r&apos;C:\User\Admin\Desktop&apos; 注意: 原始字符串中的引号同样需要使用\进行转义 Python bytes类型及用法bytes类型代表了字节串。 字节串与字符串不同的是: 字节串是以字节为单位进行操作 字节串可直接用于网络通信数据互联 字节串是由多个字节组成的，每个字节由8个bit位组成。 字节串保存的数据都是二进制格式的数据。 字节串可以转换成字符串，而字符串也能恢复成字节串。 字节串转换为字符串 创建字节串 123456# 创建一个空的bytesb1 = bytes()# 创建一个空的bytes值b2 = b&apos;&apos;# 创建一个非空的字节串b3 = b&apos;hello&apos; 字符串转换为字节串 12345# 使用encode方法将字符串以utf-8字符集转换为字节串b4 = &quot;I love Python&quot;.encode(&apos;utf-8&apos;)# 创建bytes对象时将字符串的字符集指定为&apos;utf-8&apos;，自动转换为字节串b5 = bytes(&apos;I love Python&apos;, encoding=&apos;utf-8&apos;) 字节串转换为字符串 12# 使用字节串对象的方法decode，指定字符集转化字节串str1 = b&apos;I love Python&apos;.decode(&apos;utf-8&apos;) Python bool布尔类型bool变量只有两个值分别是: True,False。它们都是Python的关键字。 True代表真 False代表假 例如表达式: 13 &gt; 5 结果是False Python中所有对象都可以进行真假值的测试。 Python len()函数详解：获取字符串长度或字节数len()函数是Python内置函数，用于获取字符串或字节串的长度（数量）。 例子: 统计字符串的长度 1print(len(&quot;Hello World&quot;)) 输出结果: 11 统计字节串的长度 1print(len(&quot;你好世界&quot;.encode())) 输出结果: 12 不同的语言所占的字节数不同，并且不同的编码格式所占的字节数也不同。 例如，汉字使用utf-8编码格式，占用3个字节，中文标点符号使用GBK编码格式占用2个字节。 Python input()函数：获取用户输入的字符串input()是Python的内置函数，其作用是输出一段信息然后请求用户输入，并且将获取的值传入接收的对象。 input()函数将会把用户输入的任何字符都作为字符串读入。 例子: 12a = input(&quot;Please input something:&quot;)print(type(a)) 运行: 12Please input something &gt; 19&lt;class &apos;str&apos;&gt; 注意: Python2.x中，要求input()函数读入的内容必须是符合Python语法表达式的。 例如: 输入字符串时，必须带双引号，否则将会报错。 Python print()函数的高级用法 输出多个参数 例子: 123name = &quot;EvanMeek&quot;age = 18print(&quot;我叫:&quot;, name, &quot;age&quot;, 18) 输出: 1我叫: EvanMeek age 18 指定输出多个参数时的分隔符(默认的分割符为空格) 1234name = &quot;EvanMeek&quot;age = 18print(&quot;我叫:&quot;, name, &quot;age&quot;, 18)print(&quot;我叫:&quot;, name, &quot;age&quot;, 18, sep=&apos;|&apos;) 结果: 12我叫: EvanMeek age 18我叫:|EvanMeek|age|18 指定结束符(默认结束符为换行符\n) 123print(10,&apos;\t&apos;,end=&quot;&quot;)print(11,&apos;\t&apos;,end=&quot;&quot;)print(12,&apos;\t&apos;,end=&quot;&quot;) 结果: 110 11 12 指定输出目标(默认输出为标准输出) 12345f = open(&quot;test.txt&quot;, &quot;w&quot;)print(&apos;Just Test&apos;, file = f)f.close() 结果: 将 ‘Just Test’ 写入到 tes.txt文件内 Python格式化字符串(格式化输出)Python中的格式化字符串可以对各种类型的数据进行格式化输出。 例子: 格式化输出整型数据 12number = 100print(&quot;Number is:%s&quot; % number) 格式化分为三个部分，分别是被包括在双引号内的占位符(%s)、以及中间部分的 格式化分隔符(%)与对应占位符的变量或表达式(number) %s被称为占位符,又可以说是转换说明符(Conversion Specifier) 转换说明符 说明 %d,%i 转换为带符号的十进制形式的整数 %o 转换为带符号的八进制形式的整数 %x,%X 转换为带符号的十六进制形式额整数 %e 转换为科学计数法标识的浮点数(e小写) %E 转换为科学计数法标识的浮点数(E大写) %f,%F 转换为十进制形式的浮点数 %g 智能选择使用%f或%e格式 %G 智能选择使用%F或%E格式 %c 格式化字符及其ASCII码 %r 使用repr()将变量或表达式转换成字符串 %s 使用str()将变量或表达式转换为字符串 Python允许aaaaqaz123在占位符前添加一个标志用来指定对齐： -(减号) :指定左对齐 +(加号) : 表示数值总要带着符号. 0,表示不补充空格，而是补充0。 例子: 12345print(&quot;%06d&quot; % num2)print(&quot;%+06d&quot; % num2)print(&quot;%-6d&quot; % num2) 输出结果: 123000030+0003030 精度值：用于指定小数点后的数字位数，如果是字符串时指定转换后字符串的最大字符数 Python转义字符及用法转义字符是指在指定字符前添加反斜杠\，对特殊的字符进行转义。 表格请点击此链接查看👉💿Python常用/支持的转义字符 Python类型转换，Python数据类型转换函数大全Python身为弱类型编程语言，不需要为变量声明数据类型，但在某些场景下，仍然需要进行类型转换，而Python内置了很多常用数据类型的转换函数，请看下表。 函数 作用 int(x) 将x转换成整数类型 float(x) 将x转换成浮点数类型 complex(real,[,imag]) 创建一个复数 str(x) 将x转换成字符串 repr(x) 将x转换成表达式字符串 eval(str) 计算在字符串中的有效Python表达式，并返回一个对象 chr(x) 将整数x转换成一个字符 ord(x) 将字符x转化成它对应的整数值 hex(x) 将一个整数x转换成一个十六进制的字符串 oct(x) 将一个整数x转换成一个八进制的字符串 使用类型转换函数时，被转换的数据必须是有意义的，例如，在使用int()函数时无法将一个费阿拉伯数字的字符串进行转换。 Python算术运算符及用法详解算术运算符用于处理四则运算的符号，在数字的处理中应用得最多。 加法运算符 算术运算例子: 123a = 10b = 20print(&quot;%d&quot; % (a+b)) 输出:30 字符串拼接例子: 123hello = &quot;Hello&quot;world = &quot;World&quot;print(&quot;%s&quot; % hello+world) 输出:HelloWorld 减法运算符 减法算术例子: 1234a = 10b = 5print(&quot;%d&quot; % (10-5)) 输出:5 求负算术例子: 123a = 10a = -aprint(a) 输出: -10 *乘法运算符 乘法算术例子: 12a =10.5print(a*a) 输出:110.25 字符串连接例子: 12str=&quot;test &quot;print(str*3) 输出:test test test /和//除法运算符 普通除法算术例子(除不尽产生小数): 123a = 10b = 3print(a/b) 输出:3.3333333333333335 整除除法算术例子(除不尽舍去小数): 123a = 10b = 3print(a//b) 输出:3 注意:Python中不可使用0作为除数，否则会引发ZeroDivisionError错误 注意:Python2.x中没有整除运算符 Python2.x的的求整除的规则是: 当两个操作数都是整数时，/作为整除运算符 当两个操作数其中一个是浮点数时，/作为非整除运算符 %求余运算符 Python不需要求余的两个操作数是整数 Python不允许求余运算的第二个操作数为0 求余运算例子: 12print(&quot;10 % 3 = &quot;,(10%3))print(&quot;10.5 % 3.5 = &quot;,(10.5%3.5)) 输出: 1210 % 3 = 110.5 % 3.5 = 0.0 注意: 若求余运算第二个操作符为负数，那么结果也一定是负数。 **乘方运算符 乘方+开方运算例子: 1234print(&apos;5 的 2 次方：&apos;, 5 ** 2) # 25print(&apos;4 的 3 次方：&apos;, 4 ** 3) # 64print(&apos;4 的开平方：&apos;, 4 ** 0.5) # 2.0print(&apos;27 的开 3 次方：&apos;,27 **(1 / 3 )) # 3.0 输出: 12345 的 2 次方： 254 的 3 次方： 644 的开平方： 2.027 的开 3 次方： 3.0 Python赋值运算符（入门必读）赋值运算符常用于将运算符右侧的值赋值给左侧的容器。 基本赋值运算符 将赋值运算符右侧的表达式赋值给左侧的容器。 1234a = 10b = ac = a+bprint(a,b,c) 输出:10 10 20 扩展后的赋值运算符 =赋值运算符与其他运算符结合后，将成为功能更强大的赋值运算符。 Python位运算符详解初学者可暂时跳过本章 位运算符通常使用场景是：图形、图像处理、创建设备驱动等底层开发。 Python位运算符的操作对象为整数类型，它会把数字看做相应的二进制来进行计算。 &amp;按位与运算符 有两个操作数 运算符法则：按位将2个操作数对应的二进制进行一一对应，对应时，只有对应数位都为1时，则结果为0，否则为1。 例如: 123a = 10b = 5print(bin(a), bin(b), a &amp; b) 输出结果: 10b1010 0b101 0 |按位或 运算符 |是其运算符，具有两个操作数。 运算符法则：按位将2个操作数对应的二进制进行一一对应，对应时，只有对应数位都为0时，则结果才为0，否则为1。 ^按位异或运算符 ^是其运算符，具有两个操作数。 运算符法则：按位将两个操作数对应的二进制进行一一对应，对应时，若对应数位都为0或1，则结果为0，否则为1 ~按位取反运算符 ~是其运算符，具有1个操作数 运算符法则：将其操作数的二进制进行取反，也就是：原本为0的取反为1，原本为1的取反为0. 其他：原码、反码、补码是什么 原码: 将某数值转换为二进制数，若此数值为正数或0则代表可以是无符号的，那么最高位则不需要一个符号位，若为负数则需要一个符号位。 反码: 对原码按位取反，但符号位不变。 补码: 负数的补码是其反码+1，正数或0的补码与原码相同。 &lt;&lt;左移运算符 &lt;&lt;是其运算符，具有两个操作数 将操作数按补码形式进行整体向左移动。移动后，溢出的丢弃，空出的以0填补。 >> 右移运算符 &gt;&gt;是其运算符，具有两个擦作数 将操作数按补码形式进行整体向右移动。移动后，溢出的丢弃，空出的以符号位填补。。 Python比较运算符(关系运算符)比较运算符又称为关系运算符，其作用是对各种表达式，容器结果进行大小、真假等比较。如果比较结果为真，则返回True(真)否则返回False(假)。 比较运算符 == 和 is区别 == 比较的是值 is 比较的所引用对象的地址 Python逻辑运算符及其用法逻辑运算符也是对真假（布尔类型）进行运算符，其返回值也为bool。 Python三目运算符(三元运算符)用法详解Python利用if来实现三目运算符的功能。 语法格式： 1True_statements if expression else False_statements 运算法则: 先对expression(表达式)求值，如果为True则执行True_statements否则执行False_statements 例子: 123a = 10b = 20print(&quot;a&gt;b&quot;) if a &gt; b else print(&quot;a&lt;b&quot;) 结果:1a&lt;b Python允许在三目运算符的False_statements或True_statements放置多条语句。 两种放置方式: 以英文逗号隔开，将每条语句执行结果，组成元组。 以英文分号隔开，只返回一条语句的结果。 例子: 1234a = 20b = 20print(&quot;a&gt;b&quot;) if a &gt; b else (print(&quot;a&lt;b&quot;) if a &lt; b else print(&quot;a=b&quot;)) 结果: 1a = b Python运算符优先级不同的运算符有一个优先级，在用于在表达式中进行区别执行顺序。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python-02]Python初探]]></title>
    <url>%2F2019%2F08%2F29%2FPython-02-Python%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[Python系列第二章笔记，查看Python系列所有文章，请点击💿 Mac安装Python环境由于我目前的设备只有一台Mac Book，所以我就只记录Mac安装Python的过程。 最新的Mac OS X以及集成了Python 2，打开终端(Terminal)输入:python检查是否已安装 安装Python3可以在这个页面进行下载:💿Python下载页面 python不是内部或外部命令的解决方法由于这个问题只有Windows才会出现，所以遇到问题的话，去看下原文吧💿点我看原文解决方案 第一个Python程序打开终端，输入python3命令，进入交互式解释器 1print(&quot;hello,world!&quot;) 即可输出包括在双引号之间的字符 注意点: 小括号与双引号必须在英文半角状态下输入 print必须全部为小写 文本编辑器编写并执行Python程序 可以使用Vim编辑器编写Python源代码，然后终端中执行 注意点: 不要使用Word或Windows的记事本程序编写Python源码，因为这两款软件会为源代码添加隐藏符号，而这些符号不被Python所解释，程序将会报错。 Python交互式解释器及用法交互式解释器是为了让开发者快速学习、则是Python的功能。 在终端内执行python命令即可打开 其中&gt;&gt;&gt;提示符，我们写的命令都是能被python解释器所执行的Python命令，如果输入的内容没有定义，那么解释器将会报错。 IDE(集成开发环境)是什么IDE(Intergreated Development Environment),用来辅助开发者开发的应用软件。 集成开发环境是一些列开发工具的组合套装，例如我们编写Python程序，不仅需要解释器，而且还需要一些辅助工具，例如:语言编辑器、自动构建工具、除错器。 Python IDE有哪些，哪款适合初学者？首先说明，合适自己的才是最好的。 PyCharm 由JetBrains公司开发的Python开发工具 优点: 跨平台 支持语法高粱、项目代码管理、智能提示、自动完成、调试、单元测试、版本控制等 支持Django Web开发框架 社区版本免费 缺点: 软件较大，比较重 专业版，收费 Microsoft Visual Studio 由微软开发用于进行C#和.NET等应用的开发工具，简称VS。 要让VS支持Python，需要安装PTVS插件。 优点: PTVS插件开源 支持编辑、浏览、智能感知、混合Python/C++调试、Django 缺点: 不跨平台，只支持Windows 软件较大，比较重 非学生收费 Python IDLE使用方法详解由于本人不使用IDLE作为我的Python开发工具，所以这里就不提了。 想了解的，看原文💿点击查看原文 Python注释(多行注释和单行注释)注释是写给人看的，是用来用自然语言解释代码给开发者看的。 注释不被解释器所执行。 Python允许在任何地方差人注释和字符串，除了在标志符和字符串之间。 Python中有三种注释分别是: 单行注释 语法格式1# 注释内容 单行注释所在位置可以是代码的上一行，可以是当前行的末尾。 Python多行注释 语法格式 123```注释内容``` 多行注释使用三个成对的单引号或三个成对的双引号作为多行注释块 通常用法: 为Python文件、模块、类或者函数等添加版权、功能描述等信息。 注意事项: 若多行注释作为语句的一部分(在语句中)将不会被认为是多行注释，而是Python字符串的标志。 Python中文编码声明注释 在Python2.x中，不支持在源码中直接写中文。所以如果需要加入中文，必须在行首加上以下注释: 1# coding=utf-8 Python3.x不需要 Python缩进规则(包含快捷键)Python采用代码缩进和冒号来区分代码块之间的层次 在Python中，类定义、函数定义、流程控制语句、异常处理语句等，行位的冒号代表代码块的开始，而同一个代码块内部代码的缩紧格式必须相同（不然Python不能知道当前代码块何时结束)，否则会出现SyntaxError Python编码规范这里所提到的规范都是PEP8所定义的。 需要严格遵守的代码编写规范: 每个import语句只导入一个模块 123456# 推荐import osimport sys# 避免import os sys 不在行尾添加分号，一行只放一条语句 12# 避免height = float(input(&quot;input height:&quot;)); weight=float(input(&quot;input weight&quot;)); 单行不超过80个字符，如果超过可以使用小括号将多行内容隐式的连接。 123# 推荐text=(&quot;aaaaaaaaaaaaaaaaaaaaaaaa&quot;&quot;bbbbbbbbb&quot;) 适当使用空行，增加代码可读性 适当使用空格分隔运算符之间，函数之间，以及逗号两侧。 💿PEP 8官方介绍 Python标识符命名规范Python标识符规范: 由字母、下划线、数字组成，但首字符不能为数字。 不能与Python内置的关键字相同，例如我们前面提到的import就是Python关键字。 Python中，标识符的命名区分字母大小写。 Python的标识符前后具有下划线代表由特殊意义。 推荐命名规范(不遵守此规范程序不会无法运行，但这基本是行业标准): 标识模块名时，尽量短小，由下划线分割标识符单词。 标识包名时，尽量短小，由英文句号作为分割。 标识类名时，单词首字母大写。 函数名、类属性，方法名，使用小写，多个单词之间使用下划线 编码规范的重要性编码的规范是为了提高开发效率。 我们编码时需要遵守准则: 阅读者 &gt; 编程者 &gt; 机器 Python关键字(保留字)Python关键字是Python内置的单词，其被赋予特殊的意义。 所有的关键字表如下: 关键字表 and as assert break class continue def del elif else except finally for from False globl if import in is lambda nonlocal not None or pass raise return try True while with yield Python内置函数Python具有内置函数，可由开发者直接调用。 有关内置函数的用法和解释可由访问[💿Python内置函数]进行查看.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python-01]Python教程基础]]></title>
    <url>%2F2019%2F08%2F29%2FPython-01-Python%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Python系列第一章笔记，查看Python系列所有文章,请点击 💿 编程语言是什么编程语言中的每个结构，都有固定的使用格式（称之为语法)以及精确的含义（称之为语义）。 编程语言也分等级，例如C、C++、Java、Ruby等可以称为高级语言，而计算机硬件只能理解一种非常低级的编程语言，机器语言。 解释型语言和编译型语言（两者区别） 编译型语言 编译型语言是指使用专门的编译器，对特定的操作系统（平台）将源代码一次性“翻译”为可被该操作系统（平台）硬件所执行的机器语言。 优点： 编译好后的可执行文件，可以在没有编译器的机器上独立运行。 程序执行速度快 缺点： 跨平台不友好(如果是不同的平台，需要将源代码在特定的平台重新编译，甚至需要修改代码) 解释型语言 解释型语言由解释器完成将源代码转换成机器语言，在任何平台上必须安装解释器才可以运行，而不同的平台只需要安装解释器，代码不需要修改也可以被解释。 优点： 跨平台友好 缺点： 执行速度慢 Python是什么，Python简介 Python历史 1989年，荷兰人Guido van Rossum 创造了Python. Python最初基于ABC教学语言. Python简介 Python可以和其他语言，如C、C++、Java的模块（方法/函数）轻松的结合在一起，因此Python又被称为“胶水”语言。 Python的设计哲学 优雅、明确、简单。 有些人说：“人生苦短，我用Python” Python的特点（优点和缺点） 简单易学 Python虽然语法格式要求严格，但是语法却很简洁。 开源 Python是开源的，使用Python编写的程序可以做商业用途也不用付费，并且可以让第三方开发者为Python开发提供优秀的功能。 高级语言 在使用Python编写程序时，开发者无需考虑底层细节问题，而专注于编写程序。 解释型语言 可移植性优秀 面向对象 Python既支持面向过程编程，也支持面向对象编程。 强大的功能 Python可以从简单的字符串处理到复杂的3D图形编程，这些借助Python的扩展模块可以轻松完成。 可扩展性 Python具有脚本语言中最丰富和强大的类库，不管是I/O、GUI、网络编程、数据库编程等绝大部应用场景，都可以使用Python内置的类库完成。 Python可以使用C或C++编写的代码，这样可以一定程度上的弥补执行速度慢的缺点。 缺点 速度慢，相比Java、C、C++编写的程序，运行效率都要慢。源代码加密困难，由于是解释型语言，不像编译型语言那样会被编译成各种目标程序，所以加密困难。 学Python，不需要有编程基础Python语法简明易懂，不像C++或C语言等语法复杂，并且在学习Python中也不需要太过于专注底层的细节，很多事情解释器都已经帮忙做好了。所以对于零基础的初学者来说，Python非常合适。 Python能干什么，Python的应用领域 Web应用开发 Python可以通过一些模块，使Python具备HTTP服务器与Python的Web程序之间的通信。 全球最大的搜索引擎Google，在其搜索系统中就大量的使用Python。 豆瓣也是由Python编写的。 操作系统管理、自动化运维开发 大部分操作系统中，Python都作为标准的系统组件，例如大多数Linux发行版，BSD系、Mac OS X都集成了Python。 并且相对于Shell脚本来说，无论是可读性、性能、代码重用度以及扩展性方面都要优秀很多。 游戏开发 虽说Python的运行效率不算快，但很多游戏可以用C++编写高性能模块，而用Pyton编写游戏的逻辑。 例如，文明这款游戏就是使用Python实现的。 编写服务器软件 由于Python对各种网络协议的支持完善，所以经常被用于编写服务器软件以及网络爬虫。 科学计算 Python内置了很多工具，可以让科研人员编写科学计算程序。 怎样学习Python，才能成为Python高手？ 编程语言都是相通的 如果你具备一定的编程基础，接触一门新的编程语言时会发现，不同的编程语言其实是相通的，大多数不同的地方在于语法规则。 Python对初学者友好 多实践、积累代码量 任何编程语言知识都是大量的，如果不在学习编程时就开始练习，那么可能当你学完素有的语法后，却把前面的知识忘得一干二净。 所以，学习编程，需要多写代码，没有途径可走。 时刻注意代码规范 在我们学习时，一定要养成良好的编程习惯，例如适当的编写注释，定义变量名称时不要随意使用无意义的字符。 开发经验必不可少 当你熟练的掌握一门编程语言的语法时，你还需要大中型产品的开发经验，它会让你学得更多，简而言之站得更高，看得更远。 Python 2.x和Python 3.x，初学者应该如何选择？推荐选择Python 3.x，因为Python将在2020不再更新Python 2.x，并且Python 3.x比Python 2.x 具有更多的特性与功能。 这里只是推荐，详细看Python3和Python2的区别可以看这本:📖《Python3和Python2的区别》 Python版本区别，Python3和Python2区别详解学习完基础再来…暂时未编写😅 不过可以知道的是，Python3相比与Python2在语句输出、编码、运算和异常等方面做出了调整。 Python2to3 自动将Python2.x代码转换成Python3.x代码学习完基础再来…暂时未编写😅 学完完基础再来…暂时未编写 Python PEP 及时追踪Python最新变化为了追踪Python的更新动态，我们需要借助Python PEP 文档 Python PEP文档 Python语法修改方案是由邮件列表的形式进行讨论，但Python的PEP文档发布了，新的变化才会生效。 PEP(Python Enhancement Proposal)，中译为Python改进方案。它主要由三个用途 通知: 汇总Python核心开发者重要信息 标准化: 提供代码风格，文档或者其他指导意见 设计: 对提交的新功能进行说明 如果想要查看提交的PEP历史，可以点击这里:PEP0文档 Python底层是用什么语言实现的大多数讨论的Python，所指的是CPython，它是用C语言编写的。 不仅有用C语言编写的Python也有用其他语法编写的Python。 不同语言实现Python的的原因，大部分是为了解决某些实际问题而创建的，例如： 在嵌入式系统中运行Python代码 在运行框架(Java/.NET)或其他语言做代码集成。 在Web浏览器中运行Python代码 以上所述使用CPython需要花费开发者大量精力也很难实现，所以才有了各种实现方式的Python. Stackless Python Stackless Python自称为Python增强版，它没有依赖C语言的调用栈。 其新添加的功能最重要的是:解释器管理的微线程 支持版本是2.7.9和3.3.5，Stackless Python的所有额外功能都是内置stackiess模块内的框架。 JPython 由Java实现的Python。它将代码编译为Java字节码，开发者可以在Pyton模块中无缝使用Java类 JPython与CPython的主要区别: 真正的Java垃圾回收机制 没有全局解释器锁(GlobalInterpreter Lock,GIL)，在多线程应用中可以充分利用多个内核 支持版本: 2.7 缺点: 缺少对C/Python扩展API的支持，预计JPython3.x支持C/Python扩展API IronPython IronPython将Python引入至.NET框架中。 支持版本: 2.7.5 缺点: 类似JPython 相比于CPython的优点: 没有全局解释器锁 用.NET语言家族编写的代码可以轻松集成到IronPython中，反之亦然。 通过Silverlight，在所有主流Web浏览器中都可运行。 PyPy 社区内呼声最高的Python实现，它是由Python重写的Python。 支持版本: 2.7完全兼容,PyPy3与3.25完全兼容 PyPy与CPython实现的主要区别: 使用垃圾回收 集成跟踪JIT编译器，可以提高性能 借鉴Stackless Python在应用层的无栈特性。 缺点: 对C/Python扩展API不完善，但为CPyExt子系统C扩展提供了某种程度的支持。 了解Jupyter Notebook，你已然超越了90%的Python程序员简单介绍下，Jupyter Notebook就是个整合了代码、计算输出、解释文档、多媒体资源的多功能科学运行平台。 去看原文吧，这个知道有这个东西，以后再去学习。 💿原文传送门]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下安装Rust]]></title>
    <url>%2F2019%2F08%2F20%2FMac%E4%B8%8B%E5%AE%89%E8%A3%85Rust%2F</url>
    <content type="text"><![CDATA[本篇文章记录了我是如何在Mac下安装rust的过程. 首先在你Shell的配置文件内加入下面两行: 12export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-staticexport RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup 然后打开终端，输入: 1curl https://sh.rustup.rs -sSf | sh 中间稍微等待一下，选择安装的方式即可。 安装好后记得执行: 1source $HOME/.cargo/env 最后再编辑$HOME/.cargo/config文件 1234567[registry]index = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;[source.crates-io]registry = &quot;https://github.com/rust-lang/crates.io-index&quot;replace-with = &apos;ustc&apos;[source.ustc]registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot; 就大功告成啦，赶快写一个HelloWorld吧!]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下超好用的风扇控制与温度监控软件————TG Pro]]></title>
    <url>%2F2019%2F08%2F20%2FMac%E4%B8%8B%E8%B6%85%E5%A5%BD%E7%94%A8%E7%9A%84%E9%A3%8E%E6%89%87%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B8%A9%E5%BA%A6%E7%9B%91%E6%8E%A7%E8%BD%AF%E4%BB%B6%E2%80%94%E2%80%94%E2%80%94%E2%80%94TG-Pro%2F</url>
    <content type="text"><![CDATA[鸽了好久的一篇文章，今天把它补上。 TG Pro是一款Mac下用于检测温度以及控制风扇转速的优秀软件 我们先来看看软件本体是怎样的: 是不是感觉硬件的所有信息都简单明了的展示出来了？ 我们还可以对软件进行一些设置。]]></content>
      <categories>
        <category>软件分享</category>
      </categories>
      <tags>
        <tag>软件分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用两天MacBookPro真实感受]]></title>
    <url>%2F2019%2F08%2F17%2F%E4%BD%BF%E7%94%A8%E4%B8%A4%E5%A4%A9MacBookPro%E7%9C%9F%E5%AE%9E%E6%84%9F%E5%8F%97%2F</url>
    <content type="text"><![CDATA[经过漫长的等待，我的MacBook Pro终于是到货了，经过我的两天调教，我已经逐渐习惯了。 &emsp;前天一大早，我接到了电话，不用想，肯定就是我得mbp到货了。可能是我看过太多测评视频的缘故，当我亲手开箱时，却没有被mbp给惊艳到，不过机身确实非常薄，应该是我接触过的电脑最薄的台15寸笔记本了。mbp支持单手开合，这一点我非常满意，草草的设置完第一次启动系统后，我迫不及待的安装我所需的软件，由于早前我看过一些关于Mac OS X的文章，我马上就去配置了Homebrew，但我发现，貌似配置国内源有点困难，没有我在Manjaro下那么方便，快捷。 &emsp;经过我的一番折腾，Homebrew总算是安装好了，我便开始配置开发环境，首先选择了传说中功能非常强大的iterm2，功能强大到我不能快速上手，必须花费时间去研究研究它才能顺手使用。在我折腾Mac时，十分讨厌这个键盘布局，现在亦是如此，把fn键放在键盘的边缘处，我每次想要按control时总是误触，以及touchbar的escape键，简直按起来一点反馈没有，所以我就通过karabiner这款软件修改了个我习惯的键位布局。 &emsp;不得不说mbp的这个屏幕，简直是太棒了，我原先用的是dell的4k屏幕，但在我用mbp时，甚至会觉得比4k屏好，可能是色彩非常准确的缘故吧。可能因为屏幕素质太过于优秀的缘故，耗电并不如网上说的那样，从早到晚不用充电，经过实测，这款标配的mbp 2019款在chrome十几个网页+Emacs+NeoVim+微信+腾讯QQ+Telegram+蓝牙耳机+Wifi开启+网易云+屏幕亮度80%+键盘背光最亮的情况下，3个半小时耗电50%，你可能觉得我在吹它～，但它确实就是这么厉害。 &emsp;超大的触摸板，简直太好用，配合上Mac OS X的触摸板手势，对窗口的管理完全掌握在你的手指间。再说说机器发热的情况，在我上面所提到的使用环境下，几乎感觉不到mbp在发热，但是在打开一些大型应用，例如ps,pr,ae这些软件时，Mac OSX就像是提高了机器性能一般，风扇开启了高转速，机器也随之发热了，但得得益于mbp的外壳，可以在边缘垫上一元硬币辅助散热，并且效果还不错，虽说在开启大型应用mbp会发热严重，但也只是部分区域会感受到热，在手腕，手拖处几乎感觉不到，打字时由于蝶式键盘的缘故，只要是每个手指精确的放在键帽上，只能感觉到微微发热，但是在键帽之间的缝中可以明显感受到烫手。 &emsp;最后吹一下mbp，它确实时非常好用，就是价格稍高，对于普通家庭来说，进两万元的支出也不是一个小数目了，希望有生之年能看到Apple能做物美价廉，感动人心的好产品(笑]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Happiness from the heart]]></title>
    <url>%2F2019%2F08%2F11%2FHappiness-from-the-heart%2F</url>
    <content type="text"><![CDATA[15分钟前，我观看了一集TED演讲，我从中了解了什么才是真正的快乐。这篇文章就讲述了我的感悟与亲身体验。 Fifteen minutes ago, I watched a TED talk, from which I learned what real happiness is. This article and related my feeling and experience of happiness from the heart. EnglishNext, I will ask a few questions, which are very simple, because you must have the answer in your heart. So the first question is: Are you happy today? I think you already have the answer, then the next question is: why are you happy or unhappy today? The point is why you are happy, or why you are not happy. For example, you may not be happy today because you are arranged to work with colleagues you don’t like. Of course, I think you should have no colleagues you don’t like. In this example, the reason why you are unhappy &gt; is to work with colleagues you don’t like, but what I want to say is: you must stop being unhappy because of colleagues or because of something or some external factors. This is what I want to say. You may understand this: don’t be unhappy because of external factors. But in fact, what I want to express is: happiness or happiness is from the heart, not &gt; from external factors. even if you work with your favorite colleagues, it cannot be the reason why you are happy today. real happiness is from the heart. Chinese下面，我将会问几个问题，这几个问题十分简单，因为你们心中肯定有答案。那么第一个问题是：你今天开心吗？我想你应该已经有了答案，那么接下来是第二个问题：你今天为什么开心或者为什么不开心？重点在于为什么开心，或者为什么不开心。举个例子，你今天可能会因为被领导安排与不喜欢的同事共事，你不开心。当然，我觉得你应该没有不喜欢的同事。这个例子中，你不开心的原因就是与不喜欢的同事共事，但我想说的是：你必须停止因为同事或者说是因为某个事物又或是某些外部因素让你不开心。这也就是我想说的。你可能会理解成：不要因为外部因素，从而使得不开心。但其实我想表达的是：快乐或开心是由自内心的，而不是由自外部因素的，就算是你跟喜欢的同事共事，那么也不能成为你今天快乐的原由，真正的快乐是发自内心。]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The process of purchasing MacBook Pro]]></title>
    <url>%2F2019%2F08%2F02%2FThe-process-of-purchasing-MacBook-Pro%2F</url>
    <content type="text"><![CDATA[这篇文章记录我买MBP的过程. &emsp;Because I need to use PS and lightweight PR and have the need to prgramming,and the current AlienWareR13 can no longer met my needs.After one day and on night’s selection,I finally chose MacBookPro 15.6 with difficulty. &emsp;The configuration diagram is as follows. &emsp;First of all, 16GB is enogh for me to run a few more virtual machines, and it is also fast in drawing and editing. Although many people on the Internet said that heat dissipation is not good.I found that 2018 version of heat dissipation is not very good when I readlly got to know it. Considering the problem of heat dissipation, I also bought i9 version instead of i9 version. I hope erverthing goes well! &emsp;The fllowing is the spitting. When I was preparing to place an order, I was looking for the student discount page for half a day. When I found it, I wanted to know what the student discount conditions were. As a result, I didn’t see the relevant instructions until I went to Baidu to know that I needed the student certificate from full-time universities. &emsp;When I learned some rough information from the internet, I placed the order. when placing the order, I had to pay first to verify whether the student id card was qualified. this is really disgusting … as for why, I will mention later. After I placed the order, I just waited for Apple to send me an email so that I could know what the student discount request was. In the middle of the night, I received a text message from Apple, which said: Let me check the email, and the information about the student discount conditions is in it. The second disgusting thing that happened to me at this moment was that I didn’t receive e-mail! However, I did not have the option to apply for resending the mail, which made me very angry and the shopping experience was very poor. Since the customer service is off duty, I can only ask the next morning. The customer service personnel helped me successfully send the student id card, and then I waited for the verification to pass. What made me feel sick for the third time has happened again! My order was cancelled because my credentials were invalid. However, Apple did not send a single email. Only when I checked the order status could I find that it had been cancelled. I went to ask the customer service again, and the information the customer service gave me was: the name of the student id card and the name of the consignee did not match, so it was cancelled. I feel very speechless … can’t parents give their children computers? ! The consignee must also match the student ID. Now I sit and wait for the refund. However, the refund time makes me despair even more. It takes me 5 working days at the latest, and I bought it on Friday. Apple employees will have a holiday at the weekend, so I can’t handle it yet. That is to say, I have to wait for a whole week at the latest to receive the refund! I think it takes so much time to place a new order! It just makes me feel that the shopping experience is terrible! &emsp;I’m just waiting for a refund and then placing another order. I don’t even want to buy Mac Book Pro now. It’s so annoying! &emsp;由于我需要使用PS和轻量级的PR并且还有写代码的需求，并且现役的这台AlienWareR13已经不能够满足我的需求了。经过一天一夜的挑选，最终艰难的选择了Mac Book Pro 15.6。 &emsp;这是我的配置图. &emsp;首先，16GB对于我来说是足够的，可以用来跑多几个虚拟机，而且制图时和剪辑时速度也快，虽然网上很多人说散热不行，但当我真实去了解后才发现是2018版的散热不太行，而且考虑到散热的问题，我也没有买i9版本，而是买了9代 i7，希望一切顺利吧！ &emsp;下面就是吐槽了。在我准备下单时，我一直在找学生优惠的页面，找了半天，当我找到后，我想了解一下学生优惠的条件是什么，结果我应是没有看到相关的说明，直到我去百度才知道需要全日制高校的学生证明。 &emsp;当我从网络上了解到了一些粗略的信息后，我便下单了，下单时是先付款才能验证学生证是否合格，这一点真的恶心…至于为什么，我后面会提到。我下单后就是等待Apple给我发送邮件，这样我才能知道学生优惠的要求是什么，在半夜时，我收到了Apple的短信，短信内容是:让我检查电子邮件，有关学生优惠的条件信息在里面。这时就让我遇到第二件很恶心的事，就是我并没有收到电子邮件！但是并没有申请重新发送邮件的选项，这就让我很生气了，购物体验极差。由于客服已下班，我只能第二天早晨去询问了。客服人员帮助我成功的发送了学生证的凭证，然后我就等待验证通过。让我感到第三次恶心的事又发生了！我的订单被取消了，因为我的凭证无效，然而Apple连一个邮件也不发，只有我去查看订单状态才能发现已经被取消。我又去询问客服，客服给我的信息是：由于学生证的姓名和收货人的姓名不符合，所以被取消了。我感到十分无语…难道父母送给孩子电脑都不可以吗？！还必须要收货人跟学生证相符。现在我就坐等退款了，然而退款的时间更让我绝望，最晚需要5个工作日，而且我是周五买的，周末时Apple的员工要放假，所以还不能处理，也就是说我最晚需要等待整整一周的时间，才能收到退款！我想重新下单就需要浪费这么多的时间！简直是让我感到，购物体验极差！ &emsp;吐槽完了，我现在就是等待退款，然后重新下单，我甚至在都不想买Mac Book Pro了，太让人生气了！]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>购物体验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust-理解所有权]]></title>
    <url>%2F2019%2F07%2F30%2FRust-%E7%90%86%E8%A7%A3%E6%89%80%E6%9C%89%E6%9D%83%2F</url>
    <content type="text"><![CDATA[根据Rust中文学习了些Rust的知识，所以记录下Rust中很重要的特性之一:所有权 认识所有权所有权是Rust最独特的功能，使得Rust不需要GC即可保证内存安全. 本篇文章介绍所有权及其相关功能：借用、slice，以及Rust如何在内存中布局数据 什么是所有权所有权（ownership)是Rust的核心特性之一，其最大的特点是解决了目前大部分编程语言对内存管理方式的缺陷，例如:一些语言通过GC(垃圾回收机制)进行管理内存，在程序运行时不断的寻找无用的内存，但这种方式会使得程序的效率降低。另一种方式则是内存的分配和释放由程序员进行管理，所以经常会出现遗漏或设计缺陷，从而使得程序问题不断。而Rust的所有权特性则恰好解决了以上两个常见的问题。 在理解所有权之前，让我们先了解一个常用的数据结构:Stack Heap. 栈(Stack) 与 堆(Heap) 程序是由算法和数据组成的，栈堆这种数据结构则是一种处理数据的算法，而在所有权的概念中，数据是存在栈上还是堆上很大的影响了程序的行为。 栈的结构是一种后进先出的方式处理数据的，生活中的羽毛球例子可以清晰的描述这一关系:当我们将羽毛球放入羽毛球桶时，想要拿走时，总是拿走的最后一个放入的羽毛球，我们不能拿走最后一个放入之前的羽毛球。我们把放入羽毛球(增加数据)叫做入栈，拿出羽毛球(移出数据)叫做出栈。 ‘栈’的优点是，速度快。这主要是因为如果要获取数据则总是从栈顶直接获取，而不需要寻找某个特定的位置需要读取数据。第二个原因是:栈中数据所占内存大小都已固定也可知。 堆的结构是一种随机的方式处理数据的，生活中的例子每天吃饭可以清晰的描述这一关系:一日三餐，我们总是会想要吃什么，世界上有那么多美食，此时我们就需要选择想要的菜品才能进食，并且在要选择菜品时，我们还必须考虑是否有足够的金钱付款，而在我们选择菜品时是根据菜名通过服务员才能让厨房处理，最终上菜。我们把为菜品付款称作在堆上分配内存，而菜名称作指针，我们需要通过通过指针访问在堆上分配的内存. 堆的优点是，不受限于只能获取最后一个存入的数据，因为数据都是成堆摆布的，如果需要访问需要通过指针。 堆对数据的操作速度没有栈快，因为堆需要通过指针才能访问数据. 若数据大部分存在堆上，则有可能出现一些重复数据，为了清除这些无用的数据，确保内存空间不会被耗尽。这些问题正是所有权系统需要处理的。想必读者们也应该知道，所有权的存在就是为了管理堆数据的，当你理解了所有权后，将在编码时不用总考虑栈和堆了。 所有权规则 Rust中，每一个值都有一个称为__所有者(owner)的变量。 值只能有一个所有者。 当所有者离开作用域，这个值则会被遗弃。 变量作用域让我们看第一个关于所有权的例子 123456// 在这里使用s无效，s尚未生命&#123; let s = &quot;hello&quot;; // 从此处起，s 有效&#125;// 在这里使用s无效，因为作用域已结束 这个例子中，当s进入作用域后，直到它离开作用域为止，它一直是有效的。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emacs is sexy!]]></title>
    <url>%2F2019%2F07%2F26%2FEmacs-is-sexy%2F</url>
    <content type="text"><![CDATA[Emacs is a highly extensible text editor.It is built on a C core, and provides a fully featured Lisp environment There’s a reason why Emacs was featured in Tron Legacy - because it’s sexy! You can use Emacs for all of your text processing needs, internet and social network interations, hacking, coding, maaging to-do’s and organizing your daily schedule, playing Tetris, and manay other awesome things. It can even provide you with free psychotherapy and counseling using the built in doctor. A vibrant community of hackers is constantly writing new extensions, thanks to the power of the Emacs Lisp environment. GNU Emacs is Free Software, both free as in free beer and free as in free speech. The original Emacs was written by St. iGNUcius himself —- Richard Stallman. Not only does it give the user the four essential freedoms, its architecture is built in such a way that you have the power to mold it, change it and make it comply to your computering needs. Why use Emacs?Emacs is a very pwoerful text processor, giving you the power to manipulate documents quickly and efficiently. You can easily move through and edit paragraphs, sentences, words, and logical blocks; blaze through text using powerful search tools; and easily edit thousands of lines at once using regular expressions, keyboard macros and more. Colorful text editorEmacs can be cutomized in every conceivable way, including its looks. You can strip it down, choose between dozens of easy to intall themes with M-x load-theme, or even create your own and share it with your friends. Here are a couple of nice theme galleries: Emacs Themes, Emacs Theme Gallery. Et tu, Programmer?There are tools for every programming languaage out there. Lisp, Ruby, Python, PHP, Java, Erlang, JavaScript, C, C++, Prolog, Tcl, AWK, PostScript, Clojure, Scala, Perl, Haskell, Elixir all of there languages and more are supported in Emacs. Beacuse of the powerfull Lisp core. Emacs is easy to extend to add support, debugging, code browsing, version control integration and much more. Vim user?Let tell about Spacemacs! Spacemacs is a community-driven Emacs distribution that brings together the world of Vim and Emacs into one text eeditor. It also features ergonomics and mnemonickey binding design, and also works great as a starter pack for newcomers. More!Org mode helps you to keep notes, maintain TODO lists, plan projects and author documents. You can use your Org documents to create HTML websites like this one or export to LaTeX, Beamer, OpenDocuments and many other formats. Tramp allows you to edit remote files without leaving Emacs. You can seamlessly edit files on remote servers via SSH for FTP.edit local files with su/sudo , and much more. M-x butterfly unleashes the powers of the butterfly. Use the built in IRC client ERC along with BitlBee to connect to your favorite chat services, or use the Jabber package to hop on any XMPP service. Out of the box Emacs includes a mail client, web browser, calendar, and games; you can even edit video and images inside Emacs. There are more than 3,000 packages for Emacs, and more are written all the time. You can easilly extend your Emacs with new packages from GNU ELPA, MELPA and Marmelade repositories.]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FuShou-Mountain-Day-Trip]]></title>
    <url>%2F2019%2F07%2F23%2FFuShou-Mountain-Day-Trip%2F</url>
    <content type="text"><![CDATA[Today I gone to the FuShou mountain,So this article is about it. &emsp;It’s sunny,But I arrived到达 at my destination目的地 at noon正午.There were manay people.After a long queue排队,I finally got the ticket门票.Then I got on the interval bus区间车 again. &emsp;It was a bumpy journey to the foot一路颠簸 of Fushou Mountain.The first thing I saw was a snack area小食区 supported by a pile支撑 of read tents帐篷.Then when I entered the snack area,the air was filled with grabbing food手抓饭,thin-skinned steamed buns薄皮包子,the aroma香气 of barbecue kebabs烤肉串 and the sweet香甜的 Cavas卡瓦斯,Ice cream attracted吸引 me.I couldn’t resist无法抵御 the temptation美食 of delicious food, so I ate a lot of delicious food in Xinjiang. &emsp;After full stomach饱腹,I began to climb the mountain. The sun was very sunny. Before I reached the glass trestle玻璃栈道,my skin was red. &emsp;Glass planks up to 300M,built of steel and glass.People have a head and look through the glass to see the ground.Although I dare not look down from the highrise, I can’t fell scared on the glass path. Maybe I trust safety of these projects. &emsp;Happy time is always short,and soon,we will go home by car…]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My-Monitor]]></title>
    <url>%2F2019%2F07%2F20%2FMy-Monitor%2F</url>
    <content type="text"><![CDATA[I had been trying to write an article about the monitor a few days ago, and tooday i finally realized. &emsp;I met the monitor in 2015,When we were both junior three students.,Because I dropped out of junior high school, I had little contact with her in the previous few years.Probably since I went to college.I have occasional contact with the monitor who was about to face the college entrance examination talked to me a lot about my school and her views. I also expressed my point of view, and we exchanged our thoughts about life. &emsp;More and more, I feel that the monitor is more and more interesting. Many of her views are similar to mine.We sometimes talk for a long time and forget the time.But our relationship is still a friend. &emsp;Towards the end of my freshman year,my relationship with the monitor changed dramatically,Which is why I wrote an article about the monitor.On a very normal day,the monitory suddenly came to me and said that she wanted to come to my university,because my university is a higher ranking university in Guangdong.Kind of me,carefully answered some questions for her, and said that I really want to talk with the monitor of a university,I talk with the monitor more and more.We talk a lot to each other,whether it’s about life,learning or even the future. &emsp;Gradually,I fell in love with the monitor.From the first time I sent a photo to her,to the first time I sent a video to her,I knew that I had fallen in love with her. &emsp;I like the monitor’s voice,her attitude when talking,her eyes,some of her little jokes,some of her small shortcomins,like all of her.Now that I have identified everything. I will say to her personally when I return to Guangzhou,”I love you,my monitor.”]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Serimu Lake Day Trip]]></title>
    <url>%2F2019%2F07%2F20%2FSerimu-Lake-Day-Trip%2F</url>
    <content type="text"><![CDATA[几天前，我去了新疆的赛里木湖，所以便有了这篇文章。 A few days ago,I went to Serimu Lake in Xinjiang,So I had this article. English&emsp; Early, I was woken up by a phone call,not the monitor’s phone(monitor will not get up so early),I was confused to pick up the phone to answer,the phone came from my father’s voice.After the phone call,I immediately get out of bed and wash.Let me get up at 7 a.m in the summer vaction, in addition to the monitor’s phone,that may be what let me attention the new. &emsp;In a hurry,I arrived at Grandma’s house.I asked my father,”What are you going to do today? Why so early? My father answered,”Today your uncle is going to take you to Serimu Lake to play,so let you come and your uncle will pick us up later.”After my father said that.I was so happy that when i returned to XinJiang.I hardly ever went out to play.Every day I went out to eat meat. 中文&emsp;早早的，我被一通电话闹醒，不是班长的电话，班长不会那么早起，我迷迷糊糊地拿起手机接听，电话那头传来我爸的声音。通完电话，我立刻下床，洗漱，能让我暑假早晨7点就起床的，除了班长的电话，那可能就是什么好消息了吧。 &emsp;匆匆忙忙地，我到了奶奶家。我问爸:”今天要去干什么啊,怎么那么早？”,我爸回答:”今天你大伯要带你去赛里木湖玩，所以让你来，等下你大伯就来接我们。”，我爸说完，我心里开心得不行，回到新疆，就没怎么出去玩过，每天都是出去吃肉.. &emsp;不知过了多久，我大伯终于来了，我们便开启了我们的旅程。我们一路人从伊宁市64团出发，要行驶将近70km才能到达赛里木湖。途中我看到很多曾经只能在]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Do you know Linux?]]></title>
    <url>%2F2019%2F07%2F17%2FDo-you-know-Linux%2F</url>
    <content type="text"><![CDATA[I have been using Linux for about a year and a half.This article let’s talk about Linux. &emsp;Linux is an operating system kernel,In addition to some experts,most Linux users are uing Linux dirtributions.The Linux dirtributions is preintegrated with the Linux operating system and various application software for users. &emsp;The Linux kernel was first released by Linus Trovars on October 5,1999.Although the Linux kernel is develpoed,it does not have the tools included in an operating system,but there is a GNU tool that can be used as a system tool for Linux,so Linux is also called GNU/Linux.Currently,Linux can be used on large computers,supercomputers,mobile phones,tables,routers,televisions,game consoleds and computers,Such as,the Android operating system is based on the Linux kernel. &emsp;You maybe ask,can Linux be used as an operating system for everyday use? I will answer you with certainty,Linux Can do it.This article was broin in Arch Linux,I can do entertainment and work on Linux. &emsp;I love Linux,forever.]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[What is Vim?]]></title>
    <url>%2F2019%2F07%2F14%2FWhat-is-Vim%2F</url>
    <content type="text"><![CDATA[The editor I use every day is VIM.This article introduces the hirstory of the VIM. &emsp;Bram Miller purchased hisr Amiga computer in the late 1980s,At this time,there is no editor vi on his computer. So he started with an open source vi repilica version of Stevie，developed version 1.0 of Vim.The initial goal was to completely copy the function of vi. &emsp;After that,Vim has added countless new features. As the first milestone.version 3.0 of 1944 joined the split window mode,It can edit multiple files simultanesouly in the same terminal. &emsp;At 1996 released Vim 4.0 in 1996 using the version of the GUI.1998 Vim 5.0 version added syntax highlighting.2001 Vim 6.0 version added Code floding,Plugin,Multi-anguage support ,Vertical segmentation window etc.The Vim 7.0 release was released in May 2006 added Spell check,Context-sensitice completion,Tab editing etc. &emsp;The latest version of Vim is now Vim8]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平铺式桌面-从入门到入坟]]></title>
    <url>%2F2019%2F07%2F12%2F%E5%B9%B3%E9%93%BA%E5%BC%8F%E6%A1%8C%E9%9D%A2-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F%2F</url>
    <content type="text"><![CDATA[本文章详细地介绍了我目前的桌面.通过此文章，你可以做到让i3成为你的一把利刃。 暂时未完成首先上图，我的i3桌面. 0x0 i3一、安装i3安装i3很简单，我们直接输入下面这条命令即可 1&gt; sudo pacman -S i3 compton polybar 此时你可能会看到i3-gaps和i3-wm，选择哪个都可以，推荐i3-gpas，但如果你想拥有一个没有配置过的i3，那么你就直接安装i3-wm即可 二、配置i3配置i3通过编辑~/.config/i3/config这个文件进行配置。 我这里已经有配置好的i3，你们可以直接使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195# i3 config file (v4)## Please see https://i3wm.org/docs/userguide.html for a complete reference!## This config file uses keycodes (bindsym) and was written for the QWERTY# layout.## To get a config file with the same key positions, but for your current# layout, use the i3-config-wizard## Font for window titles. Will also be used by the bar unless a different font# is used in the bar &#123;&#125; block below.font pango:monospace 8# This font is widely installed, provides lots of unicode glyphs, right-to-left# text rendering and scalability on retina/hidpi displays (thanks to pango).#font pango:DejaVu Sans Mono 8# Before i3 v4.8, we used to recommend this one as the default:# font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1# The font above is very space-efficient, that is, it looks good, sharp and# clear in small sizes. However, its unicode glyph coverage is limited, the old# X core fonts rendering does not support right-to-left and this being a bitmap# font, it doesn&apos;t scale on retina/hidpi displays.# use these keys for focus, movement, and resize directions when reaching for# the arrows is not convenientset $up lset $down kset $left jset $right semicolon# use Mouse+Mod1 to drag floating windows to their wanted positionfloating_modifier Mod1# start a terminalbindsym Mod1+Return exec i3-sensible-terminal# kill focused windowbindsym Mod1+Shift+q kill# start dmenu (a program launcher)bindsym Mod1+d exec dmenu_run# There also is the (new) i3-dmenu-desktop which only displays applications# shipping a .desktop file. It is a wrapper around dmenu, so you need that# installed.# bindsym Mod1+d exec --no-startup-id i3-dmenu-desktop# change focusbindsym Mod1+$left focus leftbindsym Mod1+$down focus downbindsym Mod1+$up focus upbindsym Mod1+$right focus right# alternatively, you can use the cursor keys:bindsym Mod1+Left focus leftbindsym Mod1+Down focus downbindsym Mod1+Up focus upbindsym Mod1+Right focus right# move focused windowbindsym Mod1+Shift+$left move leftbindsym Mod1+Shift+$down move downbindsym Mod1+Shift+$up move upbindsym Mod1+Shift+$right move right# alternatively, you can use the cursor keys:bindsym Mod1+Shift+Left move leftbindsym Mod1+Shift+Down move downbindsym Mod1+Shift+Up move upbindsym Mod1+Shift+Right move right# split in horizontal orientationbindsym Mod1+h split h# split in vertical orientationbindsym Mod1+v split v# enter fullscreen mode for the focused containerbindsym Mod1+f fullscreen toggle# change container layout (stacked, tabbed, toggle split)bindsym Mod1+s layout stackingbindsym Mod1+w layout tabbedbindsym Mod1+e layout toggle split# toggle tiling / floatingbindsym Mod1+Shift+space floating toggle# change focus between tiling / floating windowsbindsym Mod1+space focus mode_toggle# focus the parent containerbindsym Mod1+a focus parent# focus the child container#bindsym Mod1+d focus child# move the currently focused window to the scratchpadbindsym Mod1+Shift+minus move scratchpad# Show the next scratchpad window or hide the focused scratchpad window.# If there are multiple scratchpad windows, this command cycles through them.bindsym Mod1+minus scratchpad show# Define names for default workspaces for which we configure key bindings later on.# We use variables to avoid repeating the names in multiple places.set $ws1 &quot;1&quot;set $ws2 &quot;2&quot;set $ws3 &quot;3&quot;set $ws4 &quot;4&quot;set $ws5 &quot;5&quot;set $ws6 &quot;6&quot;set $ws7 &quot;7&quot;set $ws8 &quot;8&quot;set $ws9 &quot;9&quot;set $ws10 &quot;10&quot;# switch to workspacebindsym Mod1+1 workspace $ws1bindsym Mod1+2 workspace $ws2bindsym Mod1+3 workspace $ws3bindsym Mod1+4 workspace $ws4bindsym Mod1+5 workspace $ws5bindsym Mod1+6 workspace $ws6bindsym Mod1+7 workspace $ws7bindsym Mod1+8 workspace $ws8bindsym Mod1+9 workspace $ws9bindsym Mod1+0 workspace $ws10# move focused container to workspacebindsym Mod1+Shift+1 move container to workspace $ws1bindsym Mod1+Shift+2 move container to workspace $ws2bindsym Mod1+Shift+3 move container to workspace $ws3bindsym Mod1+Shift+4 move container to workspace $ws4bindsym Mod1+Shift+5 move container to workspace $ws5bindsym Mod1+Shift+6 move container to workspace $ws6bindsym Mod1+Shift+7 move container to workspace $ws7bindsym Mod1+Shift+8 move container to workspace $ws8bindsym Mod1+Shift+9 move container to workspace $ws9bindsym Mod1+Shift+0 move container to workspace $ws10# reload the configuration filebindsym Mod1+Shift+c reload# restart i3 inplace (preserves your layout/session, can be used to upgrade i3)bindsym Mod1+Shift+r restart# exit i3 (logs you out of your X session)bindsym Mod1+Shift+e exec &quot;i3-nagbar -t warning -m &apos;You pressed the exit shortcut. Do you really want to exit i3? This will end your X session.&apos; -B &apos;Yes, exit i3&apos; &apos;i3-msg exit&apos;&quot;# resize window (you can also use the mouse for that)mode &quot;resize&quot; &#123; # These bindings trigger as soon as you enter the resize mode # Pressing left will shrink the window’s width. # Pressing right will grow the window’s width. # Pressing up will shrink the window’s height. # Pressing down will grow the window’s height. bindsym $left resize shrink width 10 px or 10 ppt bindsym $down resize grow height 10 px or 10 ppt bindsym $up resize shrink height 10 px or 10 ppt bindsym $right resize grow width 10 px or 10 ppt # same bindings, but for the arrow keys bindsym Left resize shrink width 10 px or 10 ppt bindsym Down resize grow height 10 px or 10 ppt bindsym Up resize shrink height 10 px or 10 ppt bindsym Right resize grow width 10 px or 10 ppt # back to normal: Enter or Escape or Mod1+r bindsym Return mode &quot;default&quot; bindsym Escape mode &quot;default&quot; bindsym Mod1+r mode &quot;default&quot;&#125;bindsym Mod1+r mode &quot;resize&quot;# Start i3bar to display a workspace bar (plus the system information i3status# finds out, if available)bar &#123; status_command i3status&#125;######################################################################## automatically start i3-config-wizard to offer the user to create a# keysym-based config which used their favorite modifier (alt or windows)## i3-config-wizard will not launch if there already is a config file# in ~/.i3/config.## Please remove the following exec line:#######################################################################exec i3-config-wizard 将上面的内容粘贴到i3的配置文件内即可 四、美化i3-polybarpolybar是一个快速并且易用的状态显示栏 就如同你们看到的桌面预览图一般，上面的状态栏就是通过polybar实现的 我的polybar已经配置完成了，可以方便的显示工作区的数字，以及窗口的标题，以及CPU,RAM,CPU温度,时间,系统托盘等功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353;==========================================================;;; ██████╗ ██████╗ ██╗ ██╗ ██╗██████╗ █████╗ ██████╗; ██╔══██╗██╔═══██╗██║ ╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗; ██████╔╝██║ ██║██║ ╚████╔╝ ██████╔╝███████║██████╔╝; ██╔═══╝ ██║ ██║██║ ╚██╔╝ ██╔══██╗██╔══██║██╔══██╗; ██║ ╚██████╔╝███████╗██║ ██████╔╝██║ ██║██║ ██║; ╚═╝ ╚═════╝ ╚══════╝╚═╝ ╚═════╝ ╚═╝ ╚═╝╚═╝ ╚═╝;;; To learn more about how to configure Polybar; go to https://github.com/polybar/polybar;; The README contains a lot of information;;==========================================================[colors]background = #cc222222background-alt = #444;foreground = $&#123;xrdb:color7:#222&#125;foreground = #dfdfdfforeground-alt = #555primary = #ffb52asecondary = #e60053alert = #bd2c40[bar/example];monitor = $&#123;env:MONITOR:HDMI1&#125;monitor = $&#123;env:MONITOR:eDP1&#125;width = 100%height = 30;offset-x = 1%;offset-y = 1%radius = 6.0fixed-center = truebackground = $&#123;colors.background&#125;foreground = $&#123;colors.foreground&#125;line-size = 3line-color = #f00border-top-size = 0border-left-size = 0border-right-size = 0border-color = #00000000padding-left = 0padding-right = 2module-margin-left = 1module-margin-right = 2font-0 = ttf-liberation-sans:fixed:pixelsize=12;1font-1 = source han sans cn:pixelsize=12:antialias=false;1font-2 = &quot;Font Awesome 5 Free:style=Solid:pixelsize=12;1&quot;font-3 = &quot;Font Awesome 5 Brands:style=Regular:pixelsize=12;1&quot;font-4 = &quot;material icons:pixelsize=16;3&quot;modules-left = i3modules-center = xwindow;modules-center = modules-right = cpu memory temperature battery date tray-position = righttray-padding = 2tray-background = $&#123;colors.background&#125;cursor-click = pointercursor-scroll = ns-resize[module/xwindow]type = internal/xwindowlabel = %title%width = 50label-maxlen = 45[module/xkeyboard]type = internal/xkeyboardblacklist-0 = num lockformat-prefix = &quot;&quot;format-prefix-foreground = $&#123;colors.foreground-alt&#125;format-prefix-underline = $&#123;colors.secondary&#125;label-layout = %layout%label-layout-underline = $&#123;colors.secondary&#125;label-indicator-padding = 2label-indicator-margin = 1label-indicator-background = $&#123;colors.secondary&#125;label-indicator-underline = $&#123;colors.secondary&#125;[module/filesystem]type = internal/fsinterval = 25mount-0 = /label-mounted = %&#123;F#0a81f5&#125;%mountpoint%%&#123;F-&#125;: %percentage_used%%label-unmounted = %mountpoint% not mountedlabel-unmounted-foreground = $&#123;colors.foreground-alt&#125;[module/bspwm]type = internal/bspwmlabel-focused = %index%label-focused-background = $&#123;colors.background-alt&#125;label-focused-underline= $&#123;colors.primary&#125;label-focused-padding = 2label-occupied = %index%label-occupied-padding = 2label-urgent = %index%!label-urgent-background = $&#123;colors.alert&#125;label-urgent-padding = 2label-empty = %index%label-empty-foreground = $&#123;colors.foreground-alt&#125;label-empty-padding = 2[module/i3]type = internal/i3format = &lt;label-state&gt; &lt;label-mode&gt;index-sort = truewrapping-scroll = falselabel-focused = %name%label-unfocused = %name%label-visible = %name%label-urgent = %name%label-mode-padding = 2label-mode-foreground = #000label-mode-background = $&#123;colors.primary&#125;label-focused-background = $&#123;module/bspwm.label-focused-background&#125;label-focused-underline = $&#123;module/bspwm.label-focused-underline&#125;label-focused-padding = $&#123;module/bspwm.label-focused-padding&#125;label-unfocused-padding = $&#123;module/bspwm.label-occupied-padding&#125;label-visible-background = $&#123;self.label-focused-background&#125;label-visible-underline = $&#123;self.label-focused-underline&#125;label-visible-padding = $&#123;self.label-focused-padding&#125;label-urgent-background = $&#123;module/bspwm.label-urgent-background&#125;label-urgent-padding = $&#123;module/bspwm.label-urgent-padding&#125; |[module/xbacklight]type = internal/xbacklightformat = &lt;label&gt; &lt;bar&gt;label = BLbar-width = 10bar-indicator = |bar-indicator-foreground = #ffbar-indicator-font = 2bar-fill = ─bar-fill-font = 2bar-fill-foreground = #9f78e1bar-empty = ─bar-empty-font = 2bar-empty-foreground = $&#123;colors.foreground-alt&#125;[module/backlight-acpi]inherit = module/xbacklighttype = internal/backlightcard = intel_backlight[module/cpu]type = internal/cpuinterval = 2format-prefix = &quot; &quot;;format-prefix-foreground = $&#123;colors.foreground-alt&#125;;format-underline = #f90000label = %percentage:2%%[module/memory]type = internal/memoryinterval = 2format-prefix = &quot; &quot;;format-prefix-foreground = $&#123;colors.foreground-alt&#125;;format-underline = #4bffdclabel = %percentage_used%%[module/wlan]type = internal/networkinterface = wlp3s0interval = 3.0format-connected = &lt;ramp-signal&gt;;format-connected-underline = #9f78e1label-connected = &quot;%essid%&quot;format-disconnected = ;format-disconnected = &lt;label-disconnected&gt;;format-disconnected-underline = $&#123;self.format-connected-underline&#125;label-disconnected = %ifname% disconnectedlabel-disconnected-foreground = #999999ramp-signal-0 = ramp-signal-1 = ramp-signal-2 = ramp-signal-3 = ramp-signal-4 = animation-packetloss-0 = ⚠animation-packetloss-0-foreground = #ffa64c;ramp-signal-foreground = $&#123;colors.foreground-alt&#125;[module/eth]type = internal/networkinterface = enp0s31f6interval = 3.0format-connected-underline = #55aa55format-connected-prefix = &quot;📶&quot;format-connected-prefix-foreground = $&#123;colors.foreground-alt&#125;label-connected = %local_ip%format-disconnected =;format-disconnected = &lt;label-disconnected&gt;;format-disconnected-underline = $&#123;self.format-connected-underline&#125;;label-disconnected = %ifname% disconnected;label-disconnected-foreground = $&#123;colors.foreground-alt&#125;[module/date]type = internal/dateinterval = 5date = &quot; %Y-%m-%d&quot;;date-alt = &quot; %Y-%m-%d&quot;time = %H:%M;time-alt = %H:%M:%Sformat-prefix = ;format-prefix-foreground = $&#123;colors.foreground-alt&#125;;format-underline = #0a6cf5label = %date% %time%[module/alsa]type = internal/volumeformat-volume = &lt;label-volume&gt; &lt;bar-volume&gt;label-volume = label-volume-foreground = $&#123;root.foreground&#125;format-muted-prefix = &quot; &quot;format-muted-foreground = $&#123;colors.foreground-alt&#125;label-muted = bar-volume-width = 5bar-volume-foreground-0 = #55aa55bar-volume-foreground-1 = #55aa55bar-volume-foreground-2 = #55aa55bar-volume-foreground-3 = #55aa55bar-volume-foreground-4 = #55aa55bar-volume-foreground-5 = #f5a70abar-volume-foreground-6 = #ff5555bar-volume-gradient = falsebar-volume-indicator = |bar-volume-indicator-font = 2bar-volume-fill = ─bar-volume-fill-font = 2bar-volume-empty = ─bar-volume-empty-font = 2bar-volume-empty-foreground = $&#123;colors.foreground-alt&#125;[module/battery]type = internal/batterybattery = BAT0adapter = ADP1full-at = 98format-charging = &lt;animation-charging&gt; &lt;label-charging&gt;format-charging-underline = #ffb52aformat-discharging = &lt;ramp-capacity&gt; &lt;label-discharging&gt;;format-discharging-underline = $&#123;self.format-charging-underline&#125;format-full-prefix = &quot; &quot;;format-full-prefix-foreground = $&#123;colors.foreground-alt&#125;format-full-underline = $&#123;self.format-charging-underline&#125;ramp-capacity-0 = ramp-capacity-1 = ramp-capacity-2 = ramp-capacity-3 = ;ramp-capacity-foreground = $&#123;colors.foreground-alt&#125;animation-charging-0 = animation-charging-1 = animation-charging-2 = animation-charging-3 = ;animation-charging-foreground = $&#123;colors.foreground-alt&#125;animation-charging-framerate = 750[module/temperature]type = internal/temperaturethermal-zone = 0warn-temperature = 60format = &lt;ramp&gt; &lt;label&gt;;format-underline = #f50a4dformat-warn = &lt;ramp&gt; &lt;label-warn&gt;;format-warn-underline = $&#123;self.format-underline&#125;label = %temperature%label-warn = %temperature%label-warn-foreground = $&#123;colors.secondary&#125;ramp-0 = ramp-1 = ramp-2 = ;ramp-foreground = $&#123;colors.foreground-alt&#125;[module/powermenu]type = custom/menuexpand-right = trueformat-spacing = 1label-open = label-open-foreground = $&#123;colors.secondary&#125;label-close =  cancellabel-close-foreground = $&#123;colors.secondary&#125;label-separator = |label-separator-foreground = $&#123;colors.foreground-alt&#125;menu-0-0 = rebootmenu-0-0-exec = rebootmenu-0-1 = power offmenu-0-1-exec = poweroff[settings]screenchange-reload = true[global/wm]margin-top = 5margin-bottom = 5 上面这段配置文件是polybar的配置文件，我们还需要一个启动polybar的脚本 launch.sh 这里的launch.sh可以改名，但是不必须得放在~/.config/polybar目录下，改名后需要修改i3配置文件的第33行。 12345678910#!/usr/bin/env bash# Terminate already running bar instanceskillall -q polybar# Wait until the processes have been shut downwhile pgrep -u $UID -x polybar &gt;/dev/null; do sleep 1; done# Launch bar1 and bar2polybar example &amp; 三、使用i3这一小节，我主要介绍我的配置文件所做的事。 下面的说明并不是将我的配置文件全部进行解读，有些我觉得你们能看懂的我就没写。 set $mod Mod1 设置i3的super为Alt键 new_window pixel 1 设置新窗口的窗口边缘的像素 new_float normal 设置浮动窗口，值为默认 hide_edge_borders 设置窗口边框隐藏 按键 说明 $mod+u 设置边框存在 $mod+y 设置边框像素为1 $mod+n 设置边框隐藏 $mod+Return(回车键) 打开alacritty终端 $mod+Shift+Return 通过alacritty打开ranger $mod+Control+g 打开Chrome $mod+Controll+f 打开Firefox $mod+Shift+q 杀死聚焦窗口 $mod+d 打开rofi $mod+h+j+k+l 将聚焦在窗口之间切换 $mdo+上下左右 同上，只不过用的是方向键 $mod+Shift+h+j+k+l 将聚焦窗口改变排列位置 $mod+Shift+上下左右 同上，只不过用的是方向键 $mod+b 切换至上一个工作区 $mod+Shift+b 将上一个工作区的容器，移动至当前工作区内 $mod+q 切换平铺方式 $mod+f 将聚焦窗口全屏 $mod+s 容器窗口排列方式为堆叠式 $mod+w 容器窗口排列方式为标签式 $mod+e 容器窗口排列方式为平铺式 $mod+Shift+space(空格键) 切换容器窗口为平铺还是浮动 $mod+space 在浮动或平铺窗口之间进行聚焦的切换 $mod+Ctrl+左或右 切换工作区，前或后 $mod+1-8 切换工作区 $mod+Ctrl+1-8 将当前容器的窗口移动至某个工作区 $mod+Shift+1-8 将当前容器移动至某个工作区 $mod+Shift+r 重启i3 $mod+Shift+c 重载i3配置文件 $mod+0 进入系统模式 l 系统模式:锁屏 s 系统模式:挂出 u 系统模式:切换用户 e 系统模式:登出 h 系统模式:休眠 r 系统模式:重启 Shift+s 系统模式:关机 $mod+r 进入窗口大小设置模式 h j k l 设置窗口上下左右的大小 上下左右 同上 Return 退出窗口大小设置模式 触摸板开关 触摸板开关 0x2 rofi一、安装rofi sudo pacman -S rofi 二、配置rofi三、使用rofi0x1 ranger一、安装ranger二、配置ranger三、使用ranger0x2 alacritty一、安装alacritty二、配置alacritty三、使用alacritty0x3 vim一、配置vim0x4 zsh一、安装zsh二、配置zsh0x5 ssr+proxychains一、安装ssr二、配置ssr三、安装proxychains四、配置proxychains五、使用ssr+proxychains实现全应用走代理0x6 fcitx一、安装fcitx二、配置fcitx三、启动fcitx]]></content>
      <categories>
        <category>折腾日志</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>i3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boring Article]]></title>
    <url>%2F2019%2F07%2F12%2FBoring-Article%2F</url>
    <content type="text"><![CDATA[Since I returned to Xinjiang,I have to eat and sleep everyday.I was so bored,then I had this article. &emsp;Befor I came to Xinjiang,I hope I can take many beatuiful pictures,eat my favorite food and do what I want to do.But now the only way to take pictures just can with mobile phone,Cameras can not be used.Every day.I eat with my parents.butI can not eat what I want.Finally,I care too much about me .I thought that home is to be free and easy to call home.I always manage my family,which is called cage! &emsp;In fact.this article is a dissemination of negative energy.If you are unhappy,I am sorry.My father just came back,he said that his business is finished.the rest of the time can enjoy.I hope the next summer life will be enriched!]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyCuteSister-1]]></title>
    <url>%2F2019%2F07%2F10%2FMyCuteSister-1%2F</url>
    <content type="text"><![CDATA[The article is the next article of “MyCuteSister”. &emsp;Next article we talk about my sister something not bad and she’s appearance,this article let’s we talk about she’s school work. &emsp;My sister is seven years old,she attended Maria Kindergarten in GuangZhou.When she was a kindergraten student,she was excellent.She often become monitor of class. &emsp;She can also draw.Since she attended kindergraten,almost every week draw a works,So for about two hundred draw works stayed we home. &emsp;She can also dance.She use weekend time learn dance,Since she can’t back bend,thwart split to be dance a complete dance.And She often join Kindergraten activites,Our whole famliy is proud for her. &emsp;By the way,She can also play the piano,Whennever I am bored.I watch the video of her playing the piano,Which make me feel better immediately. &emsp;She will become a Primary Student,Because she went up THE AFFILIATED SCHOOL OF GUANGDONG UNIVERSITY OF FOREIGN STUDIES,Bug she need stay at school,I think I will very miss her. &esp;This is my sister,And I LOVE HER.]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyCuteSister-0]]></title>
    <url>%2F2019%2F07%2F09%2FMyCuteSister-0%2F</url>
    <content type="text"><![CDATA[Last article is so bad,so this article i want is not bad. &emsp;I have a young sister,she is so cute and pretty.Now I will introduce her.Ok let’s do it. She have a black long hair,and clear and shinning eyes.When she lie on soft reading books，I always think she so beatuiful and cute.At this point,I will ask her,what book are reading? then she always say cartoon book,At this point,I say,Why you read cartoon book? She say,because i like it. Let’s talk about she’s not good,also many children’s problems.It picky eaters,such as,she dislike eggplant，I tell her do not picky eaters,she say ok.]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyCollegeLife]]></title>
    <url>%2F2019%2F07%2F05%2FMyCollegeLife%2F</url>
    <content type="text"><![CDATA[&emsp;About three years ago,I left my school where I stayed for seven years.I lose so many friends,day and night accompany friend.Of course,including you. &emsp;Three years after,I become a college student，Maybe you guessed this article is about my college life.About at 2019-9-1 start my college lift.I think I have very excited at that time. &emsp;Before school start，I participate in Military training.Remember that time ,about one hundred peoples trained in a groups together,Instructor look we are tired,then he will say:”Everyboby listen! Drop Down!”，In the twinkling of an eye one hundred peoples on the ground lie.This time nobody care isn’t dirty，just look the sky，think，THE SKY SO BEATUIFUL. &emsp;The fight of time，military training will done.This time Not only have one hundred peoples,enough seven to ten hundred peoples.We sing school song together and with in millitary training time know’s friend add WeChat Friend，Of course，me too. &emsp;Speak the true talk.When our instructor go back to army，My eyes are wet，wet is not to say I love crying,It’s because he teach for me so many knowledge. &emsp;At the last，I sincerely thank my instructor，Peace!]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fraudster Shop-坑爹商店]]></title>
    <url>%2F2019%2F07%2F05%2FFraudster-Shop-%E5%9D%91%E7%88%B9%E5%95%86%E5%BA%97%2F</url>
    <content type="text"><![CDATA[昨晚我尝试安装了i3，Manjaro的配置，然而我一直没有配置完成，我就想重装个Manjaro-i3反正文件都在Github上，不过我的U盘不知从何时起就不见了，所以我需要买个U盘。 Chinese&emsp;自从昨晚系统被我玩到暂时无法使用后，我这个内心就无法平静，一直想着一定要把i3配置好，不然过两天去乌鲁木齐连Github都上不去就惨了。 &emsp;昨晚正好宿舍又没多少电了，所以空调没开就睡觉了。睡得比较早，醒得也比较早，半夜3点就醒来了，没错，就是被热醒的。时间流逝得挺快，一晃眼就到白天了，东西收拾完毕，床位打理完成后我便回家了，回家时我就想，早上下订单，京东同城的话下午应该就能到，不过就是贵了点运费，大概算下来USB3.0 16GB的U盘才45左右，不过我又想了想，选择回家买，不需要等待快递。 &emsp;我在街头转了又转，转了又转，就是没有发现一个电脑店，正当我有些失落的时候，街角的一间手机店引起了我的注意，我自信的，揣着钱包就进去了。“老板，你这里有没有USB3.0的U盘啊?” 我说，老板想都没想说了句,”有啊!”，说着便拿出一小沓U盘，我看了看说道:”老板，这些都不是USB3.0，你拿其他的给我看一下吧!”，我此时心里想，不用骗我了，拿一些2.0的来哄骗我是3.0的吧。老板无奈的说，”你一个小时后再来吧，我这里3.0的U盘卖完了。”，虽然老板说是卖完了，但我大概能知道他根本没有进过USB3.0的货，一直靠着用3.0的价格贩卖2.0的U盘。 &emsp;后来我又找了很多家手机店和电脑店，他们居然都没有USB3.0，并且他们卖的都是USB2.0，更让我吃惊的是，他们全部统一地将USB2.0的U盘卖70-80RMB左右。其中我尝试跟他们讲价，就算是2.0U盘我暂时买个4G的USB2.0还可以装我的i3，我出价30，这是我的最高价了…然后卖家给我说不能卖，最低55，掉价这么快，80直接掉到55，最终没谈成，因为我已经很不想买USB2.0了，更不可能花那么多钱买一个过时的产物。 &emsp;说了这么多，其实就是想让大家以后不要再去实体店买这种电子产品了，当然可能有一些实体店还是正常的价格的，但据我的真实体验，实体店普遍就是要坑小白的，并且就算你指明要USB3.0他还是会拿给你USB2.0看，尝试诱骗你。 &emsp;京东晚上7点下的单，第二天9点就可以取件了，真香。强烈推荐一线城市想买这种小物件直接京东买吧，甚至还有同城送，上午买下午就到，不过要多付点运费。]]></content>
      <categories>
        <category>英文文章</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超酷-字符文件管理-ranger]]></title>
    <url>%2F2019%2F07%2F03%2F%E8%B6%85%E9%85%B7-%E5%AD%97%E7%AC%A6%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-ranger%2F</url>
    <content type="text"><![CDATA[0x0 什么是ranger?ranger是一个基于文本的文件管理器，由Python编写。 0x1 为什么要选择ranger?ranger具有以下特性: vi风格的快捷键 书签 选择 标签 选项 命令历史 创建符号链接 任务视图 自定义命令 自定义快捷键按 0x2 使用ranger在终端内输入ranger以启动ranger 使用h j k l进行目录之间的进出。 0x3 配置ranger配置文件: rc.conf 基本选项与快捷键设置 commands.py 可在ranger下使用:执行的命令 rifile.conf 文件关联，控制不同文件用不同程序打开 配色方案: ranger默认自带四种配色方案:defalut jungle snow zenburn 使用:set colorscheme scheme进行切换。 自定义配色方案文件放在~/.config/ranger/colorschemes 0x4 我的ranger配置以上传至Github 点击访问 0x5 其他下载地址:点击获取 Arch系: 1&gt; pacman -S ranger]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最快-GPU加速-Alacritty终端]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%9C%80%E5%BF%AB-GPU%E5%8A%A0%E9%80%9F-Alacritty%E7%BB%88%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[0x0 Alacritty是什么?Alacritty是一个终端仿真器。 在Alacritty 0.3.3+版本，它支持运行在macOS,Linux,BSD和Windows之上，所以它是跨平台的的。 0x1 为什么选择Alacritty?Alacritty是目前性能最强的终端之一. 它使用GPU进行渲染，可以做到其他启动器无法实现的性能优化。 Alacritty的配置十分简单，虽然其默认的配置就非常合理，官方说其并不需要额外的设置，不过Alacritty仍然提供了很多配置终端的方面。 0x2 Alacritty的配置Alacritty的配置文件在:~/.config/alacritty/alacritty.yml 0 字体打开alacritty.yml文件，找到Font configuration这行注释，即可修改。 例如: 1234567891011# Font configuration (changes require restart)font: normal: family: Droid Sans Mono style: Regular bold: family: Droid Sans Mono italic: family: Droid Sans Mono 1 配色方案Alacritty官方提供了超多种的配置方案，点击我获取 我们只需要找一个自己喜欢的配色方案将配色代码复制 然后粘贴到alacritty.yml配置文件内即可. 例如:12345678910111213141516171819202122232425262728# Colors (Solarized Dark)colors: # Default colors primary: background: &apos;0x002b36&apos; # base03 foreground: &apos;0x839496&apos; # base0 # Normal colors normal: black: &apos;0x073642&apos; # base02 red: &apos;0xdc322f&apos; # red green: &apos;0x859900&apos; # green yellow: &apos;0xb58900&apos; # yellow blue: &apos;0x268bd2&apos; # blue magenta: &apos;0xd33682&apos; # magenta cyan: &apos;0x2aa198&apos; # cyan white: &apos;0xeee8d5&apos; # base2 # Bright colors bright: black: &apos;0x002b36&apos; # base03 red: &apos;0xcb4b16&apos; # orange green: &apos;0x586e75&apos; # base01 yellow: &apos;0x657b83&apos; # base00 blue: &apos;0x839496&apos; # base0 magenta: &apos;0x6c71c4&apos; # violet cyan: &apos;0x93a1a1&apos; # base1 white: &apos;0xfdf6e3&apos; # base3 2 快捷键默认的快捷键已经是非常合理了的，如果有特殊需求，我们可以在alacritty.yml内的Key bindings项下进行修改 并在里面的注释已经将全部语法都写好了，这里举两个例子，我们将原本需要按Paste键和Copy键位改为Ctrl+C和Ctrl+V。 例子： 12- &#123; key: V, mods: Control, action: Paste &#125;- &#123; key: C, mods: Control, action: Copy &#125; 注意不要漏写,号,不然可能会出现如下情况 0x3 我的Alacritty配置已经上传至Github，点击我获取 0x4 其他Alacritty-Github页面 Arch系一键安装: 1&gt; pacman -S alacritty]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>软件折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-文件过滤及内容编辑处理命令-2]]></title>
    <url>%2F2019%2F06%2F30%2FLinux-%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%8F%8A%E5%86%85%E5%AE%B9%E7%BC%96%E8%BE%91%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4-2%2F</url>
    <content type="text"><![CDATA[3.0 做Linux运维的多个好处 做运维可以认识更多人，同时也被更多人认识。 做运维可以让自己沟通，交际能力变得比开发人员更强。 相比开发岗位，运维的岗位更重要一些。 3.1 cat 合并文件或查看文件内容concatenate cat命令5大常用功能 序号 常用功能 例子以及说明 1 查看文件内容 cat file.txt 查看文件内容，最基本的使用 2 多个文件合并为一个文件 cat f1 f2 &gt; newf 将f1和f2的内容合并到newf 3 创建编辑新文件 cat &gt; file 输入后会请求输入，快捷键Ctrl+d/c可退出 4 非交互式编辑或追加新内容 cat &gt;&gt;file&lt;&lt;EOF 输入后会请求输入，在结束时输入EOF即可退出 5 清空文件内容 cat /dev/null &gt; file 清空文件内容 语法格式 1cat [选项] [文件] 选项 说明 -n 为输出的内容加编号，从1开始 -b 与-n类似，但它忽略空白行 -s 当遇到有多行空白行，则合并为单行空白行 -v 除了LFD和TAB之外，使用^和M-引用 -T 将Tab字符显示为^I -E 在行尾显示$符号 -t 等价与-vT -A 等价于-vE 例子 使用cat命令以非交互式的方式编辑文件 方式1: 123456789&gt; cat &gt;file&lt;&lt;EOFJust a test.EOF&gt; cat fileJust a test 解释: EOF为字符标签，用于标记从何开始与从何结束，可替换为任意字符，常用做法是用EOF表示，并且字符标签必须成对出现 易错点: 结束EOF必须置前，前面不能有任意字符 方式2: 123456789&gt; cat &gt;file&lt;&lt;-EOFJust a test. EOF&gt; cat fileJust a test. 解释: 在字符标签前加上-可以使得结束标签前可放置制表符，但仅仅只可放制表符 合并多个文件为单个文件 12345678910111213&gt; cat &gt; f1f1Ctrl+d&gt; cat &gt; f2f2Ctrl+c&gt; cat f1 f2f1f2&gt; cat f1 f2 &gt; newfile&gt; cat newfilef1f2 3.2 tac 反向显示文件内容跟cat命令类似，反向输出文件内容 选项 说明 -b 在行前添加分隔标志 -r 将分隔标志视作正则表达式进行解析 -s 使用指定字符作为换行的标志 例子 123456&gt; cat file1helloworld&gt; tac file2worldhello 3.3 more 分页显示文件内容more类似于cat命令，区别在于cat命令是将文件内容一次性全部显示在屏幕上，而more则会分页进行显示。 语法格式 1more [选项] [文件] more参数选项说明 选项 说明 -num 指定屏幕显示大小为num行 +num 从行号num开始显示 -s 把连续的多个空行显示在一行 -p 不滚屏，而是清除整个自己屏幕，然后显示文件 -c 不滚屏，而是从每一屏的顶部开始显示文本，每显示完一行，就清除这一行的剩余部分 more交互式说明 子命令 说明 h/? 查看帮助 空格键 向下滚动一屏 z 向下滚动一屏 Enter 向下显示一行 f 向下滚动一屏 b 返回上一屏 = 输出当前行的行号 /查找文本 查找指定的文本 :f 输出文件名和当前行的行号 v 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 3.4 less 分页显示文件内容less类似more命令，less的功能比more要强大 语法格式 1less [选项] [文件] less命令的参数选项及说明 选项 说明 -i 搜索时忽略大小写 -m 显示进度百分比 -N 显示行号 -s 多行空行显示为单行 -e 当显示到文件结尾时自动退出，若没有此选项则需要用交互式q退出 less命令的交互式子命令及说明 子命令 说明 b 向前翻一页 空格键 向后翻一页 u 向前翻半页 d 向后翻半页 y 向上滚动一行 回车键 向下滚动一行 方向键-上 向上滚动一行 方向键-下 向下滚动一行 Page UP 向上滚动一屏 Page Down 向下滚动一屏 例子: 显示文件内容时并且显示行号 1&gt; less -N 文件名 分页显示命令的结果 1&gt; ls -l | less 3.5 head 显示文件内容头部head命令用于显示文件内容头部，默认输出行数为10行。 语法格式 1head [选项] [文件] head命令的参数选项及说明 选项 说明 -n&lt;行数&gt; 指定显示的行数 -c&lt;字节&gt; 指定显示的字节数 -q 显示时不包含指定的文件名作为文件头部 -v 显示时包含指定的文件的文件名作为文件头部 例子: 默认显示文件的前10行 1234567891011&gt; head /etc/passwdroot:x:0:0::/root:/bin/bashnobody:x:65534:65534:Nobody:/:/sbin/nologindbus:x:81:81:System Message Bus:/:/sbin/nologinbin:x:1:1::/:/sbin/nologindaemon:x:2:2::/:/sbin/nologinmail:x:8:12::/var/spool/mail:/sbin/nologinftp:x:14:11::/srv/ftp:/sbin/nologinhttp:x:33:33::/srv/http:/sbin/nologinsystemd-journal-remote:x:982:982:systemd Journal Remote:/:/sbin/nologinsystemd-network:x:981:981:systemd Network Management:/:/sbin/nologin 显示文件的前n行 123&gt; head -n 2 /etc/passwdroot:x:0:0::/root:/bin/bashnobody:x:65534:65534:Nobody:/:/sbin/nologin 显示文件的前n个字节 12&gt; head -c 4 /etc/passwdroot 显示多个文件 123456&gt; head -1 /etc/passwd /etc/profile==&gt; /etc/passwd &lt;==root:x:0:0::/root:/bin/bash==&gt; /etc/profile &lt;==# /etc/profile 3.6 tail显示文件内容尾部tail命令用于显示文件内容尾部，默认输出行数为10行。 语法格式 1tail [选项] [文件] tail命令的参数选项及说明 选项 说明 -c&lt;字节&gt; 指定显示的字节数 -n&lt;行数&gt; 指定显示的行数 -f 实时输出文件内容追加的数据 –retry 不停的尝试打开文件，直到打开为止 -F 等同于-f–retry –pid=进程号 若进程关闭则tail的-f选项则不会继续输出内容 -s 秒数 N 监视文件的间隔秒数 -q 显示时不包含指定的文件名作为文件头部 -v 显示时包含指定的文件的文件名作为文件头部 例子: 显示文件最后10行 1234567891011&gt; tail /etc/passwdgit:x:973:973:git daemon user:/:/usr/bin/git-shelllightdm:x:620:620:Light Display Manager:/var/lib/lightdm:/sbin/nologinnm-openconnect:x:972:972:NetworkManager OpenConnect:/:/sbin/nologinnm-openvpn:x:971:971:NetworkManager OpenVPN:/:/sbin/nologinntp:x:87:87:Network Time Protocol:/var/lib/ntp:/bin/falsepolkitd:x:102:102:PolicyKit daemon:/:/sbin/nologinusbmux:x:140:140:usbmux user:/:/sbin/nologinevanmeek:x:1000:1000:EvanMeek:/home/evanmeek:/usr/bin/zshnvidia-persistenced:x:143:143:NVIDIA Persistence Daemon:/:/sbin/nologinprivoxy:x:42:42:Privoxy:/:/sbin/nologin 显示文件最后5行 第一种写法 1&gt; tail -n 5 /etc/passwd 第二种写法 1&gt; tail -5 /etc/passwd 指定从第几行开始显示文件 1&gt; tail -n +10 /etc/passwd 实时监控文件的变化 监测12&gt; tail -f --retry test.txttestwords 追加内容 1&gt; echo testwords &gt;&gt; test.txt 3.7 tailf 跟踪日志文件tailf命令日常工作中用于跟踪日志文件，它与tail -f命令基本相同，但唯一的区别是若文件内容无增加，则不会重复访问磁盘文件，也不会修改文件访问时间。 语法格式 1tailf [选项] [文件] tailf命令的参数选项及说明 选项 说明 -n&lt;行数&gt; 指定显示的行数，默认为文件最后10行 例子： 跟踪日志文件 1&gt; tailf 3.8 cut 从文本中提取一段文字并输出cut命令从文件的每一行剪切字节，字符或字段，并将其输出至标准输出。 语法格式 1cut [选项] [文件] cut命令的参数选项及说明 选项 说明 -b 以字节为单位进行分割 -n 取消分割多字节字符 -c 以字符为单位进行分割! -d 自定义分隔符，默认以tab为分隔符! -f 与选项-d一起使用，指定显示哪个区域 N 第N个字节、字符或字段! N- 从第N个字节、字符或字段开始直至行尾 N-M 从第N到第M个字节、字符或字段 -M 从第一到第M个字节、字符或字段 例子: 以字节为分隔符 1234567891011121314151617&gt; cat test.txtHello World# 截取第5个字节，并输出&gt; cut -b 5 test.txto# 截取第5个字节之前的所有字符(包括第5个)，并输出&gt; cut -b -5 test.txtHello# 截取第5个字节之后的所有字符，并输出&gt; cut -b 5- test.txto World# 截取第5个字节和第10个字节，并输出&gt; cut -b 5,10 test.txtol# 截取第1个字节到第5个字节，并输出&gt; cut -b 1-5 test.txtHello 以字符为分隔符 1234567&gt; cat test.txtHello World你好世界# 截取第1到第6个字符，并输出&gt; cut -b 1-6 test.txtHello你好 自定义分隔符 123456789101112131415&gt; cat /etc/passwd | head -n 5root:x:0:0::/root:/bin/bashnobody:x:65534:65534:Nobody:/:/sbin/nologindbus:x:81:81:System Message Bus:/:/sbin/nologinbin:x:1:1::/:/sbin/nologindaemon:x:2:2::/:/sbin/nologin# 自定义分隔符为`:`，并且之输出文件前5行(:为分隔符，-f 1为指定显示第1个区域&gt; cut -d : -f 1 /etc/passwd | head -n 5rootnobodydbusbindaemon# 指定显示区域为1,6-8&gt; cut -d : -f 1,6-8 /etc/passwd | head -n +5 3.9 split 分割文件split命令可以将文件进行分割，支持根据行数或文件大小进行分割。 语法格式 1split [选项] [输入文件] [输出文件名[前缀]] 输出文件的格式会加上前缀，例如PREFIXaa,PREFIXab split命令的参数选项及说明 选项 说明 -b 指定分割后文件的最大字节数 -l 指定分割后文件的最大行数! -a 指定后缀长度，默认为2位字母 -d 使用数字后缀 例子: 按行分割文件，以及指定后缀形式 123456789101112131415161718192021222324252627# wc 命令可以查看文件的行数&gt; wc -l /etc/passwd31 /etc/passwd# 按行进行分割，每10行分割为一个新文件，文件前缀为split_&gt; split -l 10 /etc/passwd split_&gt; wc -l split_*10 split_aa10 split_ab10 split_ac 1 split_ad31 总用量# 参数-a指定分割文件的前缀长度，这里设置的是1&gt; split -l 10 -a 1 /etc/passwd split2_&gt; wc -l split2_*10 split2_a10 split2_b10 split2_c 1 split2_d31 总用量# 参数-d指定文件使用数字后缀&gt; split -l 10 -d -a 1 /etc/passwd split_&gt; wc -l split_*10 split_010 split_110 split_2 1 split_331 总用量&lt;Paste&gt; 按文件大小分割文件 123456789101112131415# 准备测试文件&gt; cp /sbin/lvm .&gt; ls -l总用量 2.3M-r-xr-xr-x 1 evanmeek evanmeek 2.3M 7月 22 21:23 lvm# 按文件字节进行分割，每500K字节分割为一个文件，以数字作为文件后缀&gt; split -b 500K -d lvm lvm_split_&gt; ls -l总用量 4.5M-r-xr-xr-x 1 evanmeek evanmeek 2.3M 7月 22 21:23 lvm-rw-r--r-- 1 evanmeek evanmeek 500K 7月 22 21:25 lvm_split_00-rw-r--r-- 1 evanmeek evanmeek 500K 7月 22 21:25 lvm_split_01-rw-r--r-- 1 evanmeek evanmeek 500K 7月 22 21:25 lvm_split_02-rw-r--r-- 1 evanmeek evanmeek 500K 7月 22 21:25 lvm_split_03-rw-r--r-- 1 evanmeek evanmeek 254K 7月 22 21:25 lvm_split_04 3.10 paste 合并文件paste命令能将文件按照行与行进行合并，中间使用tab隔开 语法格式1paste [选项] [文件] paste命令的参数选项及说明 选项 说明 -d 指定合并的分隔符，默认是Tab! -s 每个文件占用一行 例子: 合并文件 12345678910111213141516171819202122232425&gt; more t1 t2::::::::::::::t1::::::::::::::test1test1test1::::::::::::::t2::::::::::::::test2test2test2# t1与t2合并，将内容写入t3&gt; paste t1 t2 &gt; t3&gt; cat t3test1 test2test1 test2test1 test2# 合并时，自定义分隔符&gt; paste -d - t1 t2 &gt; t3&gt; cat t3test1-test2test1-test2test1-test2 文件内容合并成一行 1234&gt; paste -s t1 t2 &gt; t3&gt; cat t3test1 test1 test1test2 test2 test2 3.11 sort 文本排序sort命令将输入的文件内容按照指定的规则进行排序，然后将排序结果输出 语法格式 1sort [选项] [文件] sort命令的参数选项及说明 选项 说明 -b 忽略每行开头存在的空格字符 -n 按照数值的大小进行排序! -r 倒序排序! -u 去除重复行 -t 指定分隔符! -k 按照指定区间排序! 例子: 默认以行为单位进行排序 1234567891011121314151617181920212223$ cat test.txtt1t2t3t4# sort默认是以ASCII码进行升序排序。$ sort test.txtt1t2t3t4# 按照数值的大小进行排序$ sort -n test.txtt1t2t3t4# 按照数值的大小降序排序$ sort -nr test.txtt4t3t2t1 去除重复行 12345678910111213$ cat test.txtt1 Dt1 Dt1 Dt2 Ct3 Bt4 A# 去除重复行，并且逆序排序$ sort -u test.txt | sort -nrt4 At3 Bt2 Ct1 D 自定义区间排序 12345678# 指定以空格作为分隔符，并且以第二列进行逆序排序$ sort -t &quot; &quot; -k2 test.txtt4 At3 Bt2 Ct1 Dt1 Dt1 D -t -k的进阶用法 123456789101112131415161718192021222324252627$ cat ip.txt192.197.113.0 192.197.113.255 256193.112.0.0 193.112.255.255 65536195.78.82.0 195.78.83.255 512198.175.100.0 198.175.103.255 1024199.212.57.0 199.212.57.255 256202.0.100.0 202.0.101.255 512202.0.122.0 202.0.123.255 512202.0.176.0 202.0.179.255 1024202.3.128.0 202.3.129.255 512202.3.134.0 202.3.134.255 256202.4.128.0 202.4.159.255 8192202.4.252.0 202.4.255.255 1024# 以第3个字段的第1个字符到第3个字段的第3个字段进行数字排序$ sort -n -t. -k3.1,3.3 ip.txt193.112.0.0 193.112.255.255 65536199.212.57.0 199.212.57.255 256195.78.82.0 195.78.83.255 512198.175.100.0 198.175.103.255 1024202.0.100.0 202.0.101.255 512192.197.113.0 192.197.113.255 256202.0.122.0 202.0.123.255 512202.3.128.0 202.3.129.255 512202.4.128.0 202.4.159.255 8192202.3.134.0 202.3.134.255 256202.0.176.0 202.0.179.255 1024202.4.252.0 202.4.255.255 1024 3.12 join 按两个文件的相同字段合并join命令针对每一对具有相同内容的输入行，整合为一行输出到标准输出，默认情况下是把输入的第一个字段作为连接字段，字段之间用空格隔开。 语法格式 1join [选项] [文件1] [文件2] join命令的参数选项及说明 选项 说明 -a文件号 输出文件中不匹配的行，文件号可选值1或2,代表文件1和文件2 -i 比较字段时忽略大小写 -1 字段 以第1个文件的指定字段为基础进行合并 -2 字段 以第2个文件的指定字段为基础进行合并 例子: 合并文本 1234567891011121314151617181920212223$ more t1.txt t2.txt::::::::::::::t1.txt::::::::::::::张三 21岁李四 23岁王五 17岁赵六 15岁::::::::::::::t2.txt::::::::::::::张三 男李四 女王五 男赵六 女# 将t1和t2进行合并$ join t1.txt t2.txt &gt; t3.txt$ cat t3.txt张三 21岁 男李四 23岁 女王五 17岁 男赵六 15岁 女 3.13 uniq 去除重复行uniq命令可以输出或忽略文件中的重复行。在工作中，我们常用的场景是使用sort命令对文件排序，然后使用uniq命令去重并计数。 语法格式 1uniq [选项] [文件或标准输入] 选项说明 选项 说明 -c 去除重复行，并且计算每行出现的次数 -d 只显示重复的行 -u 只显示唯一的行 例子: 去重测试案例 12345678&gt; cat test.txt重复重复重复重复重复重复重复重复重复重复重复重复重复重复重复&gt; uniq -c test.txt5 重复重复重复 结合sort排序后去重 123456789101112131415161718&gt; cat test.txt100001000021000010000210000&gt; uniq -c test.txt2 100001 22 100001 21 10000# 在这里我们发现，uniq只能去除相邻重复的行，所以我们就使用sort排序后再进行去重复&gt; sort -n test.txt | uniq -c2 25 10000 3.14 wc 统计文件的行数、单词数或字节数wc命令用于统计文件的行数、单词数和字节数。 语法格式 1wc [选项] [文件] 选项说明 选项 说明 -c 统计字节数 -l 统计行数! -m 统计字符数 -w 统计单词数 -L 输出最长行的长度! 例子: 查看文件的字节数、字数、行数1234&gt; wc /etc/profile9 30 189 /etc/profile# 依次排列过去是 行数 - 单词数 - 字节数 3.15 iconv 转换文件的编码格式iconv命令用于转换文件的编码格式. 语法格式 1iconv [选项] [原编码] [新编码] [输入文件] 选项说明 选项 说明 -f encodingA 从编码A转换! -t encodingB 转换程编码B ! -l 显示系统支持的编码! -o 将输出输入到指定文件! 例子: 123456&gt; cat utf-8.txt你好世界# 指定utf-8.txt的编码格式为utf-8，将要转换成GB2312&gt; iconv -f UTF-8 -t GB2312 utf-8.txt &gt; gbk.txt&gt; cat gbk.txt无回显 3.16 dos2unix 将DOS格式文件转换成UNIX格式由于dos格式的文件的换行符与unix格式的文件的换行符不同，所以需要转换。 语法格式 1dos2unix [文件] 例子: 1&gt; dos2unix dosfile.txt 3.17 diff 比较两个文件的不同diff命令可以逐行比较纯文本文件的内容，并输出文件的差异。 语法格式 1diff [选项] [文件1] [文件2] 选项说明 选项 说明 -y 以并列的方式显示文件的异同之处 -W 在使用-y参数时，指定显示宽度 -c 使用上下文的输出格式 -u 使用统一格式输出 例子: 比较两个文本文件 12345678910111213141516171819202122232425evanmeek@EvanMeekdeMBP  ~/TestDir  cat test1.txt123456evanmeek@EvanMeekdeMBP  ~/TestDir  cat test2.txt456789evanmeek@EvanMeekdeMBP  ~/TestDir  diff test1.txt test2.txt# 代表文件2对比文件1删除了第一行到第三行1,3d0&lt; 1&lt; 2&lt; 3# 代表文件1的第6行下增加了文件2的第4行和第5行6a4,6&gt; 7&gt; 8&gt; 9 并排格式输出 12345678910✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -y test1.txt test2.txt1 &lt;2 &lt;3 &lt;4 45 56 6 &gt; 7 &gt; 8 &gt; 9 并排格式输出时指定宽度 12345678910✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -y -W 30 test1.txt test2.txt1 &lt;2 &lt;3 &lt;4 45 56 6 &gt; 7 &gt; 8 &gt; 9 上下文输出格式 123456789101112131415161718✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -c test1.txt test2.txt*** test1.txt 2019-08-25 16:39:32.000000000 +0800--- test2.txt 2019-08-25 16:40:32.000000000 +0800****************** 1,6 ****- 1- 2- 3 4 5 6--- 1,6 ---- 4 5 6+ 7+ 8+ 9 统一标准输出格式 12345678910111213✘ evanmeek@EvanMeekdeMBP  ~/TestDir  diff -u test1.txt test2.txt--- test1.txt 2019-08-25 16:39:32.000000000 +0800+++ test2.txt 2019-08-25 16:40:32.000000000 +0800@@ -1,6 +1,6 @@-1-2-3 4 5 6+7+8+9 3.19 rev 反向输出文件内容rev命令可以按行反向输出文件内容 语法格式 1rev [文件] 例子: 字符串反转 1234&gt; echo &#123;1..10&#125;1 2 3 4 5 6 7 8 9 10&gt; echo &#123;1..10&#125;|rev01 9 8 7 6 5 4 3 2 1 文本反转 1234&gt; cat testfile你好世界&gt; rev testfile界世好你 3.20 tr 替换或删除字符tr命令从标准输入中替换、缩减或删除字符，并将结果写入到标准输出 语法格式 1tr [选项] [字符1] [字符2] 选项说明 选项 说明 -d 删除字符! -s 保留连续字符的第一个字符，删除其他字符 -c 使用第一个字符串(set1)的补集，取反 例子: 替换文本中出现的字符为某字符 123456789&gt; cat testfiletest wordaa bb ccabc# 这里是将文件中出现&apos;a&apos;的字符替换成&apos;x&apos;,依次对应&gt; tr &apos;abc&apos; &apos;xyz&apos; &lt; testfiletest wordxx yy zzxyz 使用tr统一字母大小写 123456789&gt; cat testfiletest wordaa bb ccabc# [a-z]代表小写字母a b c d..z&gt; tr &apos;[a-z]&apos; &apos;[A-Z]&apos; &lt; testfileTEST WORDAA BB CCABC 将数字0-9替换为a-j 1234&gt; cat testfile0 1 2 3 4 5 6 7 8 9&gt; tr &apos;[0-9]&apos; &apos;[a-j]&apos; &lt; testfilea b c d e f g h i j 删除文件中出现的Evan这个单词中的每个字符 1234&gt; cat testfileEeEvVvaAanNn&gt; tr -d &apos;Evan&apos; &lt; testfileeVAN 删除文件中出现的换行符和制表符 123456&gt; cat tesfilea aaa aaa aaab b b &gt; tr -d &apos;\n\t&apos; &lt; testfilea aaa aaa aaab b b% 3.21 od 按不同进制显示文件od命令用于输出文件的八进制，十六进制等其他编码格式的字节，通常用于显示或查看文件中不能直接显示在终端的字符 语法格式 1od [选项] [文件] 选项说明 选项 说明 -A 地址进制 按指定的进制显示地址信息 -t 显示格式 指定数据的显示格式 地址信息 解释 o 八进制(默认) d 十进制 x 十六进制 n 不打印位移值 格式 解释 a 命名字符，忽略高阶位 c ASCII字符或反斜杠序列 d 有符号的十进制数 f 浮点数 o 八进制(系统默认) u 无符号十进制 x 十六进制]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的VIM配置详解]]></title>
    <url>%2F2019%2F06%2F21%2F%E6%88%91%E7%9A%84VIM%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近看了位B站Up主的视频，决定好好配置下自己的VIM，不再直接使用SpaceVim，别人配置的东西终究是别人的，要自己配置才是最顺手的。 我已经把我的配置文件上传到了Github上了，点击访问 基本都有写中文注释，哪里有不懂的，可以问我，点击查看我的联系方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302&quot; 设置vi与vim兼容set nocompatible&quot; 设置使vim识别不同的文件格式filetype onfiletype indent onfiletype plugin onfiletype plugin indent on&quot; 设置使vim能用鼠标操作set mouse=a&quot; 设置字符编码set encoding=utf-8&quot; 使配色更加兼容你的终端let &amp;t_ut=&apos;&apos;&quot; 设置缩进距离set expandtabset tabstop=2set shiftwidth=2set softtabstop=2&quot; 设置空格的显示set listset listchars=tab:▸\ ,trail:▫set tw=0set indentexpr=&quot; 退格键到行首后自动跳转到上行行尾set backspace=indent,eol,start&quot; 收起代码set foldmethod=indentset foldlevel=99&quot; 设置终端的光标在不同模式下用不同的样式,实测Konsole可用let &amp;t_SI = &quot;\&lt;Esc&gt;]50;CursorShape=1\x7&quot;let &amp;t_SR = &quot;\&lt;Esc&gt;]50;CursorShape=2\x7&quot;let &amp;t_EI = &quot;\&lt;Esc&gt;]50;CursorShape=0\x7&quot;&quot; 状态栏等于２？？？set laststatus=2&quot; vim执行的外部命令会在当前目录下执行set autochdir&quot; 关闭文件又打开光标会自动回到关闭前的位置au BufReadPost * if line(&quot;&apos;\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&apos;\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g&apos;\&quot;&quot; | endif&quot; 设置leader键为空格let mapleader=&quot; &quot;&quot; 代码高亮syntax on&quot; 设置行号set number&quot; 设置更好的行号set relativenumber&quot; 设置光标线set cursorline&quot; 自动换行set wrap&quot; 显示命令set showcmd&quot; tab多选项菜单set wildmenu&quot; 设置搜索关键词高亮set hlsearchexec &quot;nohlsearch&quot;&quot; 设置搜索输入时高亮set incsearch&quot; 搜索时忽略大小写set ignorecase &quot; 只能搜索忽略大小写set smartcase&quot; 搜索跳转结果改为=/-并且使搜索结果在屏幕中间noremap = nzznoremap - Nzz&quot; 大写JKHL重复五次执行noremap J 5jnoremap K 5knoremap H 5hnoremap L 5l&quot; 设置取消高亮noremap &lt;LEADER&gt;&lt;CR&gt; :nohlsearch&lt;CR&gt;&quot; 设置光标回到行首noremap &lt;LEADER&gt;a 0&quot; 设置光标回到行尾noremap &lt;LEADER&gt;e $&quot; 取消s删除字符的功能map s &lt;nop&gt;&quot; 快速保存map S :w&lt;CR&gt;&quot; 按大写Q直接退出map Q :q&lt;CR&gt;&quot; R快速source vimrcmap R :source ~/.vim/vimrc&lt;CR&gt;&quot;分屏操作&quot;向右分屏map &lt;LEADER&gt;l :set splitright&lt;CR&gt;:vsplit&lt;CR&gt;&quot;向左分屏map &lt;LEADER&gt;h :set nosplitright&lt;CR&gt;:vsplit&lt;CR&gt;&quot;向上分屏map &lt;LEADER&gt;k :set nosplitbelow&lt;CR&gt;:split&lt;CR&gt;&quot;向下分屏map &lt;LEADER&gt;j :set splitbelow&lt;CR&gt;:split&lt;CR&gt;&quot;光标移动至左分屏map sh &lt;C-w&gt;h&quot;光标移动至右分屏map sl &lt;C-w&gt;l&quot;光标移动至下分屏map sj &lt;C-w&gt;j&quot;光标移动至上分屏map sk &lt;C-w&gt;k&quot;增加纵向分屏大小map &lt;up&gt; :res +5&lt;CR&gt;&quot;减少纵向分屏大小map &lt;down&gt; :res -5&lt;CR&gt;&quot;减少横向分屏大小map &lt;left&gt; :vertical resize-5&lt;CR&gt;&quot;增加横横分屏大小map &lt;right&gt; :vertical resize+5&lt;CR&gt;&quot;将分屏设置为横向分屏map &lt;LEADER&gt;H &lt;C-w&gt;t&lt;C-w&gt;H&quot;将分屏设置为纵向分屏map &lt;LEADER&gt;K &lt;C-w&gt;t&lt;C-w&gt;K&quot;标签&quot;打开新标签map tn :tabe&lt;CR&gt;&quot; 跳转至上一个标签map th :-tabnext&lt;CR&gt;&quot; 跳转至下一个标签map tl :+tabnext&lt;CR&gt; &quot; 关闭当前标签map td :tabclose&lt;CR&gt;&quot;插件安装vim-plugcall plug#begin(&apos;~/.vim/plugged&apos;)Plug &apos;endel/vim-github-colorscheme&apos;Plug &apos;morhetz/gruvbox&apos;Plug &apos;vim-airline/vim-airline&apos;&quot; File navigationPlug &apos;scrooloose/nerdtree&apos;, &#123; &apos;on&apos;: &apos;NERDTreeToggle&apos; &#125;Plug &apos;Xuyuanp/nerdtree-git-plugin&apos;&quot; TaglistPlug &apos;majutsushi/tagbar&apos;, &#123; &apos;on&apos;: &apos;TagbarOpenAutoClose&apos; &#125;&quot; Error checkingPlug &apos;w0rp/ale&apos;&quot; Auto CompletePlug &apos;Valloric/YouCompleteMe&apos;&quot; Undo TreePlug &apos;mbbill/undotree/&apos;&quot; Other visual enhancementPlug &apos;nathanaelkane/vim-indent-guides&apos;Plug &apos;itchyny/vim-cursorword&apos;&quot; GitPlug &apos;rhysd/conflict-marker.vim&apos;Plug &apos;tpope/vim-fugitive&apos;Plug &apos;mhinz/vim-signify&apos;Plug &apos;gisphm/vim-gitignore&apos;, &#123; &apos;for&apos;: [&apos;gitignore&apos;, &apos;vim-plug&apos;] &#125;&quot; HTML, CSS, JavaScript, PHP, JSON, etc.Plug &apos;elzr/vim-json&apos;Plug &apos;hail2u/vim-css3-syntax&apos;Plug &apos;spf13/PIV&apos;, &#123; &apos;for&apos; :[&apos;php&apos;, &apos;vim-plug&apos;] &#125;Plug &apos;gko/vim-coloresque&apos;, &#123; &apos;for&apos;: [&apos;vim-plug&apos;, &apos;php&apos;, &apos;html&apos;, &apos;javascript&apos;, &apos;css&apos;, &apos;less&apos;] &#125;Plug &apos;pangloss/vim-javascript&apos;, &#123; &apos;for&apos; :[&apos;javascript&apos;, &apos;vim-plug&apos;] &#125;Plug &apos;mattn/emmet-vim&apos;&quot; PythonPlug &apos;vim-scripts/indentpython.vim&apos;&quot; MarkdownPlug &apos;iamcco/markdown-preview.nvim&apos;, &#123; &apos;do&apos;: &apos;cd app &amp; yarn install&apos; &#125;Plug &apos;dhruvasagar/vim-table-mode&apos;, &#123; &apos;on&apos;: &apos;TableModeToggle&apos; &#125;Plug &apos;vimwiki/vimwiki&apos;&quot; BookmarksPlug &apos;kshenoy/vim-signature&apos;&quot; Other useful utilitiesPlug &apos;terryma/vim-multiple-cursors&apos;Plug &apos;junegunn/goyo.vim&apos; &quot; distraction free writing modePlug &apos;tpope/vim-surround&apos; &quot; type ysks&apos; to wrap the word with &apos;&apos; or type cs&apos;` to change &apos;word&apos; to `word`Plug &apos;godlygeek/tabular&apos; &quot; type ;Tabularize /= to align the =Plug &apos;gcmt/wildfire.vim&apos; &quot; in Visual mode, type i&apos; to select all text in &apos;&apos;, or type i) i] i&#125; ipPlug &apos;scrooloose/nerdcommenter&apos; &quot; in &lt;space&gt;cc to comment a line&quot; DependenciesPlug &apos;MarcWeber/vim-addon-mw-utils&apos;Plug &apos;kana/vim-textobj-user&apos;Plug &apos;fadein/vim-FIGlet&apos;call plug#end()&quot; 设置透明let g:SnazzyTransparent = 1&quot; 设置主题&quot; 可选项&quot; github/snazzy/inkstainedlet g:grubvbox_termcolors=&apos;256&apos;let g:grubvbox_contrast_light = &apos;soft&apos;color gruvboxset background =light&quot; 插件配置&quot; ==== NERDTreemap ff :NERDTreeToggle&lt;CR&gt;&quot; ==== NERDTree-gitlet g:NERDTreeIndicatorMapCustom = &#123; \ &quot;Modified&quot; : &quot;✹&quot;, \ &quot;Staged&quot; : &quot;✚&quot;, \ &quot;Untracked&quot; : &quot;✭&quot;, \ &quot;Renamed&quot; : &quot;➜&quot;, \ &quot;Unmerged&quot; : &quot;═&quot;, \ &quot;Deleted&quot; : &quot;✖&quot;, \ &quot;Dirty&quot; : &quot;✗&quot;, \ &quot;Clean&quot; : &quot;✔︎&quot;, \ &quot;Unknown&quot; : &quot;?&quot; \ &#125;&quot; ==== You Complete ME&quot; 跳转至其他的声明nnoremap gd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;&quot; 跳转至文档nnoremap g/ :YcmCompleter GetDoc&lt;CR&gt;&quot; 获取类型nnoremap gt :YcmCompleter GetType&lt;CR&gt;&quot; 获取参考nnoremap gr :YcmCompleter GoToReferences&lt;CR&gt;let g:ycm_autoclose_preview_window_after_completion=0let g:ycm_autoclose_preview_window_after_insertion=1let g:ycm_use_clangd = 0let g:ycm_python_interpreter_path = &quot;/bin/python3&quot;let g:ycm_python_binary_path = &quot;/bin/python3&quot;&quot; ==== alelet b:ale_linters = [&apos;pylint&apos;]let b:ale_fixers = [&apos;autopep8&apos;, &apos;yapf&apos;]&quot; ==== TagListmap &lt;silent&gt; T :TagbarOpenAutoClose&lt;CR&gt;&quot; ==== MarkdownPreviewnmap &lt;LEADER&gt;mp :MarkdownPreview&lt;CR&gt;&quot; ==== vim-table-modemap &lt;LEADER&gt;tm :TableModeToggle&lt;CR&gt;&quot; ==== vim-indent-guidelet g:indent_guides_guide_size = 0let g:indent_guides_start_level = 2let g:indent_guides_enable_on_vim_startup = 1let g:indent_guides_color_change_percent = 0autocmd WinEnter * silent! unmap &lt;LEADER&gt;ig&quot; ====Goyomap &lt;LEADER&gt;gy :Goyo&lt;CR&gt;&quot; ==== vim-signiturelet g:SignatureMap = &#123; \ &apos;Leader&apos; : &quot;m&quot;, \ &apos;PlaceNextMark&apos; : &quot;m,&quot;, \ &apos;ToggleMarkAtLine&apos; : &quot;m.&quot;, \ &apos;PurgeMarksAtLine&apos; : &quot;dm-&quot;, \ &apos;DeleteMark&apos; : &quot;dm&quot;, \ &apos;PurgeMarks&apos; : &quot;dm/&quot;, \ &apos;PurgeMarkers&apos; : &quot;dm?&quot;, \ &apos;GotoNextLineAlpha&apos; : &quot;m&lt;LEADER&gt;&quot;, \ &apos;GotoPrevLineAlpha&apos; : &quot;&quot;, \ &apos;GotoNextSpotAlpha&apos; : &quot;m&lt;LEADER&gt;&quot;, \ &apos;GotoPrevSpotAlpha&apos; : &quot;&quot;, \ &apos;GotoNextLineByPos&apos; : &quot;&quot;, \ &apos;GotoPrevLineByPos&apos; : &quot;&quot;, \ &apos;GotoNextSpotByPos&apos; : &quot;mn&quot;, \ &apos;GotoPrevSpotByPos&apos; : &quot;mp&quot;, \ &apos;GotoNextMarker&apos; : &quot;&quot;, \ &apos;GotoPrevMarker&apos; : &quot;&quot;, \ &apos;GotoNextMarkerAny&apos; : &quot;&quot;, \ &apos;GotoPrevMarkerAny&apos; : &quot;&quot;, \ &apos;ListLocalMarks&apos; : &quot;m/&quot;, \ &apos;ListLocalMarkers&apos; : &quot;m?&quot; \ &#125;&quot; === Undotreelet g:undotree_DiffAutoOpen = 0map &lt;LEADER&gt;ut :UndotreeToggle&lt;CR&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-文件和目录操作命令-find命令]]></title>
    <url>%2F2019%2F06%2F21%2FLinux-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本篇文章为Linux系列的第2章 文件和目录操作名 2.13小节的外部展示 2.13.1 命令详解find命令参数较多，并且不同的参数所在的子模块不同. 12345678910111213 如何处理符号链接 | | 需要查找的路径 | | | |find -H-L-P path expression / | \ / | \ | | | options tests actions 参数 | | 限定的条件 | 执行的动作 选项 说明 pathname 需要查找的路径 Options模块 -depth 从指定目录下最深层的子目录开始查找 -maxdepth levels 查找的最大目录层级数，levels为自然数! -regextype type 改变正则表达式的模式，默认为emacs，还有posix-awk/basic/egrep/extended Tests模块 -mtime [-n\ n\ +n] 按照修改时间进行查找.后面会将，这几种n分别代表的是时间，单位为天! -atime[-n\ n\ +n] 同上，只不过是按照访问时间进行查找，单位为天 -ctime 按照文件的状态改变时间来查找文件，单位为天 -amin 按照文件的访问时间查找，单位为分钟 -cmin 按照文件的状态改变时间查找，单位为分钟 -mmin 按照文件的修改时间来查找文件，单位为分钟 -group 按照文件所属的组来查找文件 -name 按照文件名查找文件，只支持*,?,[]等特殊通配符! -newer 查找更改时间比指定文件新的文件 -nogroup 查找没有有效用户组的文件，即文件所属组在/etc/groups中不存在 -nouser 查找没有有效属主的文件，即该文件的属主在/etc/passwd中不存在 -path pattern 指定路径样式，配合-prune参数排除指定目录 -perm 按照文件权限来查找文件 -regex 接正则表达式 -iregex 不区分大小写接正则表达式 -size n[cwbkMG] 查找文件长度为n块的文件，带有cwbkMG时表示文件长度以字节计 -user 按照文件属主来查找文件 -type 查找某一类型的文件:!，后面会讲 -Actions模块 -delete 将查找出的文件删除 -exec 对匹配文件执行该参数给出的Shell命令! -ok 和-exec作用相同，但在执行每个命令之前，都会让用户先确定是否执行 -prune 使fint命令不再指定的目录中查找 -print 将匹配的文件输出到标准输出(默认可用 OPERATORS find支持逻辑运算符 ! 取反`! -a 取交集，全拼为and！ -o 取并集，全拼为or! -type 查找某一类型的文件: b(块设备文件) c(字符设备文件) d(目录) p(管道文件) l(符号链接文件) f(普通文件) s(socket文件) D(door) 2.13.2 使用范例查找指定时间内访问过的文件 123456&gt; find . -atime -2./Linux-文件和目录操作命令-1.md./Linux-文件和目录操作命令-find命令.md./我的VIM配置详解.md./我的VIM配置详解 查找指定时间内修改过的文件 123456789&gt; find . -mtime -5../Linux-Linux命令行简介-0.md./Linux-文件和目录操作命令-1.md./C-内存四区之栈区.md./Linux-文件和目录操作命令-find命令.md./我的VIM配置详解.md./Linux-Linux命令行简介-man命令.md./我的VIM配置详解 时间关系字符图如下: 12------------+4 4 -4---------------8 7 6 5 4 3 2 1 now -n代表从第四天到现在之内 n代表具体某一天 +n代表某一天之前 根据文件名查找指定时间的文件 12&gt; find . -mtime -1 -name &apos;*.md&apos;./Linux-文件和目录操作命令-find命令.md 根据文件类型查找目录 1234567891011121314151617181920212223242526272829&gt; find . -type d../Linux-Linux命令行简介-0./终端多窗口神器——Screen./Qt5./2008年5月12日14时28分04秒./如何自学编程./Learn-Qt5-自定义信号槽./C-内存四区之代码区与全局区./Linux./C-友元./Learn-Qt5-Qt模块简介./ManjaroLinux的安装过程./C-的命名空间与作用域./Learn-Qt5-信号槽./我儿子的博客./C-内存四区之堆区./fcitx5安装与配置./hexo-next插入网易云音乐./Linux-文件和目录操作命令-1./C-读写文件./Linux-Linux命令行简介-man命令./C-指针-基础02./Learn-Qt5-HelloWorld./常用算法-1./C-内存四区之栈区./我的VIM配置详解./解决KDE下部分应用不能使用fctix中文输入法的问题./如何用hexo-github-pages搭建博客 根据文件类型查找非目录的文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&gt; find . ! -type d./Linux-Linux命令行简介-0/1.1.2-0./fcitx5安装与配置.md./终端多窗口神器——Screen/DefalutCommandKey.png./终端多窗口神器——Screen/detachedInfo.png./Linux中的解压与压缩.md./Linux-Linux命令行简介-0.md./终端多窗口神器——Screen.md./C-内存四区之代码区与全局区.md./C-内存四区之堆区.md./2008年5月12日14时28分04秒/空降.webp./2008年5月12日14时28分04秒/操场.webp./2008年5月12日14时28分04秒/流量图.webp./hexo-next插入网易云音乐.md./如何自学编程/群组.png./Linux-文件和目录操作命令-1.md./我儿子的博客.md./解决KDE下部分应用不能使用fctix中文输入法的问题.md./C-内存四区之代码区与全局区/代码区示意图.png./C-内存四区之栈区.md./Learn-Qt5-信号槽.md./Linux-文件和目录操作命令-find命令.md./Learn-Qt5-Qt模块简介.md./C-读写文件.md./ManjaroLinux的安装过程/编辑文章时截图.png./ManjaroLinux的安装过程/分区.png./ManjaroLinux的安装过程/开始安装.png./ManjaroLinux的安装过程/安装选择界面.png./ManjaroLinux的安装过程/摘要.png./ManjaroLinux的安装过程/分区标识.png./ManjaroLinux的安装过程/桌面.png./Learn-Qt5-自定义信号槽.md./我儿子的博客/预览.png./hexo博客文章插入图片.md./C-函数探幽.md./C-内存四区之堆区/test.png./如何自学编程.md./深拷贝和浅拷贝的区别.md./ManjaroLinux的安装过程.md./fcitx5安装与配置/kcm.png./fcitx5安装与配置/输入.gif./hexo-next插入网易云音乐/01.png./hexo-next插入网易云音乐/插哪.png./2008年5月12日14时28分04秒.md./C-读写文件/二进制文件.png./C-指针-基础02/指针位偏移.png./Learn-Qt5-HelloWorld.md./ManjaroLinuxTG讨论群组.md./Learn-Qt5-HelloWorld/newProject.gif./我的VIM配置详解.md./C-友元.md./如何用hexo-github-pages搭建博客.md./Linux-Linux命令行简介-man命令.md./常用算法-1.md./C-的命名空间与作用域.md./我的Linux之路.md./2019年的规划.md./C-指针-基础01.md./C-指针-基础02.md./如何用hexo-github-pages搭建博客/创建仓库.png./如何用hexo-github-pages搭建博客/deploy.png./如何用hexo-github-pages搭建博客/逆光.jpg./如何用hexo-github-pages搭建博客/本地部署.png./如何用hexo-github-pages搭建博客/hexoinit.png./如何用hexo-github-pages搭建博客/导入密钥.png./如何用hexo-github-pages搭建博客/打开设置.png./如何用hexo-github-pages搭建博客/ssh目录.png./如何用hexo-github-pages搭建博客/设置SSH.png 根据文件或目录的权限查找文件 1234567891011121314151617181920212223242526272829&gt; find . -perm 755../Linux-Linux命令行简介-0./终端多窗口神器——Screen./Qt5./2008年5月12日14时28分04秒./如何自学编程./Learn-Qt5-自定义信号槽./C-内存四区之代码区与全局区./Linux./C-友元./Learn-Qt5-Qt模块简介./ManjaroLinux的安装过程./C-的命名空间与作用域./Learn-Qt5-信号槽./我儿子的博客./C-内存四区之堆区./fcitx5安装与配置./hexo-next插入网易云音乐./Linux-文件和目录操作命令-1./C-读写文件./Linux-Linux命令行简介-man命令./C-指针-基础02./Learn-Qt5-HelloWorld./常用算法-1./C-内存四区之栈区./我的VIM配置详解./解决KDE下部分应用不能使用fctix中文输入法的问题./如何用hexo-github-pages搭建博客 根据文件大小查找文件 12&gt; find . -size +1M./ManjaroLinux的安装过程/桌面.png 查找时忽略某个目录 123456789101112131415161718192021222324&gt; find . -path &quot;*Linux*&quot; -prune -o -type d -print../终端多窗口神器——Screen./Qt5./2008年5月12日14时28分04秒./如何自学编程./Learn-Qt5-自定义信号槽./C-内存四区之代码区与全局区./C-友元./Learn-Qt5-Qt模块简介./C-的命名空间与作用域./Learn-Qt5-信号槽./我儿子的博客./C-内存四区之堆区./fcitx5安装与配置./hexo-next插入网易云音乐./C-读写文件./C-指针-基础02./Learn-Qt5-HelloWorld./常用算法-1./C-内存四区之栈区./我的VIM配置详解./解决KDE下部分应用不能使用fctix中文输入法的问题./如何用hexo-github-pages搭建博客 查找比某个文件新，但比某个文件旧 123# 其中的!不代表取反，代表逻辑运算符非&gt; find . -newer new.txt ! -newer old.txt./verynew.txt 查找文件时使用正则表达式 12345678&gt; lstxt0.txt txt1.txt txt2.txt txt3.txt txt4.txt&gt; find . -regex &quot;.*xt&quot;./txt0.txt./txt4.txt./txt1.txt./txt2.txt./txt3.txt 对查找到的文件执行Shell命令操作 123456&gt; lstxt0.txt txt1.txt txt2.txt txt3.txt txt4.txt# 其中的&#123;&#125;代表查找到的内容，使用-exec必须在后面加上;，并且分好前要使用\，因为需要转义&gt; find . -regext &quot;.*txt&quot; -exec mv &#123;&#125; &#123;&#125;.demo \;txt0.txt.demo txt1.txt.demo txt2.txt.demo txt3.txt.demo txt4.txt.demo __对查找到的文件使用Shell命令并且使用安全模式-ok 123456&gt; find . -type f -ok rm &#123;&#125; \;&lt; rm ... ./txt1.txt.demo &gt; ? n&lt; rm ... ./txt2.txt.demo &gt; ? n&lt; rm ... ./txt4.txt.demo &gt; ? n&lt; rm ... ./txt0.txt.demo &gt; ? y&lt; rm ... ./txt3.txt.demo &gt; ? n]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-文件和目录操作命令-1]]></title>
    <url>%2F2019%2F06%2F16%2FLinux-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-1%2F</url>
    <content type="text"><![CDATA[2.0 老男孩新手成为技术大牛心法执着: 学Linux运维要有屡败屡站、不撞南墙不回头的精神。 专注: 只做一件事。两耳不闻其他事，一心只读运维书。 自信: 相信自己一定能行，未来一定可以成为技术大牛，自信是成功的基石。 心态: 保持空杯，重视基础；基础不牢，地动山摇。 2.1 pwd命令 print working diretory 查看当前路径使用pwd命令 例子: 1[evanmeek@EvanLinux ~]$ pwd 输出信息 1/home/evanmeek 选项 说明 -L 显示当前目录的逻辑路径(忽略软链接文件) -P 显示当前目录的物理路径(若有软链接则显示源文件地址) 所谓的软链接相当于快捷方式，例如~/test.txt是/test.txt的软链接，那么我们操作~/test.txt等同于操作/test.txt，详细的软链接将会在后面的ln命令讲解。 2.2 cd 切换目录 change directory 进入某个目录使用cd命令 例子: 123[evanmeek@EvanLinux ~]$ pwd[evanmeek@EvanLinux ~]$ cd /etc/sysctl.d/[evanmeek@EvanLinux /etc/sysctl.d/]$ pwd 输出信息 12/home/evanmeek//etc/sysctl.d/ 选项 说明 -P 进入目录的物理路径 -L 进入目录的逻辑路径 - 进入上次的目录 ~ 进入系统环境变量的HOME目录路径，即当前登录用户的家目录` .. 进入父目录 cd 命令如果不带任何选项和路径的话，会进入当前登录用户的家目录. 例子: 12345678[evanmeek@EvanLinux ~]$ cd Desktop[evanmeek@EvanLinux ~/Desktop]$ pwd[evanmeek@EvanLinux ~]$ cd -[evanmeek@EvanLinux ~]$ pwd[evanmeek@EvanLinux ~]$ cd /etc/systemd/[evanmeek@EvanLinux /etc/systemd/]$ pwd[evanmeek@EvanLinux /etc/systemd/]$ cd ..[evanmeek@EvanLinux /etc/]$ pwd 输出信息 1234~/Desktop/~/etc/systemd//etc/ 2.3 tree以树形结构显示目录下的内容 树形结构可以很清晰的显示出目录的父子级关系 例子: 1[evanmeek@EvanLinux ~/test]$ tree -L 1 输出信息 123456789.├── dir1│ ├── dir1_1│ └── dir2_2└── dir2 ├── dir1_1 └── dir2_26 directories, 0 files 选项 说明 -a 显示所有文件包括隐藏文件 -d 只显示目录! -f 显示每个文件的绝对路径 -i 不显示树枝 -L levelNum 显示遍历目录的层级，levelNum为层级(数字) -F 显示时根据不同文件类型在文件名结尾处显示不同的符号 例子: 显示隐藏文件 12#假设此目录下有隐藏文件[evanmeek@EvanLinux ~/tmp]$ tree -a 输出信息 1234567891011.├── dir1│ ├── dir1_1│ └── dir2_2├── dir2│ ├── dir1_1│ └── dir2_2├── .file1└── .file26 directories, 2 files 例子: 显示1级层文件完整路径，并不显示树枝 1[evanmeek@EvanLinux ~/tmp]$ tree -L 1 -fi . 输出信息 123../dir1./dir2 2.4 mkdir创建目录 make directory 创建目录使用mkdir命令 选项 说明 -p 递归创建目录，若目录已存在不会报错 -m 创建时指定目录的权限 -v 创建时显示过程信息 例子: 创建目录时显示信息 123[evanmeek@EvanLinux ~]$ mkdir -v testDir[evanmeek@EvanLinux ~]$ cd testDir[evanmeek@EvanLinux ~/testDir]$ pwd 输出信息: 1mkdir: 已创建目录 &apos;testDir&apos; 递归创建目录并且显示信息 1[evanmeek@EvanLinux ~]$ mkdir -pv father/son/test 输出信息: 123mkdir: 已创建目录 &apos;father&apos;mkdir: 已创建目录 &apos;father/son&apos;mkdir: 已创建目录 &apos;father/son/test&apos; 创建目录并且指定目录权限 12[evanmeek@EvanLinux ~]$ mkdir -m 333 -v testDir[evanmeek@EvanLinux ~]$ ls -ld testDir 输出信息: 12mkdir: 已创建目录 &apos;testDir&apos;d-wx-wx-wx 2 evanmeek evanmeek 4096 6月 17 20:15 testDir 利用特殊符号“{}”同时创建多目录及多子目录 12[evanmeek@EvanLinux ~]$ mkdir -pv father/&#123;son1/&#123;a1,a2&#125;,son2/&#123;b1,b2&#125;,son3/&#123;c1,c2&#125;&#125;[evanmeek@EvanLinux ~]$ tree father 输出信息: 1234567891011121314151617181920212223mkdir: 已创建目录 &apos;father&apos;mkdir: 已创建目录 &apos;father/son1&apos;mkdir: 已创建目录 &apos;father/son1/a1&apos;mkdir: 已创建目录 &apos;father/son1/a2&apos;mkdir: 已创建目录 &apos;father/son2&apos;mkdir: 已创建目录 &apos;father/son2/b1&apos;mkdir: 已创建目录 &apos;father/son2/b2&apos;mkdir: 已创建目录 &apos;father/son3&apos;mkdir: 已创建目录 &apos;father/son3/c1&apos;mkdir: 已创建目录 &apos;father/son3/c2&apos;father├── son1│ ├── a1│ └── a2├── son2│ ├── b1│ └── b2└── son3 ├── c1 └── c29 directories, 0 files 2.5 touch创建空文件或改变文件的时间戳属性 创建新的空文件，改变文件的时间戳属性，需要用到touch 选项 说明 -a 更改指定文件的最新访问时间 -d STRING 用字符串的方式指定一个模板作为指定文件的时间属性 -m 更改指定文件的最新修改时间 -r file 将指定文件的时间属性设置为file的时间属性 -t STAMP 使用时间格式设置文件的时间属性 例子: 创建文件 1[evanmeek@EvanLinux ~]$ touch test.txt 同时创建多个文件 1[evanmeek@EvanLinux ~]$ touch test1.txt test2.txt 利用{}批量创建文件 1[evanmeek@EvanLinux ~]$ touch t&#123;01..05&#125;.txt 利用stat命令查看时间戳 1[evanmeek@EvanLinux ~]$ stat t01.txt 输出信息 12345678File: t01.txtSize: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: 10305h/66309d Inode: 18352077 Links: 1Access: (0644/-rw-r--r--) Uid: ( 1000/evanmeek) Gid: ( 1000/evanmeek)Access: 2019-06-17 21:36:42.380004039 +0800Modify: 2019-06-17 21:36:42.380004039 +0800Change: 2019-06-17 21:36:42.380004039 +0800Birth: 2019-06-17 21:36:42.380004039 +0800 时间戳属性说明: Access 访问属性 Modify 修改属性 Birth 状态改变属性 利用-a选项修改文件最后访问属性 12[evanmeek@EvanLinux ~]$ touch -a t01.txt[evanmeek@EvanLinux ~]$ stat t01.txt 输出信息 12345678File: t01.txtSize: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: 10305h/66309d Inode: 18352077 Links: 1Access: (0644/-rw-r--r--) Uid: ( 1000/evanmeek) Gid: ( 1000/evanmeek)Access: 2019-06-17 21:44:27.210736590 +0800Modify: 2019-06-17 21:36:42.380004039 +0800Change: 2019-06-17 21:44:27.210736590 +0800Birth: 2019-06-17 21:36:42.380004039 +0800 修改文件的修改时间 12[evanmeek@EvanLinux ~]$ touch -d 20010101 t01.txt[evanmeek@EvanLinux ~]$ stat t01.txt 输出信息 12345678File: t01.txtSize: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: 10305h/66309d Inode: 18352077 Links: 1Access: (0644/-rw-r--r--) Uid: ( 1000/evanmeek) Gid: ( 1000/evanmeek)Access: 2001-01-01 00:00:00.000000000 +0800Modify: 2001-01-01 00:00:00.000000000 +0800Change: 2019-06-17 21:48:26.700992172 +0800Birth: 2019-06-17 21:36:42.380004039 +0800 修改指定文件为某文件的时间属性 123[evanmeek@EvanLinux ~]$ stat t02.txt[evanmeek@EvanLinux ~]$ touch -r t02.txt t01.txt[evanmeek@EvanLinux ~]$ stat t01.txt 输出结果 12345678File: t01.txtSize: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: 10305h/66309d Inode: 18352077 Links: 1Access: (0644/-rw-r--r--) Uid: ( 1000/evanmeek) Gid: ( 1000/evanmeek)Access: 2019-06-17 21:36:42.380004039 +0800Modify: 2019-06-17 21:36:42.380004039 +0800Change: 2019-06-17 21:51:35.907031392 +0800Birth: 2019-06-17 21:36:42.380004039 +0800 2.6 ls显示目录下的内容及相关属性信息 list directory contents 例子: 查看当前目录下的文件信息 1[evanmeek@EvanLinux ~]$ ls 输出结果 1Applications Desktop Downloads GameDir index.html Music Pictures temp WorkDir 每个人的目录里面的内容不同，所以可能不一样。 选项 说明 -l 使用长格式列出目录下的文件和信息 -a 显示目录下的所有文件，包括隐藏文件! -t 根据最新的修改时间排序，不加此参数默认是根据文件名排序! -r 反向排序 -F 在显示的条目后加上特殊符号用以区别文件类型! -p 目录后面加上“/” -i 显示inode节点信息 -d 遇到目录时，只列出目录本身，并且不跟随符号链接! -h 以人类可读的信息显示文件或目录大小 -A 列出所有文件，包括隐藏文件夹，但不包括.和.. -S 根据文件大小排序 -R 递归列出所有子目录 -x 逐行列出项目而不是逐栏列出 -X 根据扩展名排序 -c 根据状态改变时间排序 -u 根据最后访问时间排序 –color={never,always,auto} 根据文件类型显示不同颜色，never:不显示，always:总是显示，auto:表示自动显示 –full-time 以完整的时间格式进行显示 –time-style={full-iso,long-iso,iso,locale} 以不同的时间格式输出，long-iso最常用 –time={atime,ctimeA} 按不同的时间属性输出,atime:访问时间，ctime:改变权限属性时间，默认:最后修改时间 例子: 环境准备 123456[evanmeek@EvanLinux ~]$ mkdir temp[evanmeek@EvanLinux ~]$ cd temp[evanmeek@EvanLinux ~]$ mkdir -p father/dir&#123;01..02&#125;[evanmeek@EvanLinux ~]$ touch father/dir&#123;01..02&#125;/txt&#123;01..02&#125;[evanmeek@EvanLinux ~]$ touch father/dir&#123;01..02&#125;/.txt&#123;01..02&#125;[evanmeek@EvanLinux ~]$ tree -a 输出结果 1234567891011121314 . └── father ├── dir01 │ ├── .txt01 │ ├── txt01 │ ├── .txt02 │ └── txt02 └── dir02 ├── .txt01 ├── txt01 ├── .txt02 └── txt023 directories, 8 files 递归显示所有文件 1[evanmeek@EvanLinux ~/WorkDir/MyBlog/]$ ls -Ra 输出信息 1234567891011.:. .. father./father:. .. dir01 dir02./father/dir01:. .. .txt01 txt01 .txt02 txt02./father/dir02:. .. .txt01 txt01 .txt02 txt02 ls命令输出属性解释 目录内容如下： 1234567.├── dir01├── dir02├── file01.txt└── file02.txt2 directories, 2 files 长格式列出人类可读信息并显示inode信息 1[evanmeek@EvanLinux ~]$ ls -lhi 输出信息 12345total 8.0K18219052 drwxr-xr-x 2 evanmeek evanmeek 4.0K 6月 18 19:27 dir0118219053 drwxr-xr-x 2 evanmeek evanmeek 4.0K 6月 18 19:27 dir0218219054 -rw-r--r-- 1 evanmeek evanmeek 0 6月 18 19:28 file01.txt18219055 -rw-r--r-- 1 evanmeek evanmeek 0 6月 18 19:28 file02.txt 从第一列依次往后排，分别含义为: inode索引节点编号 文件类型以及属性(第一字符标注类型，后9个代表权限) 硬链接个数 文件或目录所属用户 文件或目录所属的组 文件或目录的大小 修改时间 文件名或目录名 2.7 cp复制文件或目录 copy 选项 说明 -p 复制文件时保存源文件的所有者、权限信息及时间属性 -d 如果复制的源文件是符号链接，那么仅复制符号链接本身，并且保留符号链接所只想的目标文件或目录 -r 递归复制目录，即目录下所有的子目录及文件 -a 等同于上面的p、d、r这3个选项功能的总和 -i 覆盖已有文件前提示用户确认 -t 调换命令格式，默认格式是”cp 源文件 目标文件”，将目标文件和源文件进行位置调换 例子: 环境准备 12345678910.└── fatherDir ├── sonDir1 │ └── test.txt ├── sonDir2 │ └── test.txt └── sonDir3 └── test.txt4 directories, 3 files 拷贝fatherDir为father2Dir并保留源文件的所有者，权限信息及时间属性 1[evanmeek@EvanLinux ~/temp]cp -rp fatherDir father2Dir 再次拷贝fatherDir为father2Dir从而覆盖上个例子的father2Dir 1[evanmeek@EvanLinux ~etemp]$ cp -ri fatherDir father2Dir 输出信息 123cp：是否覆盖&apos;father2Dir/fatherDir/sonDir1/test.txt&apos;？ ycp：是否覆盖&apos;father2Dir/fatherDir/sonDir2/test.txt&apos;？ ycp：是否覆盖&apos;father2Dir/fatherDir/sonDir3/test.txt&apos;？ y 2.8 mv移动或重命名文件 move | 选项 | 说明 | |——|————————————————————| | -f | 若目标文件已存在，不询问直接覆盖 | | -i | 若目标文件已存在，询问是否覆盖 | | -n | 不覆盖已存在的文件 | | -t | 交换目标文件和源文件的参数位置，常用于有多个目标目录的情况 | | -u | 源文件比目标文件新，或目标文件不存在时再移动 | 例子: 环境准备 123456总用量 4-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test0.txt-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test1.txt-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test2.txt-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test3.txtdrwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt 更换文件名 12[evanmeek@EvanMeek ~]$mv test0.txt test-1.txt[evanmeek@EvanMeek ~]$ls -l --full-time 输出信息 12345-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test-1.txt-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test1.txt-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test2.txt-rw-r--r-- 1 evanmeek evanmeek 0 2019-06-20 19:11:36.807398116 +0800 test3.txtdrwxr-xr-x 2 evanmeek evanmeek 4096 2019-06-20 19:11:55.618528975 +0800 testTxt 移动文件 1[evanmeek@EvanLinux ~]$ mv test-1.txt testTxt 移动多个文件至一个目录 1[evanmeek@EvanLinux ~]$ mv -t testTxt test1.txt test2.txt test3.txt 2.9 rm删除文件或目录 前排提示:使用rm命令时最好知道自己在干什么! remove 选项 说明 -f 强制删除并且忽略不存在文件的提示 -i 删除时需要确认 -I 删除三个以上文件或者递归删除前需要确认 -r 递归删除目录以及其内容! 例子: 再次提醒，使用此命令时最好知道自己在做什么并且检查是否写错，一旦删除无法恢复(大多数情况下可以恢复，可以通过ext3grep实现) 环境准备 1234567.├── test2Txt│ ├── test1.txt│ ├── test2.txt│ └── testTxt│ └── test-1.txt└── test3.txt 删除文件 1[evanmeek@EvanLinux ~]$ rm test3.txt 强制删除并且删除时需要确认 1[evanmeek@EvanLinux ~]$ rm -fi test2Txt/test2.txt 输出信息 1rm：是否删除普通空文件 &apos;test2Txt/test2.txt&apos;？ 删除目录并且删除时需要确认 1[evanmeek@EvanLinux ~]$ rm -ri test2Txt/testTxt 强制删除+递归删除目录 1[evanmeek@EvanLinux ~]$ rm -rf test2Txt 最后再提醒一下，如果网上有人叫你输入如下命令，请千万不要输入 1sudo rm -rf /* 这行命令的意思是:以管理员的权限强制+递归删除根目录下的所有文件,此行命令不在我们学习范围之内. 删除时的小技巧 使用mv命令代替rm命令，可以将要删除的文件暂时保存在/tmp目录下，需要清理空间时再去删除 删除前先备份，并且最好是不同机器备份，Linux可以做到若出现问题随时还原 若非要用删除命令清理空间可以选择用find代替rm 删除时尽量不要使用系统通配符 2.10 rmdir删除空目录 remove dirctory 此命令只能删除空目录 选项 说明 -p 递归删除目录，若发现子目录被删除后父目录也为空时，则一并删除。若由于部分原因，部分目录被保留，那么则会显示相应的信息 -v 删除时显示执行过程 2.11 ln硬链接与软链接 link 链接分为两种，分别是硬链接与软链接 硬链接(hard link): 不能将硬链接链接到不同文件系统的文件 硬链接不能链接目录 删除硬链接或者源文件之一并不能完全删除实体 删除实体需要删除硬链接以及起对应的源文件 硬链接相当与源文件的另外一个入口 对于静态文件来说，对应的硬链接连接的个数为0时，则代表被删除 硬链接的文件类型是普通文件(字符型) 硬链接通过索引节点进行链接 例子: 创建硬链接 1[evanmeek@EvanLinux ~]$ ln test.txt testHardFile.txt 软链接(Symbolic Link): 类似于Windows的快捷方式 文件内存放的是源文件的路径 即使删除源文件，软链接仍然存在，但无法访问源文件 源文件被删除后，软链接则失效，失效后将会有白字红底闪烁提示 软链接可以用rm命令删除 例子: 创建软链接 1[evanmeek@EvanLinux ~]$ ln -s test.txt testSyumbolicLink.txt 文件链接案例 通过一个案例演示软链接和硬链接的区别。 1234567891011121314151617181920212223242526272829[evanmeek@EvanLinux ~]$ cat testFile123# 创建硬链接[evanmeek@EvanLinux ~]$ ln testFile testFileHardLink# 创建软链接[evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink[evanmeek@EvanLinux ~]$ cat testFile testHardLink testFileSymbolicLink123123123# 删除软链接[evanmeek@EvanLinux ~]$ rm -f testFileSymbolicLink[evanmeek@EvanLinux ~]$ cat testFile testHardLink123123# 复原[evanmeek@EvanLinux ~]$ ln -s testFile testFileSymbolicLink# 删除硬链接[evanmeek@EvanLinux ~]$ rm -f testFileHardLink[evanmeek@EvanLinux ~]$ cat testFile testFileHardLink123123# 复原[evanmeek@EvanLinux ~]$ ln testFile testFileHardLink# 删除源文件[evanmeek@EvanLinux ~]$ rm -f testFile[evanmeek@EvanLinux ~]$ cat testFileHardLink testFileSymbolicLink123cat: testFileSymbolicLink: 没有那个文件或目录 硬链接可以没有源文件 软链接不行 2.12 readlink 查看符号链接文件的内容 此命令可查看链接指向的源文件的地址 选项 说明 -f 一直跟随符号链接，直到遇到一个非符号链接的文件，若不存在则不行 例子： 1[evanmeek@EvanLinux ~]$ readlink testFileSymbolicLink 2.13 find 查找目录下的文件 由于本篇篇幅较大，请点击下方超链接进行访问。 点击访问 2.14 xargs将标准输入转换成命令行参数 选项 说明 -n 指定每行命令的最大参数数量，每个参数由空格隔开 -d 自定义分割符 -i 以{}替代xargs命令之前的结果 -I 指定一个符号替代前面的结果，而不是使用默认的{} -P 提示让用户确认是否执行后面的命令，y执行，n不执行 -0 用null替代空格作为分割符，配合find命令的-printf0选项的输出使用 2.14.2使用范例 多行输入变单行 1234567&gt; cat test.txt1 2 3 4 5 6 78 91 &gt; xargs &lt; test.txt1 2 3 4 5 6 7 8 9 1 通过-n指定每行的输出个数 123456&gt; xargs -n 2 &lt; test.txt1 23 45 67 89 1 自定义分隔符(使用-d功能) 123456&gt; echo 123I321I809I098123I321I809I098&gt; echo 123I321I809I098|xargs -d I -n 2123 321890 098 指定一个替换字符串 123456# 将查找出来的结果删除# 先将结果传给&#123;&#125;# 再会被删除&gt; find . -name &quot;*.log&quot;|xargs -i rm -rf &#123;&#125;# 自定义替换字符串&gt; find . -name &quot;*.log&quot;|xargs -I [] rm -rf [] 2.15 rename重命名 rename通过替换字符串的方式批量修改文件名 语法格式 1rename from to file 例子: 批量修改文件名 12345&gt; lstest_demo_0 test_demo_1 test_demo_2 test_demo_3 test_demo_4 test_demo_5&gt; rename &quot;_demo&quot; &quot;&quot; *&gt; lstest_0 test_1 test_2 test_3 test_4 test_5 批量修改文件扩展名 12345&gt; lstest0.txt test1.txt test2.txt test3.txt test4.txt test5.txt&gt; rename .txt .demo *&gt; lstest0.demo test1.demo test2.demo test3.demo test4.demo test5.demo 2.16 basename显示文件名或目录名 basename命令用于显示去除路径和文件后缀的文件名或目录名 语法格式 1basename [&lt;文件或目录&gt;] [后缀] 其中的后缀为可选 例子: 只显示文件名和后缀，不显示完整路径 1234&gt; mkdir -p dir1/dir2/&gt; touch dir1/dir2/test.txt&gt; basename dir1/dir2/test.txttest.txt 只显示文件名，不显示完整路径制定不显示某个后缀 123&gt; touch dir1/dir2/test.demo.txt&gt; basename dir1/dir2/test.demo.txt .txttest.demo 2.17 dirname显示文件或目录的路径 dirname命令用于只显示文件或目录的路径 语法格式 1dirname [&lt;文件或目录&gt;] 例子: 12&gt; dirname dir1/dir2/test.txtdir1/dir2 2.18 chattr改变文件的扩展属性 charttr命令用户改变文件的扩展属性，相比chmod命令不同的是，chmod只是改变文件的读写执行权限，而更底层的权限属性控制是由charttr来改变的． 语法格式 1chattr [选项] [模式] [&lt;文件或目录&gt;] 提示:lsattr命令可以查看文件的属性 选项 说明 -R 递归更改目录属性 -V 显示执行过程 mode + 增加参数 - 移除参数 = 更新为指定参数 A 指定文件的最后访问时间不可修改 a 指定文件只能添加数据，无法删除数据! ! 指定文件不能被删除，重命名，写入或新增内容 例子： 给文件加锁，使其只能为只读 1234567&gt; chattr +i test.txt&gt; lsattr test.txt----i---------e----- test.txt&gt; echo a1111 &gt; test.txtzsh: 不允许的操作: test.txt&gt; echo b2222 &gt;&gt; test.txt zsh: 不允许的操作: test.txt 给文件解锁 123456&gt; charttr -i test.txt&gt; lsattr test.txt--------------e----- test.txt&gt; eco 111 &gt; test.txt&gt; cat test.txt111 2.19 lsattr查看文件扩展属性 lsattr命令用于查看文件扩展属 语法格式 1lsattr [选项] [&lt;文件或目录&gt;] 选项 说明 -R 递归查看目录的扩展属性 -a 显示所有文件的扩展属性 -d 显示目录的扩展属性 例子: 查看文件的扩展属性 12345&gt; lsattr test.txt--------------e----- test.txt&gt; chattr +i test.txt&gt; lsattr test.txt----i---------e----- test.txt 查看目录的扩展属性 12345&gt; lsattr -d testDir--------------e----- testDir&gt; chattr +i testDir&gt; lsattr -d testDir----i---------e----- testDir 2.20 file显示文件的类型 file命令用于显示文件的类型 语法格式 1file [选项] [&lt;文件或目录&gt;] 选项 说明 -b 输出信息使用精简格式 例子: 查看文件类型 12345&gt; file test.txttest.txt: empty&gt; file *test.txt: emptytest.txt.link: symbolic link to test.txt 2.21 md5sum计算和校验文件的MD5值 md5sum命令用于计算和校验文件的MD5值. 语法格式 1md5sum [选项] [文件] 选项 说明 -b 二进制模式读取文件 -c 从指定文件中读取MD5校验值，并进行校验 -t 文本模式读取文件，默认 –quiet 校验文件时，若通过不输出OK –status 校验文件时，不输出任何信息，但可通过命令的返回值判断 例子: 生成一个文件的MD5值 12&gt; md5sum test.txtd41d8cd98f00b204e9800998ecf8427e test.txt 校验文件MD5值是否发生改变 123456789101112&gt; md5sum test.txt &gt; md5.log&gt; cat md5.logd41d8cd98f00b204e9800998ecf8427e test.txt&gt; md5sum -c md5.logtest.txt: 成功&gt; echo &quot;update&quot; &gt;&gt; test.txt&gt; md5sum -c md5.logtest.txt: 失败md5sum: 警告：1 个校验和不匹配&gt; md5sum --status -c md5.log&gt; echo $?1 2.22 chown改变文件或目录的用户和用户组 chown命令用于改变文件或目录的用户和用户组 语法格式 1chown [选项] [用户:用户组] [&lt;文件或目录&gt;] 选项 说明 -R 递归更改目录的用户和用户组 例子: 更改文件所属的用户属性 12345678&gt; ls -l test.txt-rw-r--r-- 1 root root 5 6月 27 00:31 test.txt# 授予权限的用户必须存在&gt; chown xxx test.txtchown: 无效的用户: “xxx”&gt; chown evanmeek test.txt&gt; ls -l test.txt-rw-r--r-- 1 evanmeek root 5 6月 27 00:31 test.txt 更改文件所属用户组的属性 1234567&gt; ls -l总用量 4.0K-rw-r--r-- 1 evanmeek evanmeek 5 6月 27 00:34 test.txt&gt; chown .root test.txt&gt; ls -l总用量 4.0K-rw-r--r-- 1 evanmeek root 5 6月 27 00:34 test.txt 同时更改文件的用户和用户组属性 1234&gt; chown evanmeek:evanmeek test.txt&gt; ls -l总用量 4.0K-rw-r--r-- 1 evanmeek evanmeek 5 6月 27 00:34 test.txt 递归更改目录下所有文件及目录的用户和用户组属性 12345678910111213141516&gt; tree.├── dir0│ └── test.txt├── dir1│ └── test.txt└── dir2 └── test.txt3 directories, 3 files&gt; chown -R root:root .&gt; ls -l总用量 12Kdrwxr-xr-x 2 root root 4.0K 6月 27 01:14 dir0drwxr-xr-x 2 root root 4.0K 6月 27 01:14 dir1drwxr-xr-x 2 root root 4.0K 6月 27 01:14 dir2 2.23chmod改变文件或目录权限 只有文件的属主以及超级用户root才能执行此命令 语法格式 1chmod [选项] [模式] [&lt;文件或目录&gt;] 选项 说明 -R 递归指定目录以及子目录的权限 权限对应表 权限位 全称 含义 对应数字 r read 可读权限 4 w write 可写权限 2 x execute 可执行权限 1 - 没有任何权限 0 备注 一些特殊权限位:t,T,s,S,x,X 用户类型 文件所属用户:u(OwnerUser) 用户类型 文件所属用户组:g(Group) 用户类型 其他用户:o(Other) 用户类型 所有:a(ALL),等效于u,g,o的总和 操作字符 +:添加/-:减去/=:设置 例子: 权限字母和操作符表达式 123456789101112131415&gt; ls -l总用量 4-rw-r--r-- 1 evanmeek evanmeek 4 6月 25 17:43 test.txt# 给文件所属用户减去可写权限&gt; chmod u-w test.txt# 给用户所属用户组减去可读权限&gt; chmod g-r test.txt&gt; ls -l总用量 4.0K-r-----r-- 1 evanmeek evanmeek 4 6月 25 17:43 test.txt# 给所有用户以及用户组都设置为可读可写可执行的权限&gt; chmod a=rwx test.txt&gt; ls -l总用量 4.0K-rwxrwxrwx 1 evanmeek evanmeek 4 6月 25 17:43 test.txt 使用数字更改文件或目录权限 先举个例子，有这么一个文件 1-rw-rw---- 1 evanmeek evanmeek 4 6月 25 17:43 test.txt 权限示意图 1234前三个字符代表文件属主的权限中间三个字符代表文件属组的权限后三个字符代表其他用户的权限-rw-rw---- evanmeek evanmeek test.txt 我们将每三个字符为一组将其权限位对应的数字加起来，代表这个文件的数字权限，例如上面的这个文件它的数字权限就是:660 因为(-+r+w)(-+r+w)(-+-+-)等价于(0+4+2)(0+4+2)(0+0+0)=660 1234# 将test.txt文件的所有用户权限设置为可读可写可执行&gt; chmod 777 test.txt&gt; ls -l---------- 1 evanmeek evanmeek 4 6月 25 17:43 test.txt 使用数字递归更改文件或目录的权限 123456789101112131415161718&gt; tree.├── dir0│ └── file.txt├── dir1│ └── file.txt└── dir2 └── file.txt&gt; ls -l总用量 12Kdrwxr-xr-x 2 evanmeek evanmeek 4.0K 6月 28 20:59 dir0drwxr-xr-x 2 evanmeek evanmeek 4.0K 6月 28 20:59 dir1drwxr-xr-x 2 evanmeek evanmeek 4.0K 6月 28 20:59 dir2&gt; chmod -R 777 dir&#123;0..2&#125;总用量 12Kdrwxrwxrwx 2 evanmeek evanmeek 4.0K 6月 28 20:59 dir0drwxrwxrwx 2 evanmeek evanmeek 4.0K 6月 28 20:59 dir1drwxrwxrwx 2 evanmeek evanmeek 4.0K 6月 28 20:59 dir2 Linux普通文件的读，写，执行权限说明 | 权限 | 说明 | |———|—————————-| | 可读r | 表示具有读取文件内容的权限 | | 可写w | 表示具有修改文件内容的权限 | | 可执行x | 表示具有执行文件的权限 | 可写w 如果文件没有可读权限r，使用vi编辑器，执行vi命令wq!可以强制覆盖，但源文件会内容会被清除．所以我们可以使用echo &gt;&gt; 的方式进行追加. 删除文件(修改文件)的权限是受父目录的权限控制，和文件本身无关，文件名在父目录的block里 可执行x 要求文件本身是可执行的 普通用户必须要有r权限才能够执行 root用户即使没有r权限，只需要有x权限即可执行 不管root用户位有没有执行权限，只要其他用户位有x执行权限，那么都可被root执行 Linux目录的，写，执行权限说明| 权限 | 说明 ||———|——————————————–|| 可读r | 表示具有浏览目录下文件以及子目录的权限 || 可写w | 表示具有增加，删除或修改目录内文件名的权限 || 可执行x | 表示具有进入目录的权限 | 可读r 没有x权限不能进入至目录内 ls列表可以看到所有文件名，不过会提示无法访问目录下的文件 如果ls -l列表，则所有的属性会带有文件，也会提示无权限访问目录下的文件，但是可以看到文件名 可写w 增加的不是文件内容，而是创建新文件 修改的不是文件内容(根据文件本身权限的不同)，只能修改文件名， 删除也是删除文件，而不是看文件本身的权限，是看目录的权限，如果没有x权限则不能删除 可执行权限x 没有可读权限r则不能进入目录 没有可写权限w则无法创建新文件 2.24 chgrp更改文件用户组 此命令被chown取代，用法和参数都和chown命令相同 2.25 umask显示或设置权限掩码 umask是通过八进制的数值来定义用户创建文件或目录的默认权限 语法格式 1umask [选项] [模式] 选项 说明 -p 输出的权限掩码可直接作为命令来执行 -S 以字符的方式输出权限掩码 2.25.2 通过umask计算文件目录权限 文件权限的计算 创建文件默认的最大权限为666，也就是说没有可执行权限x. umask文件权限的计算方式是，将文件的数字权限与umask(系统设置的权限值)相减，如果得到的数字有一位是偶数，那么则为最终结果，如果为奇数，那么需要将奇数位+1变成偶数，得到最终的结果。 例子: 假如umask值为:022，那么: 1234 6 6 6 文件默认的权限 0 2 2 umask值- ===== 6 4 4 都为偶数，最终结果为644 假如umask值为:045，那么: 1234567 6 6 6 文件默认的权限 0 4 5 umask值- ===== 6 2 1 其他用户权限位为奇数，所以+1 0 0 1+ ===== 6 2 2 都为偶数，最终结果为622 目录权限的计算 目录权限的计算没有奇偶之分 创建目录是默认的最大权限为777(-rwx-rwx-rwx) 计算方法和文件权限计算方法相同 例子: 假如umask值为:022，那么: 1234 7 7 7 目录默认最大权限 0 2 2 umask值- ===== 7 5 5 得到最终结果 查看系统默认的umask值 123456# 普通用户的默认umask值evanmeek &gt; umask022# 超级用户的默认umask值root &gt; umask0022 -S参数的使用 12&gt; umask -Su=rwx,g=rx,o=rx -p参数的使用 12&gt; umask -pumask 0022 临时修改umask值 1234567891011# 修改umask之前&gt; umask&gt; ls -l file1-rw-r--r-- 1 evanmeek evanmeek 0 6月 30 19:11 file1# 修改umask之后&gt; umask 044&gt; umask044&gt; touch file2&gt; ls -l file1-rw--w--w- 1 evanmeek evanmeek 0 6月 30 19:12 file2 永久修改umask值 若无特殊需求，请不要修改umask值，系统默认的umask值是系统安全的临界点，也是最合适的。 编辑/etc/profile或者/etc/bashrc 找到umask项修改即可]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Linux命令行简介-man命令]]></title>
    <url>%2F2019%2F06%2F15%2FLinux-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E4%BB%8B-man%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本篇文章为Linux系列的第1章 Linux命令行简介 1.2小节的外部展示。 1.2.1 使用man获取命令帮助信息man命令的作用: 查看命令的使用帮助 查看软件服务配置文件 查看系统调用信息 查看C库函数帮助信息 man命令的使用: 1man 参数选项 命令/文件 man命令可选参数: 参数 英文说明 中文说明 1 User Commands 用户命令相关 2 System Calls 系统调用相关 3 C Library Functions C的库函数相关 4 Devices and Special Files 设备与特殊文件相关 5 File Formats and Conventions 文件格式和规则 6 Games et. Al. 游戏及其他 7 Miscellanea 宏，包及其他杂项 8 System Admin tools and Deamons 系统管理员命令和进程 例子: 1234# 查看cp命令的使用帮助man cp# 查看C语言printf函数的使用帮助man 3 printf man命令信息的格式 标签 说明(!表示重点) NAME 命令说明及介绍! SYNOPSIS 命令的基本使用语法! DESCRIPTION 命令的详细描述，有的命令会单独使用标签介绍COMMANDS LINE OPTION或OPTIONS! OPTIONS 命令参数选项说明 COMMANDS 执行某个软件时可附加的软件的命令 FILES 程序涉及的相关文件 EXAMPLES 命令的例子! SEE ALSO 命令相关信息的说明 BUGS(REPORTING BUGS) 命令对应缺陷问题的描述 COPYRIGHT 版权信息相关声明 AUTHOR 作者介绍 man命令信息操作键 操作键 功能说明 Page Down 向下翻页 Page Up 向上翻页 Home 跳转到第一页 End 跳转到最后一页 / 向下查找某个字符 ? 向上查找某个字符 n,N 当使用向上查找，那么n则为下一个，N为上一个。当使用向下查找，那么则取反 q 结束本次man帮助 1.2.2 使用–help参数获取命令帮助信息 例子: 1[evanmeek@EvanLinux ~]$ ls --help 输出如下: 123456789用法：ls [选项]... [文件]...列出给定文件（默认为当前目录）的信息。如果不指定 -cftuvSUX 中任意一个或--sort 选项，则根据字母大小排序。必选参数对长短选项同时适用。-a, --all 不隐藏任何以. 开始的项目-A, --almost-all 列出除. 及.. 以外的任何项目 --author 与-l 同时使用时列出每个文件的作者-b, --escape 以八进制溢出序列表示不可打印的字符 1.2.3 使用help命令获取命令帮助信息 例子: 1[evanmeek@EvanLinux ~]$ help cd 输出如下: 123456789101112cd: cd [-L|[-P [-e]] [-@]] [目录] 改变 shell 工作目录。 改变当前目录至 DIR 目录。默认的 DIR 目录是 shell 变量 HOME 的值。 变量 CDPATH 定义了含有 DIR 的目录的搜索路径，其中不同的目录名称由冒号 (:)分隔。 一个空的目录名称表示当前目录。如果要切换到的 DIR 由斜杠 (/) 开头，则 CDPATH 不会用上变量。 如果路径找不到，并且 shell 选项 `cdable_vars' 被设定，则参数词被假定为一个 变量名。如果该变量有值，则它的值被当作 DIR 目录。 1.2.4 使用info获取帮助信息 例子: 1[evanmeek@EvanLinux ~]$ info cd 即可打开cd的文档信息，操作跟man的使用方式相似。 1.2.5 从互联网搜索获取命令帮助信息 Google Bing Github StackOverFlow]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Linux命令行简介-0]]></title>
    <url>%2F2019%2F06%2F15%2FLinux-Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E4%BB%8B-0%2F</url>
    <content type="text"><![CDATA[1.1 Linux命令行概述1.1.1 Linux命令行的作用与意义 Linux命令行相比图形界面操作的优点: 快速 批量 自动化 智能化管理 1.1.2 Linux命令行介绍 大多数互联网企业在使用Linux不会安装图形界面，而是才用文本模式（命令行）的方式进行使用，如图: 1.1.3 Linux命令行的开启及退出 主机开机时，Linux将会进行初始化等各种操作，最终将进入命令行，想使用必须先登录。 12user login:_password:_ 等待你输入用户名密码，密码输入时是不会显示的。 使用exit,logout或者Ctrl+d快捷键可退出登录，若退出则需要重新登录才会被允许使用Shell命令。 1.1.4 Linux命令行提示符介绍 Linux命令提示符分为两种，分别是: $普通用户 #超级管理员(root) 例子: 12[evanmeek@EvanLinux ~]$:_[root@EvanLinux ~]#:_ 其中@前面的为当前登录的用户名(username),@后面的为主机名(hostname)，主机名后面的~为路径，代表了home目录，而$或#分别代表了用户的是超级管理员还是普通用户。 超级管理员从此以后本系列都以root代表。 root与普通用户的区别： root 拥有管理整个系统的权限。 普通用户 权限较少，通常只有查看系统文件的权限，以及管理自身home目录下所有文件的权限。 查看当前登录的用户名:使用whoami查询查看主机名:使用hostname查询 额外技巧: Linux命令提示符由PS1环境变量控制，通过修改PS1环境变量，可以让提示符发生变化，例子如下: 12[evanmeek@EvanLinux ~]$ set|grep PS1PS1='[\u@\h \W]\$' PS1有特殊的变量可供选择，我们可以设置全局配置文件/etc/bashrc或/etc/profile`进行按需配置。 1.1.5 Linux命令行常用快捷键 企业工作中，管理Linux通常使用远程连接工具连接到Linux，常见的工具有: SecureCRT和XShell,以下快捷键可在此两款软件中使用。 记住常用的快捷键有利于提高效率，常用快捷键由!标注 快捷键 功能说明(!为常用) 最有用的快捷键 tab 命令或路径的补全键，Linux最有用的快捷键! 移动光标快捷键 Ctrl+a 移动光标至行首! Ctrl+e 移动光标至行尾! Ctrl+f 光标向右移动一个字符(等价与方向键右键) Ctrl+b 光标向左移动一个字符(同上) 剪切、粘贴、清楚快捷键 Ctrl+Insert 复制命令行内容! Shift+Insert 粘贴命令行内容! Ctrl+k 剪切(删除)光标处至行尾的字符! Ctrl+u 剪切(删除)光标处至行首的字符! Ctrl+w 剪切(删除)光标前一个单词! Ctrl+y 粘贴上面三个剪切(删除)的字符 Ctrl+c 终止终端正在执行的任务或删除整行字符! Ctrl+h 删除光标前一个字符(等同于Backspace)! 重复执行命令快捷键 Ctrl+d 退出当前Shell命令行! Ctrl+r 搜索命令历史记录! Ctrl+g 退出搜索命令历史记录 控制快捷键 Ctrl+l 清屏(等同于clear命令)! Ctrl+s 锁定终端，使之无法输入 Ctrl+q 解锁锁定终端 Ctrl+z 暂停执行终端运行中的任务! !开头的快捷键命令 !! 执行上一条命令 !pw 执行最近一次以pw开头的命令! !pw:p 打印输出最近以pwd开头的命令，不执行 !num 执行历史命令列表的第num(数字)条命令! !$ 上一条命令的最后一个参数，等同于Esc+. ESC相关 Esc+. 获取上一条命令的最后部分! Esc+b 移动到当前单词的开头 Esc+f 移动到当前单词的结尾 1.2 在Linux命令行下查看命令帮助 man命令是Linux很重要的一个命令，它可以帮助我们查看命令的使用方法和一些信息。 由于篇幅较大，请点击链接单独查看本章附录man命令。 点击访问 1.3 Linux关机、重启、注销命令 关机或重启命令:shutdown 参数选项 说明 -r 重启机器 -P 关闭机器电源(默认) -H 暂停机器，CPU停止工作但不断电 -h 等效-P，除非使用了-H -k 只发送关机提示,不做任何操作 -c 取消关机 例子: 12345678# 立即关机[evanmeek@EvanLinux ~]$ shutdown -h now# 立即重启 [evanmeek@EvanLinux ~]$ shutdonw -r now# 5分钟后关机[evanmeek@EvanLinux ~]$ shutdown -h +5# 1分钟后重启[evanmeek@EvanLinux ~]$ shutdown -r +1 重启或关机命令:halt/poweroff/reboot halt和poweroff都是reboot的链接而已。 reboot和shutdown都是systemctl的链接 本章完，如果觉得我的笔记整理的好，可以给我个打赏，你的一块钱是对我最大的鼓励!]]></content>
      <categories>
        <category>Linux系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fcitx5安装与配置]]></title>
    <url>%2F2019%2F06%2F14%2Ffcitx5%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[某天下午，我在Telegram群组里受人安利Fcitx5,今晚正好有空，所以就安装了个试试，还挺好的。(抱歉，文章标题一直写错了..直到这篇博客被人看到提醒我才发现..) 所需安装的软件包: fcitx5-git 输入法基础框架主程序 fcitx5-chinese-addons-git 简体中文输入的支持，云拼音 fcitx5-gtk-git gtk 程序的支持 fcitx5-qt4-git qt4 的支持 fcitx5-qt5-git qt5 的支持可能还需要： kcm-fcitx5-git 如果你用的是 KDE ，请装这个 fcitx5-rime-git 繁體中文輸入 RIME 中州韻輸入法引擎 如果你是KDE桌面环境可以直接使用kcm-fcitx5-git配置输入法: 否则将改配置文件~/.config/fcitx5/profile 12345678910111213141516171819202122[Groups/0]# Group NameName=Default# LayoutDefault Layout=us# Default Input MethodDefaultIM=pinyin[Groups/0/Items/0]# NameName=keyboard-us# LayoutLayout=[Groups/0/Items/1]# NameName=pinyin# LayoutLayout=[GroupOrder]0=Default 若没有fcitx5这个目录，则先打开一次fcitx5，再关闭，因为fcitx5关闭时会覆盖此文件。 由于fcitx5不能自动启动，我们需要添加环境变量 将如下内容添加到~/.xprofile 1fcitx5 &amp; 然后再将如下内容添加到~/.pam_environment`，没有则创建 123GTK_IM_MODULE=fcitx5XMODIFIERS=@im=fcitxQT_IM_MODULE=fcitx5 KDE用户可以直接在系统设置模块-自动启动设置 默认的皮肤很丑，我们可以使用这个fcitx5-simple-theme 然后你就可以把fcitx4给删了…]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>fcitx5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn-Qt5-Qt模块简介]]></title>
    <url>%2F2019%2F06%2F12%2FLearn-Qt5-Qt%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Qt5分为两个大的模块，分别是Qt Essentials以及Qt Add-Ons以及一些额外的模块和工具． Qt EssentialsQt Essentials是Qt的基础，它可以在所有平台上运行，下面列出了Qt Essentials模块的组件． 模块 简述 Qt Core 其他非图形类模块所使用的核心, Qt GUI 图形界面组件的基类，包括了OpenGL. Qt Multimedia 音频，视频，广播和摄像头相关功能. Qt Network 提供跨平台的网络能力． Qt Qml 提供QML使用的C++API. Qt Quick 允许在Qt/C++程序中嵌入 Qt Quick Qt SQL 允许使用SQL访问数据库 Qt Test 提供Qt程序的单元测试能力｜ Qt Webkit 基于WebKit2的实现以及一套全新的QML API Qt Add-OnsQt Add-Ons是Qt的扩展模块，建立在基础模块之上，在能运行Qt的平台之上可以酌情引人． 模块 简述 Qt 3D 提供声明式语法，在Qt程序中可以简单地嵌入3D图像．｜ Qt Bluetooth 提供用于访问蓝牙无线设备的C++和QML API. Qt Contacts 用于访问地址薄或联系人数据库的C++和QML API. Qt D-Bus Unix平台独有的类库，用于使用D-Bus协议进与进程间进行交互 Qt Graphical Effects 提供一系列用于实现图像特效的类 Qt Image Formats 支持图片格式的一系列插件 Qt JS Backend 为V8 JavaScript引擎的移植，仅供QtQML模块内部使用 Qt Location 方便在Qt应用程序中使用OpenGL，保留于Qt4 Qt Organize 使用QML和C++API访问组织事件｜ Qt Print Support 提供对打印功能的支持｜ Qt Publish and Subscribe 为应用程序提供对项目值的读取，导航，订阅等功能. Qt Quick 1 从Qt4移植而来的Qt Declarative模块，用于提供与Qt4兼容 Qt Script 提供脚本化机制，为了与Qt5兼容 Qt Script Tools 为了使用Qt Script模块的应用程序提供的额外的组件 Qt Sensors 提供访问各类传感器的QML和C++接口. Qt Service Framework 提供客户端发现其他设备的服务. Qt SVF 提供渲染和创建SVG文件的功能． Qt System Info 提供一套API，用于发现系统相关的信息. Qt Tools 提供了Qt开发的方便工具,例如Qt CLucene,Qt Designer,Qt Help以及Qt UI Tools. Qt Versit 提供了对Versit API的支持． Qt Wayland 仅用于Linux平台，用户替代QWS Qt WebKit 从Qt4 一直来的基于WebKit1和QWidget的API Qt Widgets 使用C++扩展的Qt Gui模块，提供了一些界面组建，比如按钮，单选框 Qt XML SAX和DOM的C++实现．此模块已凉凉，更换为QXmlStreamReader/Writer Qt XML Patterns 提供对XPath,XQuery,XSLT和XML Schema验证的支持．]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>C_++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn-Qt5-自定义信号槽]]></title>
    <url>%2F2019%2F06%2F11%2FLearn-Qt5-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[上一篇信号槽的学习，我们分析了QObject::connect()函数，使用connect()可以让我们连接Qt提供的信号，但Qt的信号槽机制还允许我们自定义的信号和槽，使得我们的程序更加的健壮，具有解耦性． 我们通过一个新闻和订阅者的例子讲解典型的观察者模式． 有一个报纸类Newspaper，有一个订阅者类Subscriber，Subscriber可订阅Newspaper，订阅后若Newspaper有了新内容，那么Subscriber则会立即得到通知． 上面这个案例的观察者是Subscriber，被观察者则是Newspaper．在实现代码时，观察者会将自身注册自被观察者的一个容器中．被观察者发生了任何变化时，便会通知这个容器的所有观察者． 下面，我们将用Qt的信号槽实现上面的的案例． 12345678910111213141516171819202122232425262728293031323334353637383940414243//newspaper.h#include &lt;QObject&gt;class NewsPaper : public QObject &#123; Q_OBJECTpublic: NewsPaper(const QString &amp;name) : m_name(name) &#123;&#125; void send() &#123; emit newPaper(m_name); &#125;signals: void newPaper(const QString &amp;name);private: QString m_name;&#125;;//reader.h#include &lt;QObject&gt;class Reader : public QObject &#123; Q_OBJECTpublic: void receiverNewsPaper(const QString &amp;name)&#123; qDebug()&lt;&lt;"Newpaper:"&lt;&lt;name; &#125;&#125;;//main.cpp#include &lt;QCoreApplication&gt;#include &lt;newspaper.h&gt;#include &lt;reader.h&gt;int main(int argc, char *argv[]) &#123; QCoreApplication a(argc, argv); NewsPaper paper("xx与xxx结婚了!"); Reader reader; QObject::connect(&amp;paper, &amp;NewsPaper::newPaper, &amp;reader, &amp;Reader::receiverNewsPaper); paper.send(); return a.exec();&#125; 运行结果: 1Newpaper:xx与xxx结婚了! 我们看到Reader类和Newspaper类都继承了QObject 类，在Qt中，只有继承了QObject类的类才具有信号槽的能力．凡是Object类还是它的派生类或者是间接派生类，都应该在类体的第一行代码写上Q_OBJECT．这是一个宏，它为我们的类提供了信号槽额机制，国际化机制，以及Qt提供的反射能力（非C++ RTTI)．你可能会认为假如你的类不需要使用信号槽则不添加这个宏，那是错误的，因为它不仅仅提供了信号槽的能力，还有很多操作都依赖于这个宏．目前，只需要知道我们要将这个宏加在头文件内． 再看Newspaper类，它的代码很简单，只不过是加了一个signals关键字，signals所列出的块就是该类的信号．信号就是一个个的函数名，返回值为void，参数是该类需要让外界知道的数据. Newspaper类的send()函数比较简单，只有一条语句emit newPaper(m_name);. emit是Qt对C++的一个扩展关键字，但实际上也是一个宏．emit的翻译是发出，也就是发出newPaper()信号．如果有接受者关注这个信号， 那么还需要知道是哪条新闻发出的信号，所以我们将实际的新闻名字m_name以参数传递的方式给这个信号，当接收者收到这个信号时，就可通过槽函数获得实际的值，这样也就完成了数据从发出者到接受者的一个转移． Reader类是接受信号的，所以我们也需要继承QObject，并且添加Q_OBJECT宏．其他的代码则是默认构造函数和一个普通的成员函数．在Qt5中，任何成员函数,static函数,全局函数和Lamabda表达式都可以作为槽函数．槽函数其实也就是普通的成员函数，因此作为成员函数，也会收到public,private等访问控制符的影响．信号也会收到影响，因为如果信号是private的，那么这个信号就不能在类的外面使用，也就没有了意义． main函数中，我们首先创建了Newspaper和Reader两个独享，然后使用QObject::connect()函数．这个然后我们调用Newspaper的send()函数．这个函数只有一个语句：发出信号．由于我们将Newspaper的信号和Reader的槽函数进行了连接，当这个信号发出时，那么将会自动调用Reader的槽函数． 总结自定义信号槽需要注意的事项: 发送者和接收者都需要的是QObject的子类，若草函数是全局函数，Lambda表达式等其他无需接受者则除外． 使用signals标记信号函数，信号是一个函数声明，返回void，不需要实现函数代码； 使用emit发送信号 使用QObject::connect()函数连接信号和槽.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn-Qt5-信号槽]]></title>
    <url>%2F2019%2F06%2F10%2FLearn-Qt5-%E4%BF%A1%E5%8F%B7%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[信号槽是Qt的一个很重要的特性，掌握信号槽是学好Qt的必要条件之一. 信号槽，我们可以理解为监听模式或者是观察者模式，当Qt的某个事件发生后，那么它就会发出一个信号，例如一个按钮(button)被点击(clicked)，那么它会发出一个信号. 但是这种信号是毫无目的的，但是如果我们使用连接(connect)函数，那么就可以使用由我们定义的函数(槽slot)来处理这个信号． 简而言之则是，当某个信号发出，被连接的槽函数则会被回调，这就是观察者模式；当这个信号有来连接的槽函数，那么某个操作则会被触发． 下面看代码: 123456789101112#include &lt;QApplication&gt;#include &lt;QDebug&gt;#include &lt;QPushButton&gt;int main(int argc, char *argv[]) &#123; QApplication a(argc, argv); QPushButton button("Quit"); QObject::connect(&amp;button, &amp;QPushButton::clicked, &amp;QApplication::quit); button.show(); return a.exec();&#125; 编译运行后，我们将会看到一个显示文本为Quit的Button，当我们点击它则会退出这个应用程序． 下面我们分析一下QObject::connect这个函数. 首先它拥有以下几种重载 123456789101112131415161718QMetaObject::Connection connect(const QObject *, const char *, const QObject *, const char *, Qt::ConnectionType);QMetaObject::Connection connect(const QObject *, const QMetaMethod &amp;, const QObject *, const QMetaMethod &amp;, Qt::ConnectionType);QMetaObject::Connection connect(const QObject *, const char *, const char *, Qt::ConnectionType) const;QMetaObject::Connection connect(const QObject *, PointerToMemberFunction, const QObject *, PointerToMemberFunction, Qt::ConnectionType)QMetaObject::Connection connect(const QObject *, PointerToMemberFunction,Functor); 每种重载的返回值都是QMetaObject::Connection，这里暂时不讨论，先让我们看看connect函数最常用的用法: 1connect(sender,signal,receiver,slot); connect一般会接受前四个参数，第一个sender是发出信号的对象，第二个signal是sender发出的信号,第三个是接收信号的对象，第四个是receiver接收信号之后需要调用的参数． 简而言之，当sender对象发出signal信号由receiver对象接受再调用slot函数． 根据这个常用的形式，我们可以依次分析connect的重载． 第一种 sender类型为常量QObject指针，signal为常量字符指针，receiver为常量Object指针，slot为常量字符指针，signal和slot都被作为字符串进行处理． 第二种 sender和receiver仍为常量Object指针，然而signal和slot则为QMetathod引用，由此我们可以对signal和slot进行比较 第三种 sender仍为const Object，而signal和slot则是const char，这里的reveiver被省略了，它由this指针代替. 第四种 sender和receiver仍为const Object *，而signal和slot则为PointerToMemberFunction，看其名知其意，PointerToMemberFunction则是一个指向成员函数的指针． 第五种 注意最后的Functor参数，它可以接收，static函数，全局函数以及Lambda表达式. 经过我们的分析，可以看出，connect()函数的参数里，sender和receiver没有什么区别，都是QObject指针，主要只有signal和slot的形式区别． 信号槽要求信号和槽的参数一致.一致也就是说，参数类型一致．如果不一致，只有槽函数的参数比信号的少的情况才允许，即使是这样，槽函数的参数列表的顺序也必须和信号参数一致．这是因为，你可以使槽函数忽略信号传的参数，但是不能说信号没有这个数据．]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年的规划]]></title>
    <url>%2F2019%2F06%2F09%2F2019%E5%B9%B4%E7%9A%84%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[2019年已过半，今晚正好想整理下自己完成的2019年目标，顺便把自己2019年的目标分享在博客。 书籍《标准C++入门与编程实践》————————————————————已读完《Linux系统管理完全手册》————————————————————在读《Vim实用技巧》——————————————————————————————未读《计算机网络教程》———————————————————————————未读《Qt5编程入门》——————————————————————————————在读 想学但未学Adobe PhotoshopAdobe AfterEffectsAdobe Primiere 生活想多拿起相机拍拍美好的世界， 想找个女朋友， 想减肥， 想写操作系统….]]></content>
      <categories>
        <category>分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Learn-Qt5-HelloWorld]]></title>
    <url>%2F2019%2F06%2F08%2FLearn-Qt5-HelloWorld%2F</url>
    <content type="text"><![CDATA[当我学习完C++的基础语法后，开始有了想制作拥有Gui界面的应用程序，所以我便选择了Qt，它具有可跨平台，并且已经有一些优质的中文教程可选． 那么就让我们从Qt5的HelloWorld开始吧! 第一步先创建一个项目 可以使用快捷键 Ctrl+N 即可呼出创建项目的菜单 创建完成后可以看到右侧项目栏有了刚刚创建的项目，并且对不同类型的文件进行了区分 HelloWorld.pro: Qt的工程文件，由qmake处理 main.cpp: 里面就是main函数 mainwindows.cpp,mainwindows.h,mainwindows.ui这些就是我们创建项目时指定的名称。 至此，我们就可以编译并启动一个Qt5应用程序了，点击左下角的第一个绿色按钮则会进行编译运行的操作。 现在我们需要在窗体上放上一个标签，这里标签的内容就是HelloWorld。 修改main.cpp文件 1234567891011#include &lt;QApplication&gt;#include &lt;QLabel&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QLabel label("HelloWorld"); label.show(); return a.exec();&#125; 再编译运行，我们则可看到一个显示”HelloWorld”的窗体程序。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++的命名空间与作用域]]></title>
    <url>%2F2019%2F05%2F30%2FC-%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[本篇文章将会详细的讲解在使用C++时一些关于作用域的易错点，以及在各模块之间有同名冲突问题要如何利用命名空间解决． 命名空间 也称为名字空间，可以解决多模块同名冲突的问题 命名空间的作用在日后的开发工作中，总是团队开发，那么可能会因为个人习惯问题，造成对左值命名相同．那么在使用两个不同的库时，可能会有两个相同的对象，那么就会出现命名冲突． 解决这种冲突的方法就是在定义时加上前缀，在使用时指定命名空间的作用域即可，这就是命名空间． 定义命名空间定义命名空间很简单只需要使用namespace关键字即可 我们可以定义一个命名空间将自己的类，函数或对象包括起来: 123456789101112131415namespace myspace&#123; class Test&#123; public: int a; Test(int a):this-&gt;a(a)&#123;&#125; &#125;; Test t(10);&#125;int main()&#123; using namespace myspace; Test t(20); cout&lt;&lt;t.a&lt;&lt;endl;&#125; 与类的成员类似，这些对象，函数，类，被称为名字空间的成员． using声明 using namespace 命名空间名; 在前面的内容中，已经不知不觉地使用上了名字空间，例如: 12using namespace std;cout&lt;&lt;"hello"&lt;&lt;endl; using声明语句告诉编译器可以尝试者从std命名空间内查找cout和endl. using指令倘若我们只需要使用std命名空间中的cout和endl成员，那么可以通过using指令指定待使用的命名空间的成员. 123using std::cout;using std::endl;cout&lt;&lt;"hello"&lt;&lt;endl; using指明会明确的告诉编译器，将使用到std命名空间中cout和endl，这样就不需要编译器依次查找了，效率会提高一点. 命名空间的别名如果命名空间都有相同的名称了，我们还可以对它设置一个别名，用于区分. 123namespace myStd = std;myStd::cout&lt;&lt;"hello"&lt;&lt;myStd::endl; 其中myStd作为std命名空间的别名． 作用域 可以简称为域,是指对象的可见性问题 C++目前支持3种作用域: 局部作用域(local scope); 名字作用域(namespace scope); 类域(calss scope); 局部作用域在每段语句块都包含一个局部的作用域，在这个语句块中声明的对象仅在当前语句块内部起作用． 例如，函数体，循环体都是局部作用域: 12345void foo()&#123; int a(10);&#125;//error a超过了作用域，访问不到foo()函数内部的a变量cout&lt;&lt;a&lt;&lt;endl; 12345for(int i=0;i&lt;100;i++)&#123; cout&lt;&lt;i&lt;&lt;endl;&#125;//error i超过了for的作用域，i是for的局部变量cout&lt;&lt;i&lt;&lt;endl; 提示:在Visual C++6.0中上述代码将i输出不会报错，因为它没有遵循该项C++标准，但在VC2003和Dev-C++中都会报错. 下面再看一个case语句块的作用域 1234567891011int choose(-1);cin&gt;&gt;choose;switch(choose)&#123; case 0: string str; break; case 1: //error:重定义了str string str; break;&#125; 若不用{}将代码括起来，那么就会出现重定义的错误，因为在同一个作用域下定义了两个string str变量，正确的代码如下: 123456789101112131415int choose(-1);cin&gt;&gt;choose;switch(choose)&#123; case 0: &#123; string str; break; &#125; case 1: &#123; //error:重定义了str string str; break; &#125;&#125; 我们通过加上{}使得给每个case块加上了不同的作用域，也就解决了重定义的问题． 函数的作用域函数体和上面提到的作用域一样，在函数体内声明的变量，只能在函数体内访问． 函数体内部包括花括号内的代码以及函数的形参列表，它们都受函数的作用域限制． 123456void foo(int i)&#123; //正常访问i变量 cout&lt;&lt;i&lt;&lt;endl;&#125;//error 未声明i变量cout&lt;&lt;i&lt;&lt;endl; 当函数之间互相调用也是有单独的作用域的，例如递归代码，注意观察i的值，每次调用自身时i的值都是不同的 123456void foo(int i)&#123; cout&lt;&lt;i&lt;&lt;endl; if(i&gt;0)&#123; foo(i/2); &#125;&#125; 局部变量的存储类型你可能听说过:自动存储类型，静态存储类型，但是你听过寄存器存储类型么? 不同的存储类型，决定了C++编译器存储这些属性的空间和方式. 自动存储类型在默认情况下，我们定义的变量就属于自动存储类型 1234void foo()&#123; int a(10); cout&lt;&lt;a&lt;&lt;endl;&#125; 在foo()函数体执行完毕后a变量将会自动释放，我们也可以换种写法: 1234void foo()&#123; auto int a(10); cout&lt;&lt;a&lt;&lt;endl;&#125; 这样做只不过为了显式的说明这个是个自动存储类型的变量 我们还可以使用类函数观测自动存储类型的销毁时间: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class Test &#123;public: int a; Test(int a); ~Test();&#125;;Test::Test(int a) : a(a) &#123; cout &lt;&lt; "创建[" &lt;&lt; this &lt;&lt; "]" &lt;&lt; endl;&#125;Test::~Test() &#123; cout &lt;&lt; "销毁[" &lt;&lt; this &lt;&lt; "]" &lt;&lt; endl;&#125;int main() &#123; Test t(10); Test t1(20); return 0;&#125; 输出结果 123456创建[0x7fff82f501c0]创建[0x7fff82f501c4]销毁[0x7fff82f501c4]销毁[0x7fff82f501c0]Process finished with exit code 0 以上代码就可观测到自动存储类型变量的自动销毁过程． 注意，由于自动存储类型变量会自动销毁，所以我们不要保存自动存储类型变量的地址，因为在对象销毁后，它不再具有我们程序赋予它的意义． 1234void *foo()&#123; auto Test t(10); return &amp;t;&#125; 寄存器存储类型寄存器存储类型继承于C语言，我们在对这种类型的变量进行存储数据时程序将会从寄存器中获取，而非内存，这样可以提高效率，这常常用于被频繁使用的变量． 12345void foo()&#123; for (register int i = 0; i &lt; 10000; ++i) &#123; cout&lt;&lt;i&lt;&lt;endl; &#125;&#125; 虽说C++继承了C语言的寄存器存储类型这一特性，但我们对一个变量加上register仅仅只能说是一种期望，因为有些编译器可能不会理会我们，编译器可能更清楚，如何处理这个变量更加高效． 静态存储类型静态存储变量特殊在于:它超出局部作用域的时候，却依然不会被销毁． 请看下面的代码: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class Test &#123; int _a;public: Test(int a) : _a(a) &#123; cout &lt;&lt; "创建[" &lt;&lt; this &lt;&lt; "]" &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; "销毁[" &lt;&lt; this &lt;&lt; "]" &lt;&lt; endl; &#125;&#125;;void foo() &#123; //静态变量 static Test t(10); cout &lt;&lt; "t对象已销毁" &lt;&lt; endl;&#125;int main() &#123; //调用第一次 foo(); //调用第二次 foo(); return 0;&#125; 输出结果: 1234创建[0x5645e7afa19c]t对象已销毁t对象已销毁销毁[0x5645e7afa19c] 可以看到，我们调用了两次foo()函数，也就是创建了两次Test对象，但是最终输出的结果却只是创建了一次和销毁了一次，也就说的那个程序执行完第一次foo()函数后，静态变量t依然存在! 常见用法 程序员们偶尔会利用static的特性，让静态变量存储一些历史数据，不需要每次都销毁的数据. 12345678910111213141516#include &lt;iostream&gt;using namespace std;void foo() &#123; static int i(0); i++; cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "次调用foo()" &lt;&lt; endl;&#125;int main() &#123; for (int i = 0; i &lt; 3; ++i) &#123; foo(); &#125; return 0;&#125; 输出结果 12345第1次调用foo()第2次调用foo()第3次调用foo()Process finished with exit code 0 今天就先写到这里，继续学习了. 命名空间域全局域123456789101112131415161718//全局作用域下的varAint varA=100;void foo1()&#123; varA++;&#125;void foo2()&#123; int varA=200; ::varA++; //输出内部作用域的varA cout&lt;&lt;varA&lt;&lt;endl; //输出全局作用域的varA cout&lt;&lt;::varA&lt;&lt;endl;&#125;int main() &#123; foo1(); foo2(); return 0;&#125; 输出结果 1234200102Process finished with exit code 0 最外层的varA为全局作用域的变量，当内部作用域出现相同的变量名时，那么外层的变量将会被隐藏。 我们使用域操作符”::”来显式的指定作用域。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用算法-1]]></title>
    <url>%2F2019%2F05%2F27%2F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-1%2F</url>
    <content type="text"><![CDATA[这篇算法文章，是我3个月前的一个笔记，目前正好要做项目，得用到一些算法，所以就直接贴过来. 常用算法 本页理解几个常用的算法 冒泡排序冒泡排序是一种稳定的排序算法 稳定即是，如果相邻的元素相同，不会再去进行调换位置 冒排的运作是(从后往前)。 我们操作数组来进行演示。 我们首先定义一个整型数组里面存储几个整型数据 12//待排序的数列int[] nums = &#123;9,6,4,3,10,25&#125;; 基本思路：比较相邻的元素，如果前一个元素比后一个元素大，那么则调换位置。 每排序一轮那么下一轮就将排序元素的个数-1，因为每轮排序都会把当前轮数的最大元素放在最后。 我们尝试先用大脑来演示排序的过程12345678//未排序时9 6 4 3 10 256 9 3 4 10 25 //第一轮 调换了2次6 3 4 9 10 //第二轮 调换了2次3 4 6 9 //第三轮 调换了2次3 4 6 //第四轮 调换了0次3 4 //第五轮 调换了0次 我们可以看到我们这组数据只需要排序三轮就可以排序成功，排序轮数是数组长度-1轮，调换次数是看数组相邻元素的大小关系，这个我们不用知道，我们只需要记住，排序轮数是数组长度-1就好。 那么在代码中我们要如何将其进行调换呢？ 有两种方式，通常来说我们可以定义一个临时变量，让相邻元素进行调换位置。 了解了基本思路，我们直接进行代码编写吧！ 123456789101112131415161718192021222324252627public class Demo&#123; public static void main(String args[])&#123; //待排序的数列 int[] nums = &#123;9,6,4,3,10,25&#125;; //临时变量，用于调换位置 int temp; //第一层循环，控制轮数 for(int i = 0;i &lt;nums.length;i++)&#123; //第二层，控制每轮要进行排序的元素数量 for(int j = 0;j&lt;nums.length-1-i;j++)&#123; //如果当前元素比后一个元素大那么则调换元素值 if(nums[j]&gt;nums[j+1])&#123; //我们先把当前元素的后一个元素放入临时变量存储,防止被当前元素覆盖 temp = nums[j+1]; //把当前元素的值覆盖后一个元素 nums[j+1] = nums[j]; //再把当前元素存入后一个元素的值(刚刚保存在temp变量里的) nums[j] = temp; &#125; &#125; &#125; //遍历输出 for(int num:nums)&#123; System.out.println(num); &#125; &#125;&#125; 刚刚说了有两种方式进行调换，是因为我们操作的数据是整型(int)的所以，我们可以使用加减的方式做到调换位置。 引用上面的代码，把tem变量删除，将调换元素值的代码更换成如下代码 123456789101112131415161718/*为了方便理解，我们这里就用上面数组下标为0和1的值(9,6)来进行演*///这个if不用加，我只是让你们知道是哪些代码if(nums[j]&gt;nums[j+1])&#123; //当前元素的值是与后一个元素值的和 nums[j] = nums[j]+nums[j+1]; //上一行代码等同于 nums[j] = 9 + 6 //执行完上一行代码，nums[j] = 15; //执行完此行代码nums[j+1] = 9 //等价于 nums[j+1]= 15 - 6 nums[j+1] = nums[j]-nums[j+1]; //执行完此行代码nums[j] = 6 //等价于 nums[j] = 15 - 9 nums[j] = nums[j] - nums[j+1];&#125; 第二种调换方式有点绕，不过仔细看看代码的注释那是很容易理解的！ 下一记: 选择排序算法 选择排序算法 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小值。 上面这个引用是网上随便抄的一个思路。 这次我们依旧是从小到大排序，选择排序和冒泡排序不同的是每一轮排序，它只调换一次位置，这个具体调换谁，就是选择排序的核心了。 我们每轮排序时都需要找到最小的元素，然后把它的下标记录下来，进行调换，第二轮排序时就不再比较刚刚记录的最小的元素了，所以依靠这种方式就可以实现排序的操作。 下面我们直接看代码 12345678910111213141516171819202122232425262728293031public class Main &#123; public static void main(String[] args) &#123; //需要排序的数组 int[] nums = &#123;6, 9, 4, 4, 25, 10&#125;; //记录每轮排序时最小元素的下标 int minIndex; //第一层循环控制轮数 for (int i = 0; i &lt; nums.length - 1; i++) &#123; minIndex = i;//假设当前轮最小元素下标为i //内层循环要记录出当前轮最小元素的下标 for (int j = i + 1; j &lt; nums.length; j++) &#123; //比较两个相邻元素的大小 if (nums[minIndex] &gt; nums[j]) &#123; //由于找到新的最小值，所以记录一下 minIndex = j; &#125; &#125; //如果最小值记录的和我们假设的值是一样，说明这一轮最小的元素就是它，所以不需要进行调换位置 if (minIndex != i) &#123; //下面代码都是为了让第一个元素和最小元素进行调换位置，因为是从小至大 nums[minIndex] += nums[i]; nums[i] = nums[minIndex] - nums[i]; nums[minIndex] -= nums[i]; &#125; &#125; //遍历输出排序后的结果 for (int num : nums) &#123; System.out.println(num); &#125; &#125;&#125; 小结：选择排序是每一轮排序都把最小的元素和没有排序时的元素进行调换位置，然后每进行一轮后，最小元素不会进入排序的操作。 下一节，二分查找算法 二分查找法 这是一种查询算法，效率高，但有个要求，必须是一串有序的数列。 二分查找，见名知意，即是将数列分为两半来查找，取一个中间值，也就是说数组长度的中间值，基本思路是: 定义起始查找位，结束查找位 求得数组长度中间值都 如果要查找的值比中间值小，那么肯定就是在二分的左边，也就是说比中间值小的值。 如果要查找的值比中间值大，那么肯定就是在二分的右边，也就是说说比中间值大的值。 如果要查找的值等于中间值，那么直接返回中间值的下标即可 如果都没找到，那么返回-1. 看了这个概念，我们还得注意几点 需要一个循环，循环是为了让每次查找时未找到可以将起始位置或结束位置改变，起始位置和结束位置取决与中间值和要查的值的关系，如果中间值大，那么起始位置就应该为0，结束位置就应该为中间值-1，也就是说中间值的左边，如果中间值大则反过来，如果相等，则直接返回，因为已经查找到了。 好了，我们直接看代码吧！ 123456789101112131415161718192021222324252627282930313233343536public class Main &#123; public static void main(String[] args) &#123; int nums[] = &#123;1,3,5,78,90,100,300&#125;; System.out.println(binarySearch(nums,1)); &#125; /** * 二分查找法 * @param nums 要查找的数列 * @param key 要查找的值 * @return */ static int binarySearch(int[] nums,int key)&#123; //起始下标 int start = 0; //结束下标 int end = nums.length-1; //起始查询的下标不能超过结束下标 while(start&lt;=end)&#123; //中间的下标，如果是下标长度是偶数，那么则是去小数点取整数的值 int middle = (start+end)/2; //如果中间下标的值比要查找的值大 if(nums[middle]&gt;key)&#123; //要查找的值那肯定是在二分的左边，所以结束下标就以中分下标长度－１开始查找 end = middle-1; &#125;else if(nums[middle]&lt;key)&#123; //二分的右边开始查找 start = middle+1; &#125;else&#123; //如果要查找的值就是二分下标的值，那么直接返回即可 return middle; &#125; &#125; //如果没有查找到那么则返回-1代表没有查找到 return -1; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何自学编程?]]></title>
    <url>%2F2019%2F05%2F23%2F%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前几日，我在Telegram上创建了个Linux的讨论群组反响挺好，不过都是各大高校或者已在工作的大佬们入群。 今天舍友请邀家做客，吃完饭我们在操场上散步，我脱了鞋，走了几圈想到， 为什么不把我身边的同学们集合起来创建一个讨论群组，回到宿舍我便创建了群组，由于每个人能力有限，不是谁都可以翻墙的，所以我就用微信群作为讨论的地方。 0x0 制定目标这个目标最好是十分远大的，并且必须是准确的。 例如你说你要赚很多钱，但是你并不知道你要怎样做才能赚很多钱，你可以想，你要赚很多钱，通过卖保险…然后开始学习销售方面的才能。 制定目标是最重要的，你可以花几天的时间去想这件事，因为，一旦下定目标，你就需要全力以赴奔向它。 0x1 选择方向你可能需要面对的是该学什么，我是推荐前期选一门比较热门的编程语言开始学习，在学习过程中多了解软件开发这个世界，你自然会有很多选择。 当然，我这里是推荐学习C++，虽然它曾经被我的偶像Linus Torvalds臭骂一顿，但由于要考试，再加上这门语言的语法非常灵活，极具智慧的初学者可以有很多种hack玩法。 0x2 学习过程在你选定你要学习的目标后，你必须有一个正确的学习心态和学习方法，我这里只提我自己的学习心态和学习方法。 0x21学习心态我对编程是随和的，我可以从中获得快乐，快乐至上才是最重要的，你需要尝试用代码来使你快乐，可以把一些你感兴趣事物与代码结合，我相信你会爱上编程的。 0x22学习方法不要问，去调试，去反编译 这句话虽说有些偏执，但确实很有效，很多时候答案不是靠别人，而是要靠你自己研究出来的，一套好教材提供的学习线路基本都是环环相扣，甚至可以跳节选学，倘若你是一步一步学习的，那么你遇到的问题肯定可以从你所学的知识获得解答。 多写代码，多讨论，尝试新想法 多写代码是必须的，你可能会说，我很菜，我都不知道写什么代码，我怎么办。我推荐你抄代码，抄别人的代码，看别人是怎么写的，你就抄下来，尝试理解。倘若抄得很吃力，我建议你换个选择，倘若在抄代码过程中，能大概理解其运作方式，你可以与群组的人们进行讨论，这样既可以自己学习也可以让别人学习。 多讨论，上面很多次提到讨论，事实上，讨论就是十分重要的，你可以在讨论时获取到大量知识，若你感兴趣完全可以研究别人所提到的技术，再回头进行讨论，技术提升就是这么来的。 尝试新想法，往往一个程序，可以有很多种写法，你可以尝试着思考如何用更简短或者更易懂的方式重写一遍，使得程序更健壮和执行速度更快。 0x3 充分利用互联网虽说我国的互联网事实上是局域网，但是也不影响我们小白进行学习，网上的优质教程有特别多，而且大多是免费的。 不仅仅是从互联网上获取教程，互联网上可以说是什么都有，你想要的一切只有你找不到的，没有不存在的，有兴趣的可以百度搜索一下原子弹制作从入门到精通。这边推荐一个更好的利用搜索引擎的文章点击访问 0x4 读书在学习的过程中，我们可能会遇到很多坑，在很多书籍中讲的很明白、透彻，所以阅读技术类书籍是能大大提高我们水平的，但有个缺点，不是谁都能读完一本书。 推荐书籍以后会写。 0x5 推荐学习C++视频教程 C++书籍 Git视频教程 0x6 其他如果你是Windows系统，那么推荐Visual Studio作为你的编程工具。 如果你是Linux系统，那么推荐CLion作为你的编程工具。 如果你是OS X系统，抱歉没用过苹果系统，应该是Xcode。 推荐学习资源:点击访问 0x7 讨论群组]]></content>
      <categories>
        <category>个人感想</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++读写文件]]></title>
    <url>%2F2019%2F05%2F22%2FC-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一些简单的读写文件的操作。 本篇文章使用C++fstream头文件提供的库函数进行读写操作 请引入#include \&lt;fstream>进行下面的操作。 写入写入文件步骤如下: 实例化ofstream对象，或者fstream对象. ofstream ofs; 打开文件流 ofs.open(const std::string &amp;s,ios_base::openmode=ios_base::out); 写入文件 ofs&lt;&lt;; 关闭文件流 ofs.close(); 注意打开文件流函数的参数分别为路径和打开方式. 常用的打开方式如下: 模式标识 适用对象 描述 ios::int ifstream,fstream 打开输入,默认用于ifstream和fstream ios::out ofstream,fstream 打开输出，默认用于ofstream和fstream ios::trunc ofstream 打开输入，默认用户ofstream ios::ate ifstream 打开并且在打开后将文件指针指向文件末尾，若文件不存在，则出错 ios::app ostream,fstream 打开输出，并且将数据输出至文件末尾，相当与追加 iso::binary ifstream,ofstream,fstream 以二进制的方式打开文件，进行输入或输出 以上所有的打开方式可以通过或|运算符进行联合使用，例如: 12//以二进制的方式打开输出ofstream ofs(path,ios::out|ios::binary); 不管是读取操作还是写入操作，只要涉及打开文件函数的调用，我们都需要在使用完之后对文件进行一个关闭的操作 好的，下面可以看例子了，我们将写入一些数据到一个文件内。 以文本写入 下面将读取两种不同类型的文件以作为案例进行讲解。 1234567891011121314151617181920/** * 写入文件 * @param path 文件路径 * @param context 内容 */void writeFile(string path,string context)&#123; //实例化写入对象 ofstream ofs; //打开输出 ofs.open(path,ios::out); //向文件写入数据 ofs&lt;&lt;context&lt;&lt;endl; //关闭输出 ofs.close();&#125;int main()&#123; //调用 writeFile("./test.txt","测试");&#125; 这样我们就将测试这个段文本信息，写入到当前目录下test.txt文件内了. 以二进制文件写入以二进制文件方式写入，C++提供了write()库函数,它的函数原型是: write(const _CharT* __s, streamsize __n); 其要求地一个参数为字符型指针，第二个参数为最大写入字符数大小。 123456789101112131415161718192021222324252627282930class Student &#123;private: char name[64]; int age;public: Student(char name[64], int age) &#123; for (int i = 0; i &lt; sizeof(name); ++i) this-&gt;name[i] = name[i]; this-&gt;age = age; &#125;&#125;;`/** * 写入二进制文件 * @param path */void writeFileByBinary(string path) &#123; //创建输出流对象，并且指定路径和文件打开方式 ofstream ofs(path, ios::out | ios::binary); Student *student = new Student("张三", 18); //写入文件 ofs.write((const char *) student, sizeof(Student)); ofs.close(); delete (student);&#125;int main()&#123; writeFileByBinary("student.bin");&#125; 这里我们将类成员属性的值以二进制的方式写入进一个文件内。 最终文件内的内容人类是看不大懂的。 注意:以二进制方式写入文件,那么需要以二进制的方式读取文件，不然读出的数据将是乱码. 读取 下面将读取两种不同类型的文件以作为案例进行讲解。 以文本文件读取读取有很多种方式，下面将会演示三种，分别是: 逐行读取 逐词读取 逐字符读取 逐字符读取(不推荐)逐字符读取：通过输入流读取单个字符，再将读取到的字符存入容器中。因为是单个字符读取，所以效率较低。 123456789101112131415161718/** * 逐字符读取 * @param path 路径 */void readFile04(string path) &#123; //实例化读取操作对象 ifstream ifs; //打开文件 ifs.open(path, ios::in); //数据存储变量 char cbuffer; //逐字符读取，并且将读取的内容复制给c,不再进行读的条件是当读取的字符为EOF，代表文件的结尾. while ((cbuffer = ifs.get()) != EOF) &#123; cout &lt;&lt; cbuffer &lt;&lt; endl; &#125; //关闭文件 ifs.close();&#125; EOF代表文件的末尾，它是一个宏，逐字符读取的条件为，若遇到文件末尾，也就代表读取完成。 逐行读取(有两种方式，但都是逐行读取)第一种： 123456789101112131415161718/** * 逐行读取 * @param path 路径 */void readFile02(string path) &#123; //实例化 fstream fs; //打开文件 fs.open(path, ios::in); //用字符数组进行缓存 char buffer[1024] = &#123;0&#125;; //逐行进行读取，getline(存储读取到的字符的字符数组,最大读取字符数) while (fs.getline(buffer, sizeof(buffer))) &#123; cout &lt;&lt; buffer &lt;&lt; endl; &#125; //关闭文件 fs.close();&#125; 使用字符数组作为数据存储容器，用fstream对象的getline()函数调用，第一个参数为:存储读取到的数据的容器，第二个参数为最大读取数量，这里使用sizeof()是为了不出现数据过大，从而使得字符数组不够大，引发数组越界。 第二种: 123456789101112131415161718/** * 逐行读取 * @param path 路径 */void readFile03(string path) &#123; //实例化读取操作对象 ifstream ifs; //打开文件 ifs.open(path, ios::in); //数据存储容器 string buffer; //使用全局函数getline(输入流，可存储的容器)进行逐行读取 while (getline(ifs, buffer)) &#123; cout &lt;&lt; buffer &lt;&lt; endl; &#125; //关闭文件 ifs.close();&#125; 与第一种方法相似，只不过是将数据存储容器更换为了string类型，但是使用的是全局函数getline(输入对象,数据存储容器),它的第一个参数为：输入对象，也就是我们的读取对象，getline会把数据读入至制定的输入流内，再通过输入流存储至容器。 逐词读取(以空格区分)逐词读取，将会已空格进行区分每个词汇，再读取。 12345678910111213141516171819202122/** * 逐词读取文件 * @param path 文件路径 */void readFile01(string path) &#123; //实例化读取文件对象 ifstream ifs; //打开文件 ifs.open(path, ios::in); //判断文件是否能打开 if (!ifs.is_open()) &#123; cout &lt;&lt; "文件打开失败!" &lt;&lt; endl; return; &#125; //字符数组缓存 char buffer[1024] = &#123;0&#125;; //将读取的数据放入缓存区 while (ifs &gt;&gt; buffer) cout &lt;&lt; buffer &lt;&lt; endl; //关闭文件 ifs.close();&#125; 这里多了一个判断文件是否能打开的操作，这样可以防止，路径出错使得程序出错。 这种逐词读取的方式是读取对象通过右移运算符把读取的数据存入容器之中，但是是以空格区分每个词汇。 以二进制的方式读取前面我们使用了二进制的方式写入文件，那么被写入的文件就会变成二进制文件，这种文件需要使用二进制读取才能将内容正确的读取，下面看一个简单的例子。 1234567891011121314/** * 以二进制的方式读取文件 * @param path 路径 */void readFileByBinary(string path) &#123; //创建输入流对象，并且指定路径和文件打开方式 ifstream ifs(path, ios::in | ios::binary); char * c = new char[64]; ifs.read(c, sizeof(c)); cout&lt;&lt;c&lt;&lt;endl;&#125;int main()&#123; readFileByBinary("Student.smi");&#125; 输出结果: 123张三Process finished with exit code 0 这里我们将Student.smi这个文件用二进制的方式读取，那么就能正确的将文件内容获取，但如果我们以二进制的方式读取一个文本文件，将会出现一些我们不想要的结果。 总结读取文件创建ifstream对象,写入文件创建ofstream对象，fstream对象既可以读又可以写。 操作文件得先打开文件 操作文件完毕得关闭文件 二进制文件读取需要读取二进制格式的文件]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我儿子的博客]]></title>
    <url>%2F2019%2F05%2F21%2F%E6%88%91%E5%84%BF%E5%AD%90%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[自从教会大学同学搭建博客后，他也开始写博客了，内容挺好玩的，推荐去看看。 随便截取一个片段，这哥们咋那么傻的可爱。 想去看的话，点击下面的链接吧，他是个新手，所以基本不用指望去他那里能学到啥。 PS:痔疮，你看到了别打我 EvanShady的博客]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>欢乐时光</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决KDE下部分应用不能使用fcitx中文输入法的问题]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%A7%A3%E5%86%B3KDE%E4%B8%8B%E9%83%A8%E5%88%86%E5%BA%94%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8fctix%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我有两台设备，都是KDE5-Plasma桌面，但是其中一台可以完美使用中文输入法，另外一台则不可以，为了解决这个问题，便有这篇文章。 *** 本教程使用fcitx输入法框架。** 第一步首先安装一些必要的软件: 1$ sudo pacman -S fcitx fcitx-im fcitx-configtool fcitx-googlepinyin 第二步安装完成后编辑:/etc/environment文件，加上如下内容: 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx 第三步注销当前会话，配置输入法为googlepinyin即可使用。 本文参考]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>KDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++友元]]></title>
    <url>%2F2019%2F05%2F17%2FC-%E5%8F%8B%E5%85%83%2F</url>
    <content type="text"><![CDATA[相比Java的继承，C++的友元在某些场景下更加方便，再加上我是没用过友元的，所以就深入研究了下友元，所以有了这篇文章。 什么是友元？友元可以访问类中私有的成员。 它的使用场景又如下几种: 全局函数作友元 类作友元 成员函数做友元 实例下面将通过几个案例，分别演示不同场景下，友元的使用方式。 全局函数作友元本小节通过使用一个全局函数访问类的私有成员，分别有两种情况，一种为无友元，另一种则使用了友元。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;//先声明Person类，防止下面报错class Person;//声明showPrivateVar函数，防止报错.void showPrivateVar();//定义Person类class Person&#123;private: //私有属性，money,showPrivateVar函数访问的就是这个 double money;public: //声明构造函数 Person();&#125;;//类外定义构造函数Person::Person()&#123; this-&gt;money = 10;&#125;/** * 访问私有成员 */void showPrivateVar()&#123; //实例化Person类对象 Person p; //访问Person对象的私有成员 cout&lt;&lt;"尝试访问Person类的私有属性:"&lt;&lt;p.money&lt;&lt;endl;&#125;int main()&#123; //调用访问私有成员函数 showPrivateVar(); return 0;&#125; 显然，这个程序是跑不起来的，因为全局函数showPrivateVar访问了类Person的私有成员，这是没有使用友元的情况下，但是如果我们把友元加上，那么再跑一遍试试。 12345678910class Person&#123; //使showPrivateVar函数作为Person类的友元 friend void showPrivateVar();private: //私有属性，money,showPrivateVar函数访问的就是这个 double money;public: //声明构造函数 Person();&#125;; 运行结果: 123尝试访问Person类的私有属性:10Process finished with exit code 0 我们只是在定义类时加了一行代码，使得showPrivateVar函数作为类的友元，我们就可以在使用showPrivateVar函数时访问Person类的私有成员. 那么，得出结论：将全局函数作为某类的友元，那么其则可访问类的私有成员。 类作类的友元这个例子，我们将演示，一个类作作为另一个类的友元，并且访问类中私有的成员. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;//声明类，防止报错class Build;/** * Build类的好朋友类，可以访问它的私有属性 */class FriendForBuild&#123; Build * b;public: //声明构造函数 FriendForBuild(); //声明visit函数 void visit();&#125;;//定义Build类class Build&#123; friend FriendForBuild;private: //私有房间 string privateRoom;public: //公共房间 string publicRoom; /** * 构造函数 */ Build()&#123; this-&gt;privateRoom = "私人卧室"; this-&gt;publicRoom = "公共客厅"; &#125;&#125;;FriendForBuild::FriendForBuild() &#123; b = new Build();&#125;/** * 访问Build类对象的所有成员，包括私有成员 */void FriendForBuild::visit()&#123; cout&lt;&lt;"我正在访问Build类对象的publicRoom成员:"&lt;&lt;b-&gt;publicRoom&lt;&lt;endl; cout&lt;&lt;"我正在访问Build类对象的privateRoom成员:"&lt;&lt;b-&gt;privateRoom&lt;&lt;endl;&#125;int main()&#123; FriendForBuild friendForBuild; friendForBuild.visit(); return 0;&#125; 输出结果: 1234我正在访问Build类对象的publicRoom成员:公共客厅我正在访问Build类对象的privateRoom成员:私人卧室Process finished with exit code 0 可以看到，我们若需要在类中访问另外一个类的私有成员，只需要把当前类作为其他类的友元，这样就可以使得当前类不受私有访问权限的限制。 成员函数做友元上面我们引入了类作类的友元，但他有个缺陷：我们可以通过友元类的所有成员访问类的私有成员了，这样就没一一个太大的限制，那么我们下面只需要将成员函数作为友元就可以避免这种问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;//声明类，防止报错class Build;/** * Build类的好朋友类，可以访问它的私有属性 */class FriendForBuild&#123; Build * b;public: //声明构造函数 FriendForBuild(); //声明visit函数 void visit();&#125;;//定义Build类class Build&#123; friend void FriendForBuild::visit();private: //私有房间 string privateRoom;public: //公共房间 string publicRoom; /** * 构造函数 */ Build()&#123; this-&gt;privateRoom = "私人卧室"; this-&gt;publicRoom = "公共客厅"; &#125;&#125;;FriendForBuild::FriendForBuild() &#123; b = new Build();&#125;/** * 访问Build类对象的所有成员，包括私有成员 */void FriendForBuild::visit()&#123; cout&lt;&lt;"我正在访问Build类对象的publicRoom成员:"&lt;&lt;b-&gt;publicRoom&lt;&lt;endl; cout&lt;&lt;"我正在访问Build类对象的privateRoom成员:"&lt;&lt;b-&gt;privateRoom&lt;&lt;endl;&#125;int main()&#123; FriendForBuild friendForBuild; friendForBuild.visit(); return 0;&#125; 总结友元可以说成时一个类的朋友，这个朋友可以访问类的所有属性，不管是私有的还是公有的，不同的场景下可以使用不同的方法使用友元。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManjaroLinuxTG讨论群组]]></title>
    <url>%2F2019%2F05%2F16%2FManjaroLinuxTG%E8%AE%A8%E8%AE%BA%E7%BE%A4%E7%BB%84%2F</url>
    <content type="text"><![CDATA[创建了个ManjaroLinux的Telegram讨论群组，欢迎加入讨论。 点击加入]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Telegram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Linux之路]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%88%91%E7%9A%84Linux%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[这篇是我2019-5-12发表在Deepin论坛的文章，感觉可以记录下，让更多人了解我的Linux之路和我对Linux桌面的一些看法. 先说说一些题外话 我是在2018年的某月(具体哪天忘了)知道了Ubuntu这个系统，也是我第一个听说过的Linux系统，然后我就不知道怎么了，就尝试去安装了，安装之前计算机对我来说就只是台”游戏机“。 第一次安装很神奇，居然成功了，但有个问题。笔电盖上屏幕后打开，会出现无法恢复的问题，而且无法解决，我当时根本Linux下的显卡驱动是什么，然后我还是继续用着..因为我没有钱买百度云会员重新下载win10镜像(穷学生)… 并且在我使用ubuntu的时候，我还一长段时间不能使用无线网络，那是因为我在笔记本有个按键，可以快速关闭无线网卡，但是按下这个快捷键Ubuntu没有给任何提示，只有无线网络无法使用。。。 我便忍了，中间一直认为是我没有装驱动，因为我在找前面提到的笔电盖屏不恢复的解决方案时，增加了”驱动” 这个关键词的经验(最终还是没搞好)，我就以为还是驱动问题，网上大量的搜索相关解决方案，然后我就学会了apt包管理器的基本使用方法…还了解了vim nano 这些编辑器，但无线网络这个问题还是没解决…后来是怎么解决的呢? 某一天下午，我在图书馆，用电脑在看编程的视频教程，然后不小心按了我上面所提到的开关无线网卡的按键，然后我就可以使用Wifi了…. 好了，这是我使用Ubuntu的一些小事迹，下面要讲Deepin了，毕竟是我使用时长最长的Linux发行版。 身为一个Linux新手，在使用Linux之后，会到处找资料，当然也会看到各种 “xxx可能是最好的Linux发行版”，各种论坛上也会讨论不同的发行版的区别，此时还没到Deepin，我发现了 Linux Mint，当时很多人叫它绿薄荷，我便安装了，说实话，我觉得Linux Mint很丑，但是很多人说它是目前Linux受欢迎度排行最高的发行版，而且又是基于Ubuntu的，安装也很方便，我便安装了Linux Mint，关于Linux Mint的回忆，我记不太清了，主要是我用的时间太短，安装好了后，去找Mint的QQ群，都寥寥无几，我便开始了我的下一段Linux旅程。 终于到Deepin了，具体是怎么知道Deepin的我已经忘记了！，可能是因为从Mint到Deepin的过渡太轻松了吧，使我没有什么深(zao)刻(gao)的记(ti)忆(yan)，我只记得，安装Deepin太简单，只需要选择语言，简单分下区，直接点击安装，稍微等待下就可用了。在Deepin下使用的太欢快了，每天都熬夜折腾自己的系统，当时看到Deepin的招聘要求是：对Linux有充满信仰的狂热，不敲代码睡不着。 我当时的情况就是这样的，并且我还一度想着以后一定要进深度公司做程序员(后来发现自己是个菜逼)。 自从我使用了Deepin，我便天天给身边的朋友安利Deepin，不过他们好像都不怎么看得起Deepin，但在我心中Deepin就是那种闪耀般的存在。后来，我老爸的老旧笔记本跑win7有点吃不消了，他主要是写文档和看视频，我又给他的电脑安装了Deepin 15.6，目前(2019-5-12)也还在使用，很赞! 下面要吹下Deepin了，国内常用软件兼容的非常好!这个要大大的赞，并且Deepin自带的软件都非常易用+实用，如果你不使用QQ或者微信那没什么… 毛玻璃效果非常漂亮，社区还是挺活跃的。 说下Deepin的缺点(个人体验): 耗电，不太可客制化(可能是我太菜)，软件旧(个人体验） 我从Deepin15.6一直用到15.9.3中间出现了很多问题（但都是小问题），随着个人技术的增长和论坛的帮助基本都是能解决，但还是有两点无法解决的，在我个人笔记本上:会偶尔卡死，真死的那种。无法睡眠。 我一直期待着15.10能将我上面提到的两个问题解决，但是并没有解决，而且标题栏变得更大了，我忍不了了，我的笔记本是13.3寸的。标题栏真的又肥又大，实在影响美观，再加上我的那些问题又无法得到解决，我就尝试了一下一直被大家所提到的Arch Linux，不过我不是直接使用的Arch Linux，我是使用的它的衍生版:Manjaro Linux，首先是它安装方便，其次是各大论坛呼声挺高的，我便直接跳过了Arch直接使用Manjaro，之前在虚拟机装了遍Arch，跑的dde。 下面便是Manjaro篇了，我选择的是KDE桌面，因为当时社区里上很多人说KDE非常可定制化，我使用了Manjaro Linux了，使用体验非常好!可以说是Very Good了! 解决了上面提到的所有问题，并且电脑还省电多了…并且在KDE下感觉比DDE丝滑一点点，不知道是不是错觉，并且电脑发热量也比DDE要低，关键是Pacman和Aur实在是太好用了，虽然debian系的软件是最多的，但是安装不一定比Pacman要方便，我在Manjaro官方软件源下找不到的软件，Aur里有，而且基本很少出现依赖问题，除了卸载的时候，会提示依赖问题，但是安装时不会。 但也不是说Manjaro就没问题了，比如QQ就不怎么样，虽然是使用的Deepin打包的，但我的还是有些问题，使用体验上没有Deepin好，微信等软件倒是没问题。 总的来说，如果你是新手或者说不愿意折腾操作系统，但又想使用Linux系统，Deepin是你最好的选择(个人看法)，如果你折腾或了解更多的Linux知识，推荐Arch系的发行版。]]></content>
      <categories>
        <category>个人感想</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝和浅拷贝的区别]]></title>
    <url>%2F2019%2F05%2F14%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[虽然网上大家们都说浅拷贝和深拷贝本不是C++原本的概念，根本都是胡乱撤出来的概念，但我感觉还是有必要写这一篇文章，并且以此作为标题。 浅拷贝我们都知道,C++在实例化一个类对象时，会自动调用它的拷贝构造函数。 那么浅拷贝就是在你没有创建自定义拷贝构造函数时执行的默认的拷贝构造函数。 那什么是拷贝构造函数呢? 拷贝构造函数是将对象的所有属性的值进行拷贝，并且赋值给要拷贝的对象 下面看个例子: 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class Human &#123;public: string name; int age; //默认构造函数 Human() &#123; cout &lt;&lt; "Human默认构造函数调用." &lt;&lt; endl; &#125; //有参构造函数 Human(string f_name, int f_age) &#123; name = f_name; age = f_age; cout &lt;&lt; "Human有参构造函数调用." &lt;&lt; endl; &#125; //析构函数 ~Human() &#123; cout &lt;&lt; "Human析构函数调用." &lt;&lt; endl; &#125;&#125;;int main() &#123; Human h1("李四", 18); cout &lt;&lt; h1.name &lt;&lt; "的年龄为:" &lt;&lt; h1.age &lt;&lt; endl; //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2 Human h2(h1); cout &lt;&lt; h2.name &lt;&lt; "的年龄为:" &lt;&lt; h2.age &lt;&lt; endl; return 0;&#125; 输出结果为: 1234567Human有参构造函数调用.李四的年龄为:18李四的年龄为:18Human析构函数调用.Human析构函数调用.Process finished with exit code 0 根据上面的代码，我们可以看出h1对象所有属性的值都拷贝给了h2对象，但是我们并没有写相关的代码，这是编译器帮我们实现的，也就是默认的拷贝构造函数，我们就称为浅拷贝。 浅拷贝的具体代码实现是怎样的呢？请看下面的代码: 12345//默认的拷贝构造函数Human(const Human &amp; h)&#123; name = h.name; age = h.age;&#125; 可与看出，它只是简单的将对象属性的值，进行拷贝。 大家思考一下，如果对象属性都是普通类型的变量，那么，这个浅拷贝是可以完美的完成这个任务的，但是如果对象属性含有引用变量或指针变量的话，那么这个浅拷贝，是否能正确的执行呢？ 答案是否定的，下面看下深拷贝。 深拷贝什么是深拷贝? 深拷贝就是由程序员自定义的拷贝构造函数，并且能够处理浅拷贝所遇到的问题，也就是能够处理当浅拷贝遇到引用变量和指针变量时，无法完美处理的场景. 下面的代码将体现，浅拷贝在遇到对象属性存在引用和指针变量时可能会出现的错误: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class Human &#123;public: string name; int *age; //默认构造函数 Human() &#123; cout &lt;&lt; "Human默认构造函数调用." &lt;&lt; endl; &#125; //有参构造函数 Human(string f_name, int f_age) &#123; name = f_name; //动态分配内存空间，将age的数据存入堆区 age = new int(f_age); cout &lt;&lt; "Human有参构造函数调用." &lt;&lt; endl; &#125; //析构函数 ~Human() &#123; //如果age指针变量是空，则释放 if(age !=NULL)&#123; delete age; //防止指针变量成为野指针 age = NULL; &#125; cout &lt;&lt; "Human析构函数调用." &lt;&lt; endl; &#125;&#125;;int main() &#123; Human h1("李四", 18); cout &lt;&lt; h1.name &lt;&lt; "的年龄为:" &lt;&lt;*h1.age &lt;&lt; endl; //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2 Human h2(h1); cout &lt;&lt; h2.name &lt;&lt; "的年龄为:" &lt;&lt;*h2.age &lt;&lt; endl; return 0;&#125; 输出结果为: 1234567free(): double free detected in tcache 2Human有参构造函数调用.李四的年龄为:18李四的年龄为:18Human析构函数调用.Process finished with exit code 134 (interrupted by signal 6: SIGABRT) 通过输出结果，我们发现，程序发生了错误。 因为由于类中有一个指针变量，所以我们编写有参构造函数时，需要将数据以堆的形式存储，并且在编译器调用析构函数时将其释放。 上面提到过，如果程序员没有自定义拷贝构造函数，那么编译器将会自动加上，也就是说，我们要进行拷贝时，程序将会以浅拷贝的方式进行拷贝。 由于是浅拷贝，那么h1对象就会将指针变量age所指向的地址赋值给h2对象的指针变量age，那么它们俩所指向的内存单元是同一个。 然而在h1对象所要执行的操作完成后，就会调用它的析构函数，里面是会释放掉age指针变量，那么也就是说，在h1对象的生命周期内，age指针变量所指向的内存单元的数据已经被释放了，但是当执行到h2的对象的生命周期时，我们再进行释放时，程序自然就会报错。 既然问题找到了，我们就需要进行修改，将这个问题解决。 下面通过深拷贝的方式，让这个bug被修复: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;class Human &#123;public: string name; int *age; //默认构造函数 Human() &#123; cout &lt;&lt; "Human默认构造函数调用." &lt;&lt; endl; &#125; //有参构造函数 Human(string f_name, int f_age) &#123; name = f_name; //动态分配内存空间，将age的数据存入堆区 age = new int(f_age); cout &lt;&lt; "Human有参构造函数调用." &lt;&lt; endl; &#125; //拷贝构造函数 Human(const Human &amp; h)&#123; name = h.name; //新开辟内存空间到堆区，存放age所指向的数据。 age = new int(*h.age); cout&lt;&lt;"Human拷贝构造函数调用."&lt;&lt;endl; &#125; //析构函数 ~Human() &#123; //如果age指针变量是空，则释放 if(age !=NULL)&#123; delete age; //防止指针变量成为野指针 age = NULL; &#125; cout &lt;&lt; "Human析构函数调用." &lt;&lt; endl; &#125;&#125;;int main() &#123; Human h1("李四", 18); cout &lt;&lt; h1.name &lt;&lt; "的年龄为:" &lt;&lt;*h1.age &lt;&lt; endl; //浅拷贝，编译器会自动将h1对象属性的值拷贝给h2 Human h2(h1); cout &lt;&lt; h2.name &lt;&lt; "的年龄为:" &lt;&lt;*h2.age &lt;&lt; endl; return 0;&#125; 输出结果为: 12345678Human有参构造函数调用.李四的年龄为:18Human拷贝构造函数调用.李四的年龄为:18Human析构函数调用.Human析构函数调用.Process finished with exit code 0 程序没有报错，说明我们的bug成功解决了。 上面的代码，我们只是自定义了一个拷贝构造函数，也就是深拷贝。 深拷贝的具体实现，就是在拷贝数据时，将数据拷贝到一个新的内存空间，并且这个内存空间是在堆区，这样也就避免了浅拷贝时的问题。 为什么能避免？ 原因是：如果通过浅拷贝进行拷贝数据的话，遇到指针或引用变量时，编译器只是将要拷贝的指针变量所指向的内存空间的地址进行拷贝，那么两个对象的指针变量所指向的地址仍然是相同的地址，所以当生命周期走向末尾，调用析构函数，释放内存空间后，再有对已释放的内存空间进行释放内存空间的操作就会引发异常。然而通过深拷贝的方式进行拷贝时，会开辟一个新的内存空间，这样每次释放空间时，则不会造成二次释放同一个空间的异常。 两者该如何选择?说得绝对点： 若类含有指针变量时，为了防止出现两个指针指向同一个内存空间，从而引发二次释放同一空间的问题，则需要在拷贝时对相应的指针变量开辟新的空间。 这时需要使用深拷贝。 说的不那么绝对: 若类只有一个实例化对象，那么使用浅拷贝也没什么关系，因为无法造成二次释放同一内存空间的问题。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>经典案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2008年5月12日14时28分04秒]]></title>
    <url>%2F2019%2F05%2F12%2F2008%E5%B9%B45%E6%9C%8812%E6%97%A514%E6%97%B628%E5%88%8604%E7%A7%92%2F</url>
    <content type="text"><![CDATA[图为汶川大地震时某部队空降救灾 0x005·12汶川地震，发生于2008年5月12日（星期一）14时28分04秒，根据地震局的数据，此次地震的面波震级 里氏震级达8.0Ms、矩震级达8.3Mw，地震烈度达到11度。 此次地震的地震波已确认共环绕了地球6圈。地震波及大半个中国及亚洲多个国家和地区，北至辽宁，东至上海，南至香港、澳门、泰国、越南，西至巴基斯坦均有震感。 伤亡人数：69227人遇难，374643人受伤，17923人失踪。 以上是一些冷冰冰的数字，在这些数字背后是无数悲痛的家庭，在遭遇国家大灾大难的时候，一切都显得那么渺小。 0x01每年的这个时刻，我都不由自主的想起这个事情。 2008年的时候正读大二，大学在宝鸡市距离汶川大概10小时的车程，震感非常剧烈，那是我人生中第一次明显的感觉到地震的威力。 那天像往常一样，午休完来到教室，照例坐到了教室的最后一排，等待老师来上课， 突然感觉到桌子在猛烈的摇晃，而桌子是固定在地板上的，前面的女同学也转过头来诧异的看着我，以为我在后面搞什么鬼。 这时候，抬头看到教室的吊灯在疯狂的摆动，突然有人意识到地震了！对大家喊到：快跑，地震了！ 跑到楼道的时候已经满是人，毕竟是大学生，虽然紧张，下楼也很有秩序。有的人跑到教室下面的广场就绷不住了大哭。 宿舍楼那边，有人穿着睡衣就跑到了楼下，有人拿着伞从二楼跳下，还有的估计是裸睡，披个床单就下来了。没有嘲笑，只有震惊和后怕。 因为不知道震源在哪里，所有人的第一反应是给家里打电话，基站一下子就崩溃了。平均每拨出100多个电话，能有一个打通。 大部分同学都联系到了家里，有那么几个却没有。晚些时候，消息传了过来，震源在汶川。 晚上路过学校操场的时候，听到一个女孩大声的哭声，心中一片凄凉。四川籍同学们围成了一个大圈，点着蜡烛，在祈祷。 学校开始不定期停课，余震不断，我们从宿舍搬到了大操场，幸亏那段时间没有下雨。 天天过上了打牌闲逛的生活，一周后学校通知放假两周，大家纷纷回家。再次回到学校，所有的空地都搭建了军用帐篷。 0x022008年5月19日全国默哀日，老师站在讲台上，14时28分全体起立，低头默哀三分钟。 我站在靠马路旁的窗子，当防空警报响起的时候，所有的车辆都自觉的靠边停车，汽车嘀声长鸣。 两种声音交织低沉而婉转，像是为逝去的人在哭泣，举国悲痛。 这是一张2008年的老图，当时，还没有从中国撤出的谷歌在自己官方博客“谷歌黑板报”上贴出了这张图，记录的是汶川地震一周后，5月19日的流量曲线。 这暴跌几乎到0的几分钟，是全国为汶川地震默哀的三分钟。 谷歌当时的博文说道： “当我们依照惯例整理和分析谷歌搜索引擎的流量数据时，一条从未见过的曲线出现在我们面前。当意识到发生了什么事情时，我们的眼睛湿润了。” 几乎降到0的那个节点说明了当时的一切，这个几乎不可能出现的数据记录着中国为汶川地震默哀的三分钟。 全世界的中华儿女在这三分钟连在了一起。 0x03在这之前我觉得中国人浑身上下充满了劣根性，自私，无爱，中国人就是一盘散沙。地震之后我才发现，中国人一下就团结起来了，那个时候也没有所谓的官员和百姓，没有奸商和地痞。 大家那时候就只有一个身份，就叫中国人。 那次灾难让我明白，中国人的团结，是刻在DNA里面的，不是挂在嘴上的，和平时候大家该干嘛干嘛，一旦到了国家危急的时候，就仿佛血液里的基因被激活，大家都知道自己该做什么。 况且古往今来，历史诚不欺我。 知乎 ———— 小小白告 汶川地震第三天早上，一个师兄没按时到校，班主任以为是睡过头了，也没有特意去找，结果一直到第四节课也没来。 打电话问家长，家长说孩子早早就去上学了，这下两边都慌了，上窜下跳的找孩子。 最后我们耿直可爱的师兄在济南火车站被拦截，身上背着家里全部现金，药品和压缩食品，要做火车去成都再去汶川救灾。 多年过去，讲起这个故事，仍旧热泪盈眶。 知乎 ———— 匿名用户 昨晚在宿舍，室友是个四川妹子正在看腾讯视频上《新青川十年之后遇见你》。 她给我看她们初中的学校。 我问她当年你的同学是不是好多都不在了。她沉默了一会说当年宿舍一共八个人，只有她一个人活下来了。 我听了这句话瞬间眼睛红了，那年她初二，今年她研二。 活着，本身就意味着一切。 知乎 ———— 匿名用户 推荐25分钟纪录片:《为了生命》。 本篇文章转载于：阅读原文作者：纯洁的微笑(一个有故事的程序员)]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>社会事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存四区之代码区与全局区]]></title>
    <url>%2F2019%2F05%2F11%2FC-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%8C%BA%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[其实这一篇应该是作为”C++内存四区”的第一篇的。 0x00 内存分区模型C++程序在执行时，内存大方向的可划分为 *四个区域** 代码区: 存放代码的二进制代码，由操作系统进行管理。 全局区: 存放全局变量和静态变量以及常量。 栈区: 由编译器自动分配释放，存放函数的参数值，局部变量等。 堆区: 由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。 内存四区的意义:不同区域存放的数据，代表着不同的生命周期，不同的生命周期使我们可以更灵活的编程。 0x01 程序运行前在程序编译后，生成的可执行程序，当我们未执行此程序前，分为两个区域 代码区: 存放CPU执行的机器指令 共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。 只读的，为了防止程序意外修改代码的指令，所以有了只读。 如上图所示，代码区主要分为两个部分，共享区是存放常备执行的代码，例如程序员所指定的内联函数，或编译器所生成的代码，这些数据在程序跑起来会一直保存在内存中, 而只读部分是为了防止外部对程序内部的数据进行非法访问，举个栗子，你的程序设定买一个苹果需要1金币，但是某开发人员，通过某手段将此内存中的数据修改为-99999金币，那么就会造成数据非法修改。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存四区之堆区]]></title>
    <url>%2F2019%2F05%2F10%2FC-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E5%A0%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[什么是堆区由程序员分配释放的内存单元，若程序员不释放，则在程序关闭时由操作系统回收． 如何将数据放在堆区在C++中由new关键字在堆区中开辟内存。 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int* func()&#123; //创建局部指针变量，但是数据是存放在堆区的。 int *a_p= new int(10); return a_p;&#125; int main()&#123; int *p = func(); cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 输出结果为: 110 看到上述代码的创建局部指针变量，但数据存放在栈区是什么意思呢? 其实在a_p这个指针变量，仍然是一个局部变量，只不过它在由new在堆区开辟的内存中存放的，请看下图。 也就是说*a_p只不过是指向的堆区中的数据，但是这个指针变量还是存放在栈区的。函数的最终返回值时堆区的10的地址。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存四区之栈区]]></title>
    <url>%2F2019%2F05%2F10%2FC-%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%E4%B9%8B%E6%A0%88%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[什么是栈区栈区是由编译器自动分配释放的内存区块，它可以用来存放局部变量，例如函数的参数值等.. 操作栈区的注意事项在函数的返回值类型为指针或引用时，不要返回栈区内的数据， 例如返回一个局部变量的地址． 因为所有局部的数据都是存放在栈区的，而栈区的内存是由编译器自动释放的，若在编译器已把某内存单元释放后，再对那个内存单元进行操作，则会报错． 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int *func()&#123; //局部变量．存放在栈区,此变量将会在函数体执行完后自动释放． int a = 10; //尝试返回局部变量的地址 return &amp;a;&#125;int main()&#123; //接受func的返回值 int *p = func(); //输出p cout&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 输出结果: 1Process finished with exit code 139 (interrupted by signal 11: SIGSEGV) 上述代码中:func()函数的返回值类型为指针，并且它的返回值为函数体内部定义的变量a的地址，当这个函数被执行完，内部变量的内存空间将会被自动释放，所以在main函数内输出已经被释放的内存单元就会发生内存溢出的问题． 其他问题可能有些编译器在第一次输出时可以正常输出，但如果是第二次输出则会报错,因为有些编译器会保留局部变量的值．]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端多窗口神器——Screen]]></title>
    <url>%2F2019%2F05%2F09%2F%E7%BB%88%E7%AB%AF%E5%A4%9A%E7%AA%97%E5%8F%A3%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Screen%2F</url>
    <content type="text"><![CDATA[曾几何时，在你使用ssh登录到服务器时要做某个需要点时间的操作时感到烦恼。 曾几何时，在你想要在终端进行多窗口控制时，感到十分麻烦。 有了Screen,你就可以获得更好的使用终端多窗口的体验。 我想你肯定遇到以下几种情况: ftp传输 系统备份 长时间运行任务 好的，以上的这几种情况在你关掉窗口或断开链接时，任务将会被杀死，一切都没了…只能重新来过。 凶手 SIGHUP 信号 以下资料来自维基百科 SIGHUP又称为Unix信号，它是Unix、类Unix以及其他POSIX兼容的操作系统种进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被终端。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。 简单来说呢，这个SIGHUP信号就是Unix信号，它可以通过控制终端以一些特殊的按键发送某些特定的信号，这些信号有特定的功能，不过都是用来处理进程的。 发送信号在一个已运行程序的终端可键入以下组合键从而实现发送某些信号。 Ctrl-C发送INT信号(SIGINT); 缺省情况下，会导致进程终止。 Ctrl-Z发送TSTP信号(SIGTSTP); 缺省情况下，会导致进程挂起。 Ctrl-\发送QUIT信号(SIGQUIT); 缺省情况下，会导致进程终止并且将内存中的信息存储到硬盘。 前因后果相信大家每次要终止当前正在运行的进程都是键入组合键Ctrl-C，也就是说触发了一个SIGHUP信号————SIGINT，也就导致了进程终止。 更多有关SIGHUP信号的资料，我会在后面的文章进行更新。 开始使用Screen先简单说说什么是Screen: Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。(吃不吃惊，居然是个窗口管理器)。 Screen就像tty一样，可以创建多个会话，然而会话还可以创建多个screen窗口，并且每个screen都跟真实SSH/Telnet连接窗口一样。 1.创建一个screen窗口 1[evanmeek@Evan-PC]# screen 这样就创建了一个可执行shell程序的窗口，若在该窗口种键入exit则退出该窗口，又倘若该窗口是当前会话的唯一窗口，screen则会退出该会话，否则screen将会自动切换到前一个窗口。 2.创建窗口+执行命令 1[evanmeek@Evan-PC]# screen vim screen会先创建一个窗口，并且执行vim命令，若你退出vim，则该窗口也会退出。 3.一个窗口中再有一个窗口中再有一个窗口中… 你可以打开一个窗口后再输入命令打开一个窗口，也可以通过组合键C-a c(CTRL+a再按c)，screen会和段话所描述的功能一样。 4.screen的暂时断开(detach)和重新链接(attach) 比如在screen窗口下用vim编辑C++源文件 1[evanmeek@Evan-PC]# screen vim test.cpp 但写到一半，你发现要修改点东西，但是又不想退出vim编辑器，那么直接键入C-a d，Screen会提示你已挂起(detached). 当你做完其他事你就可以找回该会话，进行重新连接: 找到会话 12345[evanmeek@Evan-PC]# screen -lsThere are screens on: 17944.pts-4.EvanLinux (Detached) 14290.server (Detached)2 Sockets in /run/screens/S-evanmeek. 重新连接 1[evanmeek＠Evan-PC]# screen- r 17944 这样就可以恢复pts这个会话的窗口了． 配置你的Screen前面的几个组合键操作，可以 ，我们总是通过C-a来做开始触发的命令.screen中这个叫做按键绑定，而被绑定的C-a叫做命令字符. 可通过如下键绑定查看所有键绑定． C-a ? 常用的键绑定有： 键绑定 描述 C-a ? 显示所有键绑定信息 C-a w 显示所有窗口列表 C-a C-a 切换到之前显示的窗口 C-a c 创建一个新的运行shell的窗口并切换到该窗口 C-a n 切换到下一个窗口 C-a p 切换到前一个窗口 C-a 0~9 切换到0~9窗口 C-a a 发送C-a到当前窗口 C-a d 暂时断开screen会话 C-a k 杀掉当前窗口 C-a [ 进入拷贝/回滚模式 我们可以自己设置命令字符，使用C-a ?命令可见， 缺省的命令字符为C-a，而转义字符为a; ; 我们可以修改它，通过如下格式: -exy x:命令字符 y:转义字符 1[evanmeek@Evan-PC]# screen -e^oo 这样原本需要使用Ｃ-a a 执行的操作就需要使用C-o o来执行．]]></content>
      <categories>
        <category>折腾日记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>软件折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中的解压与压缩]]></title>
    <url>%2F2019%2F05%2F08%2FLinux%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8E%8B%E4%B8%8E%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[当我们需要传输数据时，如果是直接对文件进行传输，若数据较大，则传输时间会很长。我们可以将文件进行压缩，减少文件的体积，从而减少传输耗时。 在Windows下我们通常使用rar或zip进行压缩解压的操作，但是像rar这种软件实际是收费的，所以在Linux下使用有些不太实际。 Linux下有三种主流常用的解压压缩软件可选: gzip (GNUzip) bz2 (bzip2) xz (xzutils) 三个软件的参数相同，只是命令不同: 1$ gzip [参数] &lt;文件名&gt; 1$ bzip2 [参数] &lt;文件名&gt; 1$ xz [参数] &lt;文件名&gt; 可选参数 参数名 作用 -d 解压 -k 压缩时不删除源文件 -r 递归查找目录下的文件，并且压缩 -v 显示详细信息 -t 测试压缩包是否完整 -l 显示压缩包信息 -c 写入标准输出，保持原始文件不变 -1~9 压缩等级 示例: 压缩test.txt，并删除. 1$ gzip test.txt 压缩test.txt，不删除原文件，并且显示信息. 1$ gzip -vk test.txt 以最高压缩test.txt和test2.txt，不删除原文件，显示信息，并把压缩文件写为test.gz 1$ gzip -9cvk test.txt test2.txt &gt; test.gz 解压test.gz 1$ gzip -d test.gz 介绍完上面的几种压缩软件，下面介绍一个打包软件tar 我们常常可以看见**.tar.xz这种文件，它就是用tar打包，再用xz进行压缩的文件了，下面直接看示例你就会了。 压缩这里注意第一个参数，它们分别代表使用什么压缩软件。 bz21$ tar -jcvf test.tar.bz test/ xz1$ tar -Jcvf test.tar.xz test/ gzip1$ tar -zcvf test.tar.gz test/ 解压只需要看文件名的后缀，然后把参数c改为x即可.x代表解压. 1$ tar -Jxvf test.tar.xz test/]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++指针[基础02]]]></title>
    <url>%2F2019%2F05%2F06%2FC-%E6%8C%87%E9%92%88-%E5%9F%BA%E7%A1%8002%2F</url>
    <content type="text"><![CDATA[C++指针和数组的操作。 C++中访问数组元素可以使用如下示例进行访问: 123int arr[3]=&#123;0,1,2&#125;;cout&lt;&lt;"第2个元素为:"&lt;&lt;arr[1]&lt;&lt;endl; 想必大家都知道输出的值为:1 那么我们现在可以使用指针进行访问数组元素 数组名代表的就是当前数组的第一个元素，那么我们通过让指针指向数组的数组名，即可访问数组的第一个元素。 12345int arr[3]=&#123;0,1,2&#125;;int *p = arr;cout&lt;&lt;"p:"&lt;&lt;*p&lt;&lt;endl; 输出结果为: 1p:0 提问: 为什么指针可以指向数组名，而不需要使用引用符(&amp;)？ 疑惑解答: 那是因为在C++中，数组其实就是一块内存空间，然而里面的每个元素也就组成了一块连续的内存空间，而数组名就当任了数组的首地址的作用，那么它本身就是个地址，所以直接为赋值给指针没问题。 通过上面的疑惑解答，我们知道数组名是数组的首地址，而数组的内存空间的结构是一块连续的单元，那么我们则可以通过使用指针指向数组的数组名，再进行位偏移，这样就可以使得指针指向的是下一个单元，也就是arr[1]; 12345678int arr[3]=&#123;0,1,2&#125;;int *p = arr;//对指针进行位偏移p++;cout&lt;&lt;"p:"; 输出结果: 1p: 1 上述例子演示了，对指针p进行位偏移，从而使得p重新指向了一个内存单元，即&amp;arr[1]，为何能这样使用呢？我们知道，int类型占用4个字节，而这个指针一个指向int的指针，那么对它进行++时，它所指向的位便+4个字节，那么也就是下一个内存单元&amp;arr[1]的位置，我们通过下图更直观的查看它的变化。 最后利用指针遍历输出数组内的元素 1234567int arr[3] = &#123;0,1,2&#125;;int *p = arr;for(int i = 0;i &lt;3;i++,p++)&#123; std::cout&lt;&lt;*p&lt;&lt;std::endl;&#125; 输出结果: 123012]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++指针[基础01]]]></title>
    <url>%2F2019%2F05%2F06%2FC-%E6%8C%87%E9%92%88-%E5%9F%BA%E7%A1%8001%2F</url>
    <content type="text"><![CDATA[开始写C++中比较难理解的几个知识点的笔记。 0x00 空指针用途:给指针初始化值。 特性:空指针不可访问。 为什么不可访问? 因为空指针所指向的内存空间的编号是0~255之间的，而这之间的内存是系统预留的，不可访问。 报错例子 12345//定义空指针int *p = NULL;//尝试修改空指针所指向的空间的值,报错!*p = 2; 常用情景 1234567//定义空指针int *p = NULL;int a = 10;//使指针重新指向内存空间,可行!p = &amp;a; 小结 空指针不可访问，常用于初始化指针的操作，空指针可重新指向内存空间。 0x01 野指针说明:指针指向的是非法的内存空间叫做野指针 异常:读取访问权限错误 报错例子: 12345//使指针指向一个未知空间int *p = (int*)0x1010;//尝试修改指向的空间的值,报错!*p = 10; 小结 我们要尽量避免野指针的操作，因为它是不可控的，万一修改了系统所用空间的某个值，就有可能造成系统崩溃! 0x02 const修饰指针const修饰指针分为三种场景 const修饰指针————常量指针 const修饰常量————指针常量 const既修饰指针又修饰常量 常量指针 12345678910int a=10,b=20;//定义常量指针const int *p = &amp;a;//尝试修改指针所指向空间的值,报错!*p = 20;//指针重新指向新的空间,可行!p = &amp;b; 看上面的案例，可以得出，常量指针是不能修改所指向的空间的值，但可重新指向新的空间,并且定义时，const关键字是放在指针的左侧的。 指针常量 12345678910int a=10,b=20;//定义指针常量int * const p = &amp;a;//修改指针所指向空间的值,可行!*p=20;//尝试为指针重新指向新的空间，报错!p = &amp;b; 看上面的案例，可以得出，常量指针可修改所指向的空间的值，但不可重新指向新的空间,并且定义时，const关键字是放在指针的右侧的。 既修饰指针又修饰常量 123456789101112int a=10,b=20;//定义同时const修饰指针常量的指针const int * cosnt p = &amp;a;//尝试修改指针所指向的空间的值，报错!*p = 20;//尝试为指针重新指向新的空间，报错!p = &amp;b; 看上面的案例，可以得出，如果指针和常量都被const修饰，那么就和const 引用非常类似了。 小结 常量指针 不可修改所指向的空间的值 可重新指向新的空间 指针常量 可修改所指向的空间的值 不可重新指向新的空间 指针和常量都被const所修饰 不可修改所指向的空间的值 不可重新指向新的空间 小技巧 辨别一个指针是常量指针还是指针常量可以关注const关键字是放在指针(解除引用符”*”)的右侧还是做左侧。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>学习笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next插入网易云音乐]]></title>
    <url>%2F2019%2F04%2F30%2Fhexo-next%E6%8F%92%E5%85%A5%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[让大爷们在阅读博客时能优哉游哉的听着歌看文章。 获取外链打开网易云音乐官网 找到你喜欢的音乐，可以看到有一个生成外链播放器的超链接，点击即可。 可以设置是否自动播放和尺寸，然后把代码复制下来看如何插入外链吧! 插入外链如果是插入到文章内，直接把外链放文章里面即可，Markdown是支持的. 如果是想插入到侧边栏 需要编辑next/layout/_macro/sidebar.swig文件 此时我们就需要使用开发者工具插入到自己合适的位置下 可以看到size-overview这个div包含了很多div,你需要在sidebar.swig文件内找到这一关键词，把外链加进去即可。]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>网易云音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用hexo+github-pages搭建博客]]></title>
    <url>%2F2019%2F04%2F29%2F%E5%A6%82%E4%BD%95%E7%94%A8hexo-github-pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[成功搭建博客之后，想让一起学习的小伙伴也学习搭建一下，所以就有了此篇文章. 为何选择hexo hexo博客框架的网上资料较多，技术较为成熟. hexo使用Makrdown进行渲染. hexo只需几步就可部署博客. hexo具有丰富的主题/插件可选. 安装hexo安装Nodejs,Git要安装hexo必须得安装Nodejs和Git，这里只提供GNU/Linux的过程。 大部分发行版自带Git,Nodejs只需要一条命令: apt 1$ sudo apt install nodejs npm pacman 1$ sudo pacman -S nodejs npm 配置Nodejs安装完成Nodejs和Git后还需要设置npm的软件源. 在任意目录下执行如下命令: 1$ npm config set registry https://registry.npm.taobao.org 执行如下命令测试是否设置成功(若范围淘宝的npm镜像源地址则成功): 1$ npm config get registry 配置Git注册Github注册Github 创建仓库创建Github仓库 注意: 仓库名必须是name.github.io 例如我的 evanmeek.github.io 需要设置两点: Git身份标识 12$ git config --global user.email "你的邮箱"$ git config --global user.name "你的名字" 推荐把邮箱和名字设置为Github上的邮箱和名字相同 SSH密钥 如果是第一次使用Git，那么默认是没有SSH密钥的，执行如下命令查看: 1$ ls ~/.ssh 若没有则创建新的密钥 1$ ssh-keygen -t rsa -C "你的邮箱" 创建密钥时会提示你输入一个密码，这样在用这里密钥时就需要输入密码，若不需要直接一路回车吧。 创建完成后，你会在~/.ssh内看到两个文件 分别是私钥(id_rsa),公钥(id_rsa.pub) 下一步则是需要在Github中添加刚刚生成的密钥 首先登陆Github,打开设置. 如图所示： 下一步找到SSH选项 如图所示： 下一步导入公钥 复制公钥的内容复制到key文本框内，Title随便写一个，可以写你的设备名 1$ cat ~/.ssh/id_rsa.pub 安装hexo前面安装完Nodejs和Git之后可以通过一条命令安装hexo 要使用sudo提权 执行如下命令: 1$ npm install -g hexo-cli 看到Done!之后则为安装成功. 开始搭建初始化hexo博客使用如下命令初始化博客 1$ hexo init &lt;目录&gt; 初始化完成之后目录结构大概是这样的: 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 下面分别讲下这些文件或目录分别存放了些什么。 主配置文件: _config.yml 主要用于博客的配置信息，后面还会在themes里看到_config.yml，和这个不同，我们只要记住这个是博客的主配置文件. 插件信息: package.json 包含了当前hexo博客中安装了哪些插件. 模板目录: scaffolds/ 里面包含了可定制的模板文件，在创建或生成新的博文时就会按照这里的模板进行渲染. 资源目录: source/ 在这里包含了你的一些资源文件，例如文章源码，图片等，要注意的是_posts目录并不会在生成渲染时并不会被拷贝到public目录下. 主题目录: themes/ 主题目录，所有的主题都丢在这里。 生成博客执行如下命令创建一篇博文: 1$ hexo n "文章名" hexo会在source/_posts目录下创建一个markdown文档，这样就可以开始编写了! 这一步用于生成静态文件(就是把md转为html的操作) 要在网站目录(就是初始化的目录下)下执行 1$ hexo generate 这个命令可以简化，并且还可以带两个参数 简化+参数:123$ hexo g -d # 生成+部署(也就是推送到github pages去了，你们先不要执行这一步)$ hexo g -w # 可以监视有哪些文件被生成了 配置hexo这里的user.email和user.name可以不是Github的邮箱或名字，但推荐设置为Github相同. 下面配置hexo，对于hexo的修改，可以通过_config.yml文件修改大多数设置。 找到deploy项 修改为: type为git不能为大写 部署博客部署博客这里只讲两种，分别是通过Git推送到远程代码托管中心(Github)和本地部署 本地部署 执行如下命令:1$ npm install hexo-deployer-git --save 1$ hexo s 执行完后可以通过localhost:4000进行查看. 部署到Github 1$ hexo d 这样就可以部署到Github了，通过https://你的Github用户名.github.io访问 寻找主题Hexo主题 把主题clone到博客目录的themes下，并且修改博客目录下的文件_config.yml的theme项为主题名称，重新生成就可以了。 使用体验还是有一些坑要踩的，如有问题，联系邮箱the_lty_mail@foxmail.com]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客文章插入图片]]></title>
    <url>%2F2019%2F04%2F29%2Fhexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前言在撰写博客文章时，我们会向文章插入一些图片，但是hexo本身要插入图片比较麻烦，这边就可以使用hexo的一款插件，它可以让我们插入图片非常简单。 如何安装安装此插件很简单，你只需要在你的hexo目录下执行如下命令: 1$ npm install hexo-asset-image --save 如果安装速度很慢可以把npm源改为国内源。 点击打开npm源改为国内源的方法 在设置镜像源-&gt;npm国内源下 如何使用第一步首先，我们得先设置主目录(博客目录)下的 _config.yml 文件. 找到 post_asset_folder: 项，将其修改为 true 第二步使用也十分简单，hexo-asset-image可以时hexo在创建文章时自动在文章保存目录下创建一个同名的目录。 然后我们就可以把要插入的图片放入其目录，在文章中使用Markdown的插入图片语法即可。 栗子12$ hexo n "test"$ mv test.jpg source/_posts/test 插入图片 123![图片alt](图片地址)# ![test](./test/test.jpng)]]></content>
      <categories>
        <category>折腾记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++函数探幽]]></title>
    <url>%2F2019%2F04%2F24%2FC-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD%2F</url>
    <content type="text"><![CDATA[本章内容 内联函数 引用变量 如何按引用传递函数参数 默认参数 函数重载 函数模板 函数模板具体化 本章是介绍C++在C基础上新增的特性，是进入C++领域重要的一步． C++内联函数 说明 内联函数是C++为提高程序运行速度所做出的一项改进．常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中．要了解内联函数与常规函数之间的区别，必须深入到程序内部． 那么，我们现在就深入到程序内部． 首先我们知道，编译器会把我们的源代码编译成可执行程序－－－－由一组机器语言组成． 当我们运行它时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址．随后计算机将会逐步执行这些指令． 执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到被保存的指令处． 那么，来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销． 所以 C++内联函数就提供了另一种选择．内联函数的编译代码与其他程序代码＂内联＂(结合/融合)起来． 相当于编译器将使用相应的函数代码替换函数调用． 对于内联代码，程序就不用像常规函数那样跳转，只需要将函数定义时的代码复制一份到函数调用时的位置，直接执行即可，这样将会省去函数调用时，疯狂跳转，标记的开销． 但是 虽说这样在某种程度上速度确实要快，但是也是有代价的，例如，程序在N个地方调用同一个内联函数，那么改程序将包含该函数代码的10个副本．这样就会有更大的内存开销，虽然运行速度比常规函数的调用快． 结论 我们应该在不同的场景选择不同编写函数的方式．如果执行函数代码的时间比处理函数调用机制的时间长，则节省时间只占整个过程的很小一部分，如果代码执行时间短，则内联函数的调用就可以节省非内联函数调用时间的大部分时间． 另一方面，由于整个过程相当快，因此就算节省了该过程的大部分时间，但节省时间的绝对值并不大． _除非_ :该函数被经常调用 使用 使用内联函数只需要做到以下两点即可： 在函数声明前加上关键字inline; 在函数定义前加上关键字inline; 通常的写法是省略原型，将整个定义(函数头和所有的函数代码)放在本应提供原型的地方． 可能遇到的问题 在我们编写函数为内联函数时，编译器不一定满足这种要求． 编译器认为该函数过大或识别到函数调用了自己 (内联函数不能递归) . 有些编译器没有启动或实现这种特性． 案例 12345678910111213141516#include &lt;iostream&gt;using namespace std;inline double square(double x) &#123; return x * x; &#125;int main() &#123; double a(2.0), b(5.0), c(0); cout &lt;&lt; "此时a=" &lt;&lt; a &lt;&lt; "\tb=" &lt;&lt; b &lt;&lt; " \tc=" &lt;&lt; c &lt;&lt; endl; square(a); b = square(b); c = square(7 + 1); cout &lt;&lt; "此时a=" &lt;&lt; a &lt;&lt; "\tb=" &lt;&lt; b &lt;&lt; "\tc=" &lt;&lt; c &lt;&lt; endl; return 0;&#125; 该程序的输出为: 12此时a=2 b=5 c=0此时a=4 b=25 c=64 看到上面这个例子，自然就知道不管是内联函数还是常规函数，都是按值传递参数的． 也就是说，例如 c=square(7+1) 这段代码调用square函数时将会先计算7+1的值再传递给形参x，这就是按值传递. 这使得C++的内联功能远远胜过C语言的宏定义 尽管程序没有提供单独的函数原型，但C++的原型特征仍在起作用，因为首次函数出现时是定义函数那么就会充当函数原型. 这也就意味着，如果给square()传递int或long类型的值，程序将回自动进行强制类型转换为double类型再把值复制给形参 内联与宏inline是C++新增的特性. C语言使用预处理语句#define来提供宏－－内联代码的原始实现． 例如下面这个例子. 12345#define SQUARE(X) X*Xa = SQUARE(2.0);b = SQUARE(3.2++);c = SQUARE(1+2.3); 上述示例只有第一个调用才能正常工作，因为C语言的宏定义不是按值传递的． 引用变量引用变量是C++新增的一种复合类型. 引用是为已定义的变量创建了一个别名． 例如，将变量a作为b的引用，则不管是使用a还是b都可以表示该变量，因为它们的内存块相同. 引用变量通常的使用场景是作为函数的形参． 通过将引用变量作为参数，那么函数将使用原始数据，而不是使用其副本．这样除了指针外引用也可以作为处理大型数据结构的一种途径． 创建引用变量C++使用 &amp; 用于声明引用，但是它还有另外一个作用：地址运算符。 当&amp;为声明引用时可有这样的一个例子: 12int a;int &amp; b = a; 是否感觉跟指针有点相像呢？ 是的，它们确实有点相似，就像声明中double*是指指向double类型的指针，而int&amp;是指指向int的引用。 上面的例子：引用声明允许将a和b互换————它们指向相同的值和内存单元。 下面再看一个例子，你将懂得C++中使用&amp;时引用和地址运算符的区别。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; int a=1; int &amp; b = a; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; b = 2; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;"a-address:"&lt;&lt;&amp;a&lt;&lt;endl; cout&lt;&lt;"b-address:"&lt;&lt;&amp;b&lt;&lt;endl; return 0;&#125; 输出结果为: 123456a:1b:1a:2b:2a-address:0x7ffdd4c4ae74b-address:0x7ffdd4c4ae74 首先我们声明定义了两个变量，一个是a，一个是b，b是指向int类型a变量的引用，所以它们的值和内存单元相同。 然后b被重新赋值，也就是修改它内存单元的值，相应的与它在同块内存单元的a值也随之变化。 再然后，我们输出的不是a和b的值了而是输出它们的地址: 1cout&lt;&lt;"a-address:"&lt;&lt;&amp;a&lt;&lt;endl; 此时的&amp;代表的就是地址运算符。 经过上面的一些小例子，读者们可能认为C++中&amp;为引用的作用时与指针完全一样啊，但他们还是有些不同的，下面将指出有何不同。 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; int a,*p; int b,*p2(&amp;b); *p = a; return 0;&#125; 上述代码是可以编译通过的。 指针在声明时编译器允许不为其进行初始化值 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; int a,&amp;b; b = a; return 0;&#125; 如果代码是这样，那么则编译不通过。 我们可以把引用看成cosnt指针，因为const指针是必须在创建时进行初始化，一旦于某个变量关联起来，则只能与此变量进行操作。 也就是说： 1int a,&amp;b(a); 仅在表示上等同于 12int a;const int *p(&amp;a); 上面提到“仅在表示上等同于“为什么呢，请看下面的例子。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int a(10),&amp;b(a); cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; int c(20); b = c; cout&lt;&lt;"c:"&lt;&lt;c&lt;&lt;endl; cout&lt;&lt;"a:"&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;"b:"&lt;&lt;b&lt;&lt;endl; return 0;&#125; 输出结果为: 12345a:10b:10c:20a:20b:20 可以看到最初b引用的是a，但随后b作为c的引用： 1b = c; 这就根const指针不同了，因为引用是可以改变引用的对象的，而const指针是不能改变指向的对象的. 我们仔细研究上面的代码可以发现，因为b的引用对象变化，使得b原先引用对象的值也随之发生了变化，这是由于b和a的地址相同，而该地址与c的地址不同。由于b是a的别名，因此上述赋值语句等效于: 1a = c; 也就是说，这意味着”将c变量的值赋给a变量“。 简而言之，可以通过初始化声明来设置引用，但不能通过赋值来设置。 下面有一段有趣的代码，你们可以看看。 12345int a(10);int *p =&amp;a;int &amp;b = *p;int c(20);*p = &amp;c; 上述代码首先是指针p指向的a，而b引用*p(相当于引用a),而后面指针p改变了指向的对象，但是b依然是引用a的。 将]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ManjaroLinux的安装过程]]></title>
    <url>%2F2019%2F04%2F23%2FManjaroLinux%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[获取镜像ManjaroLinux官方提供了多个桌面环境的镜像，分别是: XFCE 特点 系统资源低耗，快速 KDE 特点 高可定制化，消耗系统资源相比XFCE要大，开机时内存占用大概500MB+ GNOME 特点 简单易用，可定制化，美化较为简单，内存占用大 并且ManjaroLinux在国内有4个镜像源可选，分别是: 清华大学 中科大 华为 浙江大学 我们也可以直接使用官方的镜像源获取镜像Manjaro 选择好自己要使用的桌面环境就可以开始制作启动盘了。 制作启动盘Windows: 推荐使用Rufus进行制作启动盘。 下载好后直接选择镜像和要进行制作的U盘，选择开始。 开始时会让你勾选制作方式请选择dd模式 Linux: 只需要执行这几条命令 1$ sudo lsblk #列出系统上的所有磁盘 找到大小磁盘大小跟你U盘差不多的那个磁盘名，一般来说都是sdb或sda 如果看到你的U盘对应的MOUNTPOINT有内容，就代表目前磁盘是被挂在了的，你就需要先取消挂载. 1$ sudo umount /dev/sda* #这里的sda是你U盘的磁盘名， 取消挂载之后就可以进行格式化了. 1$ sudo mkfs.vfat /dev/sda #注意这里没有*，并且同上一样sda是你的磁盘名. 格式化完成后，进入到你下载的镜像目录下，开始进行制作启动盘. 1$ sudo dd bs=4M if=你的iso镜像路径 of=/dev/sda 如果终端内有一些返回信息，大概是xxMB/s这样的，就代表制作完成，可以关机已U盘启动了。 开始安装最好是在网络稳定的环境下进行 第一步如果启动盘顺利制作成功，并且设置BISO为以U盘启动，你将会看到: keytable————设置键盘布局 通常默认即可 lang————设置语言 设置为zh_CN，代表汉语 driver————设置使用的驱动是开源的还是不开源的 笔记本双显卡，想省电可以用free。 台式机单显卡，推荐nofree。 Boot————选择这个就开始安装了 第二步等待一会就会进入Manjaro的live系统(临时系统，可以用于修复系统或体验系统) 这个就是欢迎页面了，包含了些Manjaro的使用文档，支持，参加项目等等。 标题栏的左边有个下拉栏，可以选择语言，然后点击Lanunch installer或者开始安装即可。 点击后还可以设置一次语言，默认为中文了 然后就设置位置，用于设置时区的，我们选择Asia-Shanghai，如果有联网通常会自动选择。 下一步就是设置键盘布局，直接默认就好，有特殊需求请自行折腾。 再下一步就是分区了，这一步是挺重要的，请认真看。 默认情况下有两种选项: 抹除磁盘 将磁盘全部数据清除，分区是Manjaro自动帮你分配的. 这里可以主要到有两个选项，Swap(no Hibernate)和(witch Hibernate)，它们的区别分别是，交换空间是否用于休眠功能。 手动分区 选择手动分区之后，你将看到: 如果你是单硬盘(也就是只有一个硬盘,mdzz) 那比较简单(就算有多个也没啥) 点击新建分区表，会让你选择创建哪种，默认第一种即可（新手都推荐MBR，我不是歧视…) 然后就可以看到有一个空闲空间，选中它，然后可以看到创建按钮可以点击了 然后你就点击吧… 你就可以看到创建分区的窗口，我们要创建的分区是根目录,主目录，引导 引导的挂载点: /boot/efi 记得标记点为:boot 和 esp 根目录的挂载点: / 记得标记点为:root 主目录的挂载点: /home 如果是多硬盘，在存储器那里选择另一块磁盘，把主目录安装在那。 要注意的是主目录要选择扩展分区。 下一步就是设置一些用户信息啊，密码啊什么的，自己看着来，这里写几点不要做的事。 用户名首字母不要大写 密码不要太简单 下一步摘要可以看到一些信息，你看你自己的分区有没有搞错，看不懂的话直接下一步吧。。。 静静等待吧..安装好后会提示你重启，你也可以再玩一下。。不过一般是等不及直接重启看新系统了。 设置镜像源选择一个好的源是使用Linux体验是否良好的一个重要因素。 官方软件包源12$ sudo pacman-mirrors -i -c China -m rank$ sudo pacman -Syu 随便选一个就好，推荐中科大的(USTC). Aur软件包源123$ sudo vim /etc/pacman.conf #不一定要使用vim，你可以使用其他编辑器，如果没有默认安装vim可以用vi$ sudo pacman -Syu 在最后一行输入: 12[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 安装签名 1$ sudo pacman -S archlinuxcn-keyring npm国内源首先你得先下载npm和nodejs 1$ sudo pacman -S npm nodejs 打开终端输入: 1$ npm config set registry https://registry.npm.taobao.org 测试是否成功: 1$ npm config get registry 如果看到上面这个链接就对了 pip国内源修改~/.pip/pip.conf (没有则创建) 修改为:1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com 你也可以使用其他的源 清华 阿里云 中国科技大学 豆瓣 安装软件首先安装yay，它可以像使用pacman一样安装aur里面的软件，aur即第三方软件库 Install Yay 1$ sudo pacman -S yay 安装Vim，VSCode，CLion，IDEA，网易云，搜狗输入法，Chrome，微信，OracleJDK8 Install Vim 1$ sudo pacman -S Vim Install VSCode 1$ sudo pacman -S visual-studio-code-bin #pacman用的是vscode的二进制 Install OracleJDK8 1$ yay -S jdk8 #这里就是由第三方打包了的 Install 搜狗输入法 1$ sudo pacman -S fcitx-im fcitx-configtool fcitx-sogoupinyin 再编辑配置文件~/.xprofile(若没有创建即可) 修改为: 12345export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 注销后就能使用搜狗输入法了 Install IDEA 12$ yay -S intellij-idea-community-edition #社区版 IDEA$ yay -S intellij-idea-ultimate-edition #付费版 IDEA Install CLion 1$ yay -S CLion Install 网易云音乐 1$ sudo pacman -S netease-cloud-music Install Chrome 1$ sudo pacman -S google-chrome 这样就能完成基本的日常使用啦~ 使用体验总结稀稀算来，我用Linux也有一年多了，中间尝试了Ubuntu-16.04,18.04 Deepin-15.6-&gt;15.9.4 LinuxMint17 ArchLinux 最终还是选择了Manjaro-kde 非常建议配置不是太差的同学可以用下kde桌面，相比gnome可定制化更强（gnome更简单)，并且我感觉kde比gnome流畅些，也要比dde流畅。 这个总结也没有太完善，以后还会开篇新文章写的，最后秀图。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>折腾</tag>
        <tag>软件使用</tag>
      </tags>
  </entry>
</search>
